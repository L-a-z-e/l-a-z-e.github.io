---
title: 알고리즘의 효율 분석
description: Coding Test Java
author: laze
date: 2025-03-20 00:00:05 +0900
categories: [Dev, CodingTest]
tags: [CodingTest, Java]
---
# 알고리즘의 효율 분석

**시간 복잡도**

- 알고리즘의 성능을 나타내는 지표
- 입력 크기에 대한 연산 횟수의 상한을 의미

1 차원 배열 검색

- 값을 가장 빨리 찾는 경우 → 검색 시작 위치에 찾을 값이 바로 있는 경우
- 값을 가장 늦게 찾는 경우 → 찾으려는 값이 없거나 마지막에 위치하는 경우

알고리즘 수행 시간을 측정하는 방법

- 절대 시간을 측정하는 방법
    - 실제 시간 측정
    - 프로그램 실행 환경에 따라 달라질 수 있어서 코딩테스트에서는 활용하지 않음
- 시간 복잡도를 측정하는 방법
    - 입력 크기에 따른 연산 횟수의 추이를 활용해서 시간 복잡도를 표기하는 점근적 표기법 사용
        - 빅오 표기법
            - 최악의 경우 시간 복잡도를 표현
            - 최고 차항만 남기고 계수를 지워서 표현
            - x! > 2**x > x ** 2 > xlogx > x
    - 컴퓨터가 초당 연산할 수 있는 최대 횟수 1억 번
    
    | 시간복잡도 | N의 가용범위 |
    | --- | --- |
    | O(N!) | 10 |
    | O(2**N) | 20~25 |
    | O(N**3) | 200~300 |
    | O(N**2) | 3000~5000 |
    | O(NlogN) | 100만 |
    | O(N) | 1000~2000만 |
    | O(logN) | 10억 |
- 시간 복잡도 계산
    - 1번째 줄 1개 2번째줄 2개 N번째 줄 N개 별찍기
        - f(N) = 1 + 2 + 3 + … + N = N(N+1) / 2 ⇒ O(N**2)
    - 박테리아 수명 문제
        - 초기 박테리아 세포 N 개 해마다 세포가 이전 세포 개수의 반으로 준다면 N 입력시 출력 값 계산
        - 현재 박테리아가 N 일때 1년 뒤 박테리아 수는 1/2 * N, Y년 후 박테리아 수는 (1/2)**Y * N
        - (1/2)**Y * N 의 값이 최초로 1보다 작아질 때
        - 결국 N/2**Y < 1 양변에 2 ** Y 곱하면 2 ** Y  > N 이고 양변에 로그를 취하면 Y > log2 N
        - O(logN) 의 시간 복잡도