---
title: Spring Framework Java Bean Validation
description: 
author: laze
date: 2025-05-05 00:00:08 +0900
categories: [Dev, SpringBoot]
tags: [SpringBoot]
---
**Java Bean Validation**

스프링 프레임워크는 Java Bean Validation API를 지원합니다.

**Bean Validation 개요 (Overview of Bean Validation)**

Bean Validation은 자바 애플리케이션을 위한 제약 조건 선언과 메타데이터를 통해 유효성 검사를 수행하는 공통적인 방법을 제공합니다.

이를 사용하려면 도메인 모델 속성에 선언적인 유효성 검사 제약 조건을 어노테이션으로 달고, 이는 런타임에 의해 강제됩니다.

내장된 제약 조건들이 있으며, 자신만의 커스텀 제약 조건을 정의할 수도 있습니다.

다음 예제는 두 개의 속성을 가진 간단한 `PersonForm` 모델을 보여줍니다:

```java
// Java
public class PersonForm {
	private String name;
	private int age;
}
```

```kotlin
// Kotlin
data class PersonForm(var name: String? = null, var age: Int = 0)
```

Bean Validation은 다음 예제와 같이 제약 조건을 선언할 수 있게 합니다:

```java
// Java
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;

public class PersonForm {

	@NotNull
	@Size(max=64)
	private String name;

	@Min(0)
	private int age;
}
```

```kotlin
// Kotlin
import jakarta.validation.constraints.Min
import jakarta.validation.constraints.NotNull
import jakarta.validation.constraints.Size

data class PersonForm(
    @field:NotNull // Apply to the field generated by the property
    @field:Size(max = 64)
    var name: String? = null,

    @field:Min(0)
    var age: Int = 0
)
```

그러면 Bean Validation 검증기(validator)는 선언된 제약 조건에 따라 이 클래스의 인스턴스를 검증합니다.

**Bean Validation 제공자 구성하기 (Configuring a Bean Validation Provider)**

스프링은 Bean Validation 제공자를 스프링 빈으로 부트스트래핑하는 것을 포함하여 Bean Validation API를 완벽하게 지원합니다.

이를 통해 애플리케이션에서 유효성 검사가 필요한 곳 어디든 `jakarta.validation.ValidatorFactory` 또는 `jakarta.validation.Validator`를 주입할 수 있습니다.

다음 예제와 같이 `LocalValidatorFactoryBean`을 사용하여 기본 `Validator`를 스프링 빈으로 구성할 수 있습니다:

**Java**

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.validation.beanvalidation.LocalValidatorFactoryBean;

@Configuration
public class AppConfig {

	@Bean
	public LocalValidatorFactoryBean validator() { // Default validator bean
		return new LocalValidatorFactoryBean();
	}
}
```

**XML**

```xml
<bean id="validator"
	class="org.springframework.validation.beanvalidation.LocalValidatorFactoryBean"/>
```

앞의 예제의 기본 구성은 기본 부트스트랩 메커니즘을 사용하여 bean validation이 초기화되도록 트리거합니다.

Hibernate Validator와 같은 Bean Validation 제공자가 클래스패스에 존재할 것으로 예상되며 자동으로 감지됩니다.

*Jakarta Validator 주입하기 (Inject Jakarta Validator)*`LocalValidatorFactoryBean`은 `jakarta.validation.ValidatorFactory`와 `jakarta.validation.Validator`를 모두 구현하므로,

다음 예제와 같이 Bean Validation API를 직접 사용하는 것을 선호한다면 후자에 대한 참조를 주입하여 유효성 검사 로직을 적용할 수 있습니다:

```java
// Java
import jakarta.validation.Validator;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class MyService {

	@Autowired
	private Validator validator; // Inject jakarta.validation.Validator
}
```

```kotlin
// Kotlin
import jakarta.validation.Validator
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.stereotype.Service

@Service
class MyService {
    @Autowired
    private lateinit var validator: Validator // Inject jakarta.validation.Validator
}
```

*스프링 Validator 주입하기 (Inject Spring Validator)*`jakarta.validation.Validator`를 구현하는 것 외에도,

`LocalValidatorFactoryBean`은 `org.springframework.validation.Validator`에도 적응하므로, 빈이 스프링 Validation API를 요구하는 경우 후자에 대한 참조를 주입할 수 있습니다.

```java
// Java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.validation.Validator;

@Service
public class MyService {

	@Autowired
	private Validator validator; // Inject org.springframework.validation.Validator
}
```

```kotlin
// Kotlin
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.stereotype.Service
import org.springframework.validation.Validator // Spring's Validator

@Service
class MyService {
    @Autowired
    private lateinit var validator: Validator // Inject org.springframework.validation.Validator
}
```

`org.springframework.validation.Validator`로 사용될 때,

`LocalValidatorFactoryBean`은 내부의 `jakarta.validation.Validator`를 호출한 다음 `ConstraintViolation`을 `FieldError`로 변환하고 `validate` 메소드에 전달된 `Errors` 객체에 등록합니다.

**커스텀 제약 조건 구성하기 (Configure Custom Constraints)**

각 bean validation 제약 조건은 두 부분으로 구성됩니다:

- 제약 조건과 구성 가능한 속성을 선언하는 `@Constraint` 어노테이션.
- 제약 조건의 동작을 구현하는 `jakarta.validation.ConstraintValidator` 인터페이스 구현.

선언을 구현과 연결하기 위해, 각 `@Constraint` 어노테이션은 해당하는 `ConstraintValidator` 구현 클래스를 참조합니다.

런타임 시, `ConstraintValidatorFactory`는 도메인 모델에서 제약 조건 어노테이션이 발견될 때 참조된 구현을 인스턴스화합니다.

기본적으로 `LocalValidatorFactoryBean`은 스프링을 사용하여 `ConstraintValidator` 인스턴스를 생성하는 `SpringConstraintValidatorFactory`를 구성합니다.

이를 통해 커스텀 `ConstraintValidators`가 다른 스프링 빈처럼 의존성 주입의 이점을 누릴 수 있습니다.

다음 예제는 커스텀 `@Constraint` 선언과 스프링을 사용하여 의존성 주입을 사용하는 연관된 `ConstraintValidator` 구현을 보여줍니다:

```java
// Java - Custom Constraint Annotation
import jakarta.validation.Constraint;
import java.lang.annotation.*;

@Target({ElementType.METHOD, ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy=MyConstraintValidator.class) // Link to validator
public @interface MyConstraint {
    // Include message, groups, payload as required by Bean Validation spec
    String message() default "Invalid value";
    Class<?>[] groups() default {};
    Class<? extends jakarta.validation.Payload>[] payload() default {};
}
```

```kotlin
// Kotlin - Custom Constraint Annotation
import jakarta.validation.Constraint
import kotlin.reflect.KClass

@Target(AnnotationTarget.FIELD, AnnotationTarget.FUNCTION) // Applicable targets
@Retention(AnnotationRetention.RUNTIME)
@Constraint(validatedBy = [MyConstraintValidator::class]) // Link to validator
annotation class MyConstraint(
    val message: String = "Invalid value",
    val groups: Array<KClass<*>> = [],
    val payload: Array<KClass<out jakarta.validation.Payload>> = []
)
```

```java
// Java - Custom Constraint Validator
import jakarta.validation.ConstraintValidator;
import jakarta.validation.ConstraintValidatorContext;
import org.springframework.beans.factory.annotation.Autowired;

// Assuming Foo class exists
class Foo {}

public class MyConstraintValidator implements ConstraintValidator<MyConstraint, Object> { // Implement ConstraintValidator

	@Autowired // Inject dependencies
	private Foo aDependency;

	@Override
	public void initialize(MyConstraint constraintAnnotation) {
		// Initialization logic if needed
	}

	@Override
	public boolean isValid(Object value, ConstraintValidatorContext context) {
		// Validation logic using the dependency and the value
		// Return true if valid, false otherwise
		// Example: checkNotNull(aDependency);
		return true; // Placeholder
	}
}
```

```kotlin
// Kotlin - Custom Constraint Validator
import jakarta.validation.ConstraintValidator
import jakarta.validation.ConstraintValidatorContext
import org.springframework.beans.factory.annotation.Autowired

// Assuming Foo class exists
class Foo {}

class MyConstraintValidator : ConstraintValidator<MyConstraint, Any?> { // Implement ConstraintValidator

    @Autowired
    private lateinit var aDependency: Foo // Inject dependencies

    override fun initialize(constraintAnnotation: MyConstraint?) {
        // Initialization logic if needed
    }

    override fun isValid(value: Any?, context: ConstraintValidatorContext?): Boolean {
        // Validation logic using the dependency and the value
        // Return true if valid, false otherwise
        // Example: checkNotNull(aDependency);
        println("Validating with dependency: $aDependency and value: $value")
        return true // Placeholder
    }
}
```

앞의 예제에서 보여주듯이, `ConstraintValidator` 구현은 다른 스프링 빈처럼 의존성을 `@Autowired`할 수 있습니다.

**스프링 주도 메소드 유효성 검사 (Spring-driven Method Validation)**

`MethodValidationPostProcessor` 빈 정의를 통해 Bean Validation의 메소드 유효성 검사 기능을 스프링 컨텍스트에 통합할 수 있습니다:

**Java**

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.validation.beanvalidation.MethodValidationPostProcessor;

@Configuration
public class ApplicationConfiguration {

	@Bean
	public static MethodValidationPostProcessor validationPostProcessor() { // Must be static
		return new MethodValidationPostProcessor();
	}
}
```

**Kotlin**

```kotlin
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.validation.beanvalidation.MethodValidationPostProcessor

@Configuration
class ApplicationConfiguration {
    companion object { // Bean methods for post-processors must be static
        @Bean
        @JvmStatic // Ensure static for Spring
        fun validationPostProcessor(): MethodValidationPostProcessor {
            return MethodValidationPostProcessor()
        }
    }
}
```

**Xml**

```xml
<bean class="org.springframework.validation.beanvalidation.MethodValidationPostProcessor"/>
```

스프링 주도 메소드 유효성 검사 대상이 되려면, 대상 클래스는 스프링의 `@Validated` 어노테이션으로 어노테이션되어야 하며, 이는 선택적으로 사용할 유효성 검사 그룹을 선언할 수도 있습니다.

Hibernate Validator 및 Bean Validation 제공자와의 설정 세부 정보는 `MethodValidationPostProcessor`를 참조하십시오.

*메소드 유효성 검사는 대상 클래스 주변의 AOP 프록시에 의존하며, 인터페이스의 메소드에는 JDK 동적 프록시 또는 CGLIB 프록시를 사용합니다.*

*프록시된 클래스의 메소드와 접근자(accessor)를 항상 사용해야 한다는 점을 기억하십시오.*

*직접적인 필드 접근은 작동하지 않습니다.*

*스프링 MVC 및 WebFlux는 AOP 없이 동일한 기본 메소드 유효성 검사를 내장 지원합니다.*

**메소드 유효성 검사 예외 (Method Validation Exceptions)**

기본적으로, `jakarta.validation.Validator`가 반환하는 `ConstraintViolation` 집합과 함께 `jakarta.validation.ConstraintViolationException`이 발생합니다.

대안으로, 대신 `ConstraintViolation`이 `MessageSourceResolvable` 오류로 변환된 `MethodValidationException`이 발생하도록 할 수 있습니다.

활성화하려면 다음 플래그를 설정하십시오:

**Java**

```java
@Configuration
public class ApplicationConfiguration {

	@Bean
	public static MethodValidationPostProcessor validationPostProcessor() {
		MethodValidationPostProcessor processor = new MethodValidationPostProcessor();
		processor.setAdaptConstraintViolations(true); // Adapt violations
		return processor;
	}
}
```

**Kotlin**

```kotlin
@Configuration
class ApplicationConfiguration {
    companion object {
        @Bean
        @JvmStatic
        fun validationPostProcessor(): MethodValidationPostProcessor {
            val processor = MethodValidationPostProcessor()
            processor.setAdaptConstraintViolations(true) // Adapt violations
            return processor
        }
    }
}
```

**Xml**

```xml
<bean class="org.springframework.validation.beanvalidation.MethodValidationPostProcessor">
    <property name="adaptConstraintViolations" value="true"/>
</bean>
```

`MethodValidationException`은 메소드 파라미터별로 오류를 그룹화하는 `ParameterValidationResult` 목록을 포함하며,

각 결과는 `MethodParameter`, 인수 값 및 `ConstraintViolation`에서 변환된 `MessageSourceResolvable` 오류 목록을 노출합니다.

필드 및 속성에 대한 계단식 위반(cascaded violations)이 있는 `@Valid` 메소드 파라미터의 경우,

`ParameterValidationResult`는 `org.springframework.validation.Errors`를 구현하고 유효성 검사 오류를 `FieldError`로 노출하는 `ParameterErrors`입니다.

**유효성 검사 오류 사용자 정의하기 (Customizing Validation Errors)**

변환된 `MessageSourceResolvable` 오류는 로케일 및 언어 특정 리소스 번들이 있는 구성된 `MessageSource`를 통해 사용자에게 표시할 오류 메시지로 변환될 수 있습니다.

```java
// Java
import jakarta.validation.Valid;
import jakarta.validation.constraints.Max;
import jakarta.validation.constraints.Size;
import org.springframework.validation.annotation.Validated;

record Person(@Size(min = 1, max = 10) String name) { // Using record for brevity
}

@Validated // Enable method validation
public class MyService {

	void addStudent(@Valid Person person, @Max(2) int degrees) { // @Valid enables cascaded validation
		// ...
	}
}
```

```kotlin
// Kotlin
import jakarta.validation.Valid
import jakarta.validation.constraints.Max
import jakarta.validation.constraints.Size
import org.springframework.validation.annotation.Validated

data class Person(@field:Size(min = 1, max = 10) var name: String?) // Data class

@Validated // Enable method validation
class MyService {
    fun addStudent(@Valid person: Person, @Max(2) degrees: Int) { // @Valid enables cascaded validation
        // ...
    }
}
```

`Person.name()`의 `ConstraintViolation`은 다음을 포함하는 `FieldError`로 변환됩니다:

- 오류 코드: `"Size.person.name"`, `"Size.name"`, `"Size.java.lang.String"`, `"Size"`
- 메시지 인수: `"name"`, `10`, `1` (필드 이름 및 제약 조건 속성)
- 기본 메시지: `"size must be between 1 and 10"`

기본 메시지를 사용자 정의하려면 위의 오류 코드와 메시지 인수 중 하나를 사용하여 `MessageSource` 리소스 번들에 속성을 추가할 수 있습니다.

메시지 인수 `"name"` 자체도 오류 코드 `"person.name"` 및 `"name"`을 가진 `MessageSourceResolvable`이며 사용자 정의할 수 있다는 점에 유의하십시오.

```
# messages.properties
Size.person.name=Please, provide a {0} that is between {2} and {1} characters long
person.name=username
```

`degrees` 메소드 파라미터의 `ConstraintViolation`은 다음을 포함하는 `MessageSourceResolvable`로 변환됩니다:

- 오류 코드: `"Max.myService#addStudent.degrees"`, `"Max.degrees"`, `"Max.int"`, `"Max"`
- 메시지 인수: `"degrees"`, `2` (필드 이름 및 제약 조건 속성)
- 기본 메시지: `"must be less than or equal to 2"`

위의 기본 메시지를 사용자 정의하려면 다음과 같은 속성을 추가할 수 있습니다:

```
# messages.properties
Max.degrees=You cannot provide more than {1} {0}
```

**추가 구성 옵션 (Additional Configuration Options)**

기본 `LocalValidatorFactoryBean` 구성은 대부분의 경우에 충분합니다.

메시지 보간(message interpolation)부터 순회 해결(traversal resolution)까지 다양한 Bean Validation 구성 요소에 대한 여러 구성 옵션이 있습니다.

**DataBinder 구성하기 (Configuring a DataBinder)**

`Validator`로 `DataBinder` 인스턴스를 구성할 수 있습니다. 일단 구성되면, `binder.validate()`를 호출하여 `Validator`를 호출할 수 있습니다.

모든 유효성 검사 `Errors`는 자동으로 바인더의 `BindingResult`에 추가됩니다.

다음 예제는 대상 객체에 바인딩한 후 유효성 검사 로직을 호출하기 위해 프로그래밍 방식으로 `DataBinder`를 사용하는 방법을 보여줍니다:

```java
// Java
Foo target = new Foo(); // Assuming Foo exists
DataBinder binder = new DataBinder(target);
binder.setValidator(new FooValidator()); // Assuming FooValidator exists

// target 객체에 바인딩
MutablePropertyValues pvs = new MutablePropertyValues();
pvs.add("propertyName", "someValue"); // Add property values to bind
binder.bind(pvs);

// target 객체 검증
binder.validate();

// 유효성 검사 오류를 포함하는 BindingResult 가져오기
BindingResult results = binder.getBindingResult();
```

```kotlin
// Kotlin
val target = Foo() // Assuming Foo exists
val binder = DataBinder(target)
binder.validator = FooValidator() // Assuming FooValidator exists

// target 객체에 바인딩
val pvs = MutablePropertyValues()
pvs.add("propertyName", "someValue") // Add property values to bind
binder.bind(pvs)

// target 객체 검증
binder.validate()

// 유효성 검사 오류를 포함하는 BindingResult 가져오기
val results = binder.bindingResult // Use property access
```

`dataBinder.addValidators` 및 `dataBinder.replaceValidators`를 통해 여러 `Validator` 인스턴스로 `DataBinder`를 구성할 수도 있습니다.

이는 전역적으로 구성된 bean validation과 `DataBinder` 인스턴스에 로컬로 구성된 스프링 `Validator`를 결합할 때 유용합니다.

---

**전체 주제: 자바 빈 검증 (Java Bean Validation)**

이 부분은 자바 표준 스펙인 Bean Validation을 스프링에서 어떻게 활용하여 **객체의 필드 값들이 특정 제약 조건(Constraints)을 만족하는지 검증**하는 방법에 대한 내용입니다.

`@NotNull`, `@Size`, `@Min` 등의 어노테이션을 사용하는 것이 핵심입니다.

**핵심 아이디어:** 검증 로직을 별도의 Validator 클래스에 작성하는 대신, 검증할 객체의 필드 위에 직접 어노테이션으로 제약 조건을 선언하여 코드를 더 깔끔하고 직관적으로 만들자!

---

**1. Bean Validation 개요:**

- **표준 API:** Bean Validation은 자바 표준으로, 특정 구현체(예: Hibernate Validator - 가장 널리 사용됨)에 종속되지 않고 **공통적인 방법**으로 데이터 검증을 수행할 수 있도록 API와 어노테이션을 제공합니다.
- **선언적 방식:** 검증 규칙(제약 조건)을 검증 대상 클래스의 **필드, 메소드, 또는 클래스 자체**에 **어노테이션**으로 직접 붙여서 선언합니다.
- **런타임 검증:** 애플리케이션 실행 중에 Bean Validation **검증기(Validator)** 가 객체를 검사할 때, 이 어노테이션들을 읽고 해당 제약 조건을 만족하는지 자동으로 확인합니다.
- **내장 제약 조건:** `@NotNull`, `@NotEmpty`, `@NotBlank`, `@Size`, `@Min`, `@Max`, `@Email`, `@Pattern` 등 자주 사용되는 다양한 검증 어노테이션이 미리 정의되어 있습니다.
- **커스텀 제약 조건:** 필요하다면 자신만의 검증 어노테이션과 해당 로직을 구현하는 `ConstraintValidator`를 직접 만들 수도 있습니다.
- **예시 (`PersonForm`에 제약 조건 추가):**

    ```java
    import jakarta.validation.constraints.Min;  // 표준 제약 조건 어노테이션 임포트
    import jakarta.validation.constraints.NotNull;
    import jakarta.validation.constraints.Size;
    
    public class PersonForm {
        @NotNull // null이면 안됨
        @Size(max=64) // 최대 64자
        private String name;
    
        @Min(0) // 최소 0 이상
        private int age;
        // Getters and Setters...
    }
    ```

    ```kotlin
    import jakarta.validation.constraints.Min
    import jakarta.validation.constraints.NotNull
    import jakarta.validation.constraints.Size
    
    data class PersonForm(
        // Kotlin에서는 필드에 적용하기 위해 @field: 사용
        @field:NotNull
        @field:Size(max = 64)
        var name: String? = null,
    
        @field:Min(0)
        var age: Int = 0
    )
    ```


---

**2. Bean Validation 제공자 구성하기 (스프링 빈으로 등록)**

스프링에서 Bean Validation 기능을 사용하려면, 실제 검증 로직을 수행할 **Bean Validation 제공자(Provider)의 Validator 객체**를 스프링 빈으로 등록해야 합니다.

- **`LocalValidatorFactoryBean`:** 스프링은 Bean Validation API와의 통합을 위해 `org.springframework.validation.beanvalidation.LocalValidatorFactoryBean` 클래스를 제공합니다.
  이 클래스는 스프링 빈으로 등록될 수 있으며, 내부적으로 클래스패스에 있는 Bean Validation 제공자(예: Hibernate Validator)를 자동으로 감지하여 설정하고,
  `jakarta.validation.ValidatorFactory`와 `jakarta.validation.Validator` 인터페이스를 구현합니다.
- **등록 방법:**
  - **Java Config:**

      ```java
      @Configuration
      public class AppConfig {
          @Bean
          public LocalValidatorFactoryBean validator() { // 빈 이름은 자유롭게 지정 가능 (여기서는 "validator")
              return new LocalValidatorFactoryBean();
          }
      }
      ```

  - **XML Config:**

      ```xml
      <bean id="validator" class="org.springframework.validation.beanvalidation.LocalValidatorFactoryBean"/>
      ```

- **의존성:** 이 설정이 작동하려면 클래스패스에 **Bean Validation API (`jakarta.validation-api`)** 와 **구현체 라이브러리(`hibernate-validator` 등)** 가 모두 존재해야 합니다.

---

**3. 등록된 Validator 주입받아 사용하기**

일단 `LocalValidatorFactoryBean`이 스프링 빈으로 등록되면, 다른 빈에서 이 검증기 객체를 주입받아 사용할 수 있습니다. 두 가지 타입으로 주입 가능합니다.

- **`jakarta.validation.Validator` 주입 (표준 API 사용):**
  - Bean Validation 표준 API를 직접 사용하고 싶을 때 이 타입으로 주입받습니다.
  - 주입받은 `validator` 객체의 `validate(object)` 메소드를 호출하여 검증을 수행하고 `Set<ConstraintViolation<T>>` 형태로 결과를 받습니다.

    ```java
    @Service
    public class MyService {
        @Autowired
        private jakarta.validation.Validator validator; // ★ 표준 Validator 주입 ★
    
        public void process(PersonForm form) {
            Set<ConstraintViolation<PersonForm>> violations = validator.validate(form);
            if (!violations.isEmpty()) {
                // 오류 처리 로직...
            } else {
                // 성공 로직...
            }
        }
    }
    ```

- **`org.springframework.validation.Validator` 주입 (스프링 API 사용):**
  - `LocalValidatorFactoryBean`은 스프링의 `Validator` 인터페이스도 구현(정확히는 적응 Adapt)합니다. 따라서 스프링의 `Validator` API와 통합해야 할 때(예: 이전 섹션의 `DataBinder`와 함께 사용) 이 타입으로 주입받을 수 있습니다.
  - 주입받은 `validator` 객체의 `validate(object, Errors)` 메소드를 호출하여 검증을 수행하고, 결과는 `Errors` 객체에 자동으로 등록됩니다. (`ConstraintViolation`을 `FieldError` 등으로 변환해줌)

    ```java
    import org.springframework.validation.Validator; // ★ 스프링 Validator 임포트 ★
    // ...
    @Service
    public class AnotherService {
        @Autowired
        private Validator validator; // ★ 스프링 Validator 주입 ★
    
        public void process(PersonForm form, Errors errors) {
            validator.validate(form, errors); // Errors 객체에 결과가 담김
            if (errors.hasErrors()) {
                // 오류 처리 로직...
            } else {
                // 성공 로직...
            }
        }
    }
    
    ```


---

**4. 커스텀 제약 조건 구성하기**

Bean Validation 표준을 따라 자신만의 검증 어노테이션과 검증 로직을 만들 수 있습니다.

1. **커스텀 제약 조건 어노테이션 정의:**
  - `@Constraint(validatedBy = 검증로직클래스.class)` 어노테이션을 사용하여 직접 만든 어노테이션을 정의하고, 어떤 `ConstraintValidator` 구현체가 이 어노테이션의 로직을 처리할지 연결해줍니다.
  - Bean Validation 스펙에 따라 `message`, `groups`, `payload` 속성을 포함해야 합니다.

    ```java
    @Target({ElementType.METHOD, ElementType.FIELD})
    @Retention(RetentionPolicy.RUNTIME)
    @Constraint(validatedBy = MyConstraintValidator.class) // ★ 검증기 클래스 연결 ★
    public @interface MyConstraint {
        String message() default "Invalid value";
        Class<?>[] groups() default {};
        Class<? extends jakarta.validation.Payload>[] payload() default {};
    }
    ```

2. **`ConstraintValidator` 구현체 작성:**
  - `jakarta.validation.ConstraintValidator<어노테이션타입, 검증할필드타입>` 인터페이스를 구현합니다.
  - `initialize(어노테이션타입)`: (선택) 어노테이션 속성 값을 사용하여 검증기를 초기화할 때 사용.
  - `isValid(검증할필드타입 value, ConstraintValidatorContext context)`: 실제 검증 로직을 구현합니다. 유효하면 `true`, 아니면 `false`를 반환합니다.
  - **스프링의 장점:** `LocalValidatorFactoryBean`은 기본적으로 `ConstraintValidator` 인스턴스를 **스프링 빈처럼 생성**합니다. 따라서 `ConstraintValidator` 구현체 내에서 **다른 스프링 빈을 `@Autowired` 하여 의존성을 주입**받을 수 있습니다! (예: DB 접근이 필요한 검증)

    ```java
    public class MyConstraintValidator implements ConstraintValidator<MyConstraint, Object> {
        @Autowired // ★ 다른 스프링 빈 주입 가능! ★
        private SomeRepository repository;
    
        @Override
        public boolean isValid(Object value, ConstraintValidatorContext context) {
            // 주입받은 repository 등을 사용하여 복잡한 검증 로직 수행 가능
            // 예: DB에 해당 값이 이미 존재하는지 확인 등
            return /* 검증 결과 */;
        }
    }
    ```


---

**5. 스프링 주도 메소드 유효성 검사 (`@Validated`)**

Bean Validation은 객체 필드뿐만 아니라 **메소드의 파라미터나 반환 값**에 대해서도 제약 조건을 적용하고 검증하는 기능을 제공합니다. 스프링은 이 기능을 AOP를 통해 통합하여 제공합니다.

- **활성화:** `MethodValidationPostProcessor` 빈을 스프링 설정에 등록합니다. (Java Config에서는 `static` `@Bean` 메소드로, XML에서는 `<bean>` 태그로)

    ```java
    // Java Config
    @Bean
    public static MethodValidationPostProcessor validationPostProcessor() { // ★ static 주의 ★
        return new MethodValidationPostProcessor();
    }
    ```

- **사용법:**
  1. 메소드 검증을 적용하고 싶은 **클래스** 위에 스프링의 **`@Validated`** 어노테이션을 붙입니다. (선택적으로 검증 그룹 지정 가능)
  2. 검증하고 싶은 **메소드의 파라미터**나 **반환 값**에 Bean Validation 제약 조건 어노테이션(`@NotNull`, `@Min` 등)을 붙입니다.
  3. 만약 파라미터가 객체이고 그 **객체 내부 필드까지 연쇄적으로 검증**하고 싶다면, 해당 파라미터 앞에 `@Valid` (Jakarta Bean Validation 표준) 어노테이션을 붙입니다.

    ```java
    import org.springframework.validation.annotation.Validated;
    import jakarta.validation.Valid;
    import jakarta.validation.constraints.Min;
    // ...
    @Service
    @Validated // ★ 클래스 레벨에 붙여 메소드 검증 활성화 ★
    public class MyValidationService {
    
        public void processUserData(
                @NotNull @Size(min = 1) String userId, // 파라미터 직접 검증
                @Min(0) int point,
                @Valid UserData userData // ★ userData 객체 내부 필드까지 검증 (cascade) ★
        ) {
            // ... 로직 ...
        }
    
        @NotNull // 반환 값 검증
        public UserData findUser(@NotNull String userId) {
            // ... 로직 ...
        }
    }
    ```

- **동작 방식:** `@Validated`가 붙은 클래스의 빈은 스프링 AOP 프록시로 감싸집니다. 해당 빈의 메소드가 호출될 때, 프록시는 메소드 진입 전/후에 파라미터와 반환 값에 붙은 제약 조건을 검사합니다.
- **예외 처리:** 검증 실패 시 기본적으로 `jakarta.validation.ConstraintViolationException`이 발생합니다. `MethodValidationPostProcessor`의 `adaptConstraintViolations` 속성을 `true`로 설정하면 스프링의 `MethodValidationException`(내부에 `Errors` 정보 포함)이 발생하도록 변경할 수 있어, 오류 메시지 처리 등에 더 유용할 수 있습니다.

---

**6. 검증 오류 메시지 사용자 정의:**

- 메소드 검증 실패 시 발생하는 `ConstraintViolation`에는 여러 정보(메시지 템플릿, 속성 경로 등)가 포함됩니다.
- `MethodValidationException` (adaptConstraintViolations=true 설정 시)으로 변환된 오류는 스프링의 `Errors` 객체처럼 동작하며, 각 위반 사항은 `MessageSourceResolvable` 오류로 변환됩니다.
- 이 오류들은 이전에 설명한 `MessageSource`와 `DefaultMessageCodesResolver` 메커니즘을 통해 **다양한 오류 코드 후보**를 생성합니다. (예: `"Size.person.name"`, `"Size.name"`, `"Size.java.lang.String"`, `"Size"`)
- 개발자는 이 코드들을 사용하여 `messages.properties` 파일에 **사용자 친화적인 오류 메시지를 정의**하고 국제화할 수 있습니다. 메시지 인수(`{0}`, `{1}` 등)를 사용하여 필드 이름이나 제약 조건 값 등을 메시지에 포함시킬 수도 있습니다.

**요약:**

스프링은 **자바 표준 Bean Validation API**를 완벽하게 지원합니다. `@NotNull`, `@Size` 등 **표준 어노테이션**을 사용하여 객체 필드에 **선언적으로 제약 조건을 정의**할 수 있습니다. `LocalValidatorFactoryBean`을 스프링 빈으로 등록하면 Bean Validation 기능을 사용할 수 있으며, 표준 `jakarta.validation.Validator` 또는 스프링의 `org.springframework.validation.Validator` 타입으로 주입받아 사용할 수 있습니다. 커스텀 제약 조건을 만들 때는 `ConstraintValidator` 구현체 내에서 **스프링 의존성 주입**을 활용할 수 있습니다. 또한, `MethodValidationPostProcessor`와 `@Validated` 어노테이션을 통해 **메소드 파라미터 및 반환 값 검증**도 AOP 기반으로 쉽게 적용할 수 있으며, 검증 오류 메시지는 스프링의 `MessageSource`와 연동하여 효과적으로 관리할 수 있습니다. 이는 스프링의 `Validator` 인터페이스 방식보다 더 선언적이고 표준적인 검증 방법입니다.

---

```java
// 커스텀 제약 조건 어노테이션 예시
@Target({ElementType.METHOD, ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = MyConstraintValidator.class)
public @interface MyConstraint {

    // ★ Bean Validation 표준 필수 속성들 ★
    String message() default "Invalid value"; // 기본 오류 메시지
    Class<?>[] groups() default {};          // 검증 그룹 지정
    Class<? extends Payload>[] payload() default {}; // 심각도 등 메타데이터 전달

    // (선택) 커스텀 어노테이션 고유의 속성 추가 가능
    // int minValue() default 0;
}
```

**1. `message` 속성:**

- **역할:** 해당 제약 조건 검증에 **실패했을 때 사용될 기본 오류 메시지 템플릿**을 지정합니다.
- **값:** 보통 문자열 리터럴을 기본값으로 제공합니다. (예: `"Invalid value"`, `"must not be null"`)
- **플레이스홀더:** 메시지 템플릿 안에는 `{속성명}` 형태의 플레이스홀더를 사용하여 제약 조건 어노테이션 자체의 속성 값(예: `@Size(max=10)`의 `max` 값)을 참조하거나, `{validatedValue}` 처럼 검증 대상 값을 참조할 수 있습니다.
- **국제화 (i18n):** 실제 운영 환경에서는 여기에 직접 메시지를 쓰는 대신, `{myconstraint.invalid}` 처럼 **메시지 코드(key)** 를 지정하는 것이 일반적입니다. 그러면 이 코드를 사용하여 `MessageSource`(예: `ValidationMessages.properties`)에서 실제 로케일에 맞는 오류 메시지를 찾아 표시하게 됩니다.
- **기본값 필수:** Bean Validation 스펙은 `message` 속성에 기본값을 제공하도록 요구합니다.

**2. `groups` 속성:**

- **역할:** 어떤 **검증 그룹(Validation Group)** 에 이 제약 조건이 속하는지를 지정합니다. 검증 그룹은 특정 시나리오나 상황에 따라 **선별적으로 검증을 수행**할 때 사용됩니다.
- **값:** 검증 그룹을 나타내는 **인터페이스 클래스(들)** 의 배열(`Class<?>[]`)을 값으로 가집니다. 기본값은 빈 배열(`{}`)입니다.
- **기본 그룹:** `groups` 속성을 지정하지 않거나 빈 배열로 두면, 해당 제약 조건은 **기본 그룹(`jakarta.validation.groups.Default`)** 에 속하게 됩니다. 일반적으로 `validator.validate(object)`처럼 그룹을 지정하지 않고 검증을 수행하면 이 기본 그룹에 속한 제약 조건들만 검증됩니다.
- **활용 예시:**
  - 사용자 정보를 처음 **등록(Create)** 할 때와 **수정(Update)** 할 때 필요한 검증 규칙이 다를 수 있습니다. 예를 들어, ID는 등록 시에는 필수이지만 수정 시에는 변경 불가일 수 있습니다.
  - 이 경우, `OnCreate`와 `OnUpdate`라는 빈 인터페이스를 만들어서 검증 그룹으로 사용합니다.
  - ID 필드에는 `@NotNull(groups = OnCreate.class)` 처럼 등록 그룹 제약 조건을 걸고, 다른 필드에는 `@NotNull(groups = {OnCreate.class, OnUpdate.class})` 처럼 두 그룹 모두에 속하도록 제약 조건을 걸 수 있습니다.
  - 컨트롤러 등에서 검증을 수행할 때 `validator.validate(user, OnCreate.class)` 또는 `validator.validate(user, OnUpdate.class)` 처럼 **검증할 그룹을 명시적으로 지정**하면 해당 그룹에 속한 제약 조건들만 검증됩니다.
- **기본값 필수:** Bean Validation 스펙은 `groups` 속성에 기본값(보통 빈 배열)을 제공하도록 요구합니다.

**3. `payload` 속성:**

- **역할:** 제약 조건 위반(Constraint Violation) 시 클라이언트(검증 결과를 사용하는 코드)에게 **추가적인 메타데이터**를 전달하기 위한 수단입니다. 주로 오류의 **심각도(Severity)** 를 분류하거나 특정 UI 힌트를 제공하는 등의 용도로 사용될 수 있습니다.
- **값:** `jakarta.validation.Payload` 인터페이스를 구현하는 **클래스(들)** 의 배열(`Class<? extends Payload>[]`)을 값으로 가집니다. 기본값은 빈 배열(`{}`)입니다.
- **`Payload` 인터페이스:** `Payload` 자체는 마커(marker) 인터페이스이며, 개발자는 자신만의 Payload 타입을 정의하여 사용할 수 있습니다.

    ```java
    // 예: 심각도 Payload 정의
    public interface Severity {
        interface Info extends Payload {}
        interface Error extends Payload {}
    }
    
    // 제약 조건 어노테이션에서 사용
    @MyConstraint(payload = Severity.Error.class) // 이 제약 조건 위반은 'Error' 심각도로 간주
    private String criticalField;
    
    ```

- **활용:** 검증 실패 후 `ConstraintViolation` 객체에서 `getConstraintDescriptor().getPayload()` 메소드를 호출하여 해당 제약 조건에 설정된 Payload 타입들을 얻을 수 있습니다. 이를 통해 오류의 심각도에 따라 다른 처리를 하거나(예: Error 레벨은 로깅, Info 레벨은 무시), UI에서 특정 스타일을 적용하는 등의 작업을 할 수 있습니다.
- **일반적인 사용 빈도:** `message`나 `groups`에 비해 상대적으로 **덜 사용되는** 속성입니다. 하지만 특정 프레임워크나 복잡한 검증 시나리오에서는 유용하게 활용될 수 있습니다.
- **기본값 필수:** Bean Validation 스펙은 `payload` 속성에 기본값(보통 빈 배열)을 제공하도록 요구합니다.

**결론:**

`message`, `groups`, `payload`는 Bean Validation 표준 제약 조건 어노테이션을 정의할 때 **반드시 포함해야 하는 세 가지 표준 속성**입니다.

- **`message`**: 검증 실패 시 사용할 기본 메시지 또는 메시지 코드.
- **`groups`**: 이 제약 조건이 속한 검증 그룹(특정 상황에서만 검증하기 위한 용도).
- **`payload`**: 제약 조건 위반에 대한 추가 메타데이터(예: 심각도)를 전달하기 위한 수단.

이 속성들을 통해 Bean Validation은 단순한 값 검증을 넘어, 상황에 맞는 검증, 국제화된 메시지 처리, 오류 정보 확장 등 풍부한 기능을 제공할 수 있습니다.
