---
title: Spring AOP Capabilities and Goals
description: 
author: laze
date: 2025-05-05 00:00:10 +0900
categories: [Dev, SpringBoot]
tags: [SpringBoot]
---
**Spring AOP Capabilities and Goals**

스프링 AOP는 순수 자바로 구현됩니다.

특별한 컴파일 프로세스가 필요하지 않습니다.

스프링 AOP는 클래스 로더 계층 구조를 제어할 필요가 없으므로 서블릿 컨테이너나 애플리케이션 서버에서 사용하기에 적합합니다.

스프링 AOP는 현재 메소드 실행 조인 포인트(스프링 빈의 메소드 실행 어드바이스)만 지원합니다. 필드 가로채기(field interception)는 구현되지 않았지만,

핵심 스프링 AOP API를 손상시키지 않고 필드 가로채기 지원을 추가할 수 있습니다.

필드 접근 및 업데이트 조인 포인트를 어드바이스해야 하는 경우, AspectJ와 같은 언어를 사용할 수 있습니다.

스프링 AOP의 AOP 접근 방식은 대부분의 다른 AOP 프레임워크와 다릅니다.

목표는 가장 완전한 AOP 구현을 제공하는 것이 아닙니다(비록 스프링 AOP가 상당히 유능하지만).

오히려, 목표는 엔터프라이즈 애플리케이션의 일반적인 문제를 해결하는 데 도움이 되도록 AOP 구현과 스프링 IoC 간의 긴밀한 통합을 제공하는 것입니다.

따라서 예를 들어, 스프링 프레임워크의 AOP 기능은 일반적으로 스프링 IoC 컨테이너와 함께 사용됩니다.

애스펙트는 일반 빈 정의 구문(비록 이것이 강력한 "자동 프록시(auto-proxying)" 기능을 허용하지만)을 사용하여 구성됩니다.

이것은 다른 AOP 구현과의 중요한 차이점입니다.

스프링 AOP로는 매우 세분화된 객체(일반적으로 도메인 객체)를 어드바이스하는 것과 같은 일부 작업을 쉽거나 효율적으로 수행할 수 없습니다.

이러한 경우에는 AspectJ가 최상의 선택입니다.

그러나 스프링 AOP는 AOP에 적합한 엔터프라이즈 자바 애플리케이션의 대부분 문제에 대한 훌륭한 솔루션을 제공합니다.

*스프링 AOP는 포괄적인 AOP 솔루션을 제공하기 위해 AspectJ와 경쟁하려고 결코 노력하지 않습니다.*

*우리는 스프링 AOP와 같은 프록시 기반 프레임워크와 AspectJ와 같은 완전한 프레임워크 모두 가치가 있으며, 경쟁 관계가 아닌 상호 보완적이라고 믿습니다.*

*스프링은 일관된 스프링 기반 애플리케이션 아키텍처 내에서 AOP의 모든 사용을 가능하게 하기 위해 스프링 AOP 및 IoC를 AspectJ와 원활하게 통합합니다.*

*이 통합은 스프링 AOP API 또는 AOP 얼라이언스(AOP Alliance) API에 영향을 미치지 않습니다.*

*스프링 AOP는 하위 호환성을 유지합니다.*

*스프링 AOP API에 대한 논의는 다음 장을 참조하십시오.*

스프링 프레임워크의 핵심 신조 중 하나는 비침투성(non-invasiveness)입니다.

이는 프레임워크 특정 클래스 및 인터페이스를 비즈니스 또는 도메인 모델에 도입하도록 강요받아서는 안 된다는 아이디어입니다.

그러나 어떤 곳에서는 스프링 프레임워크가 코드베이스에 스프링 프레임워크 특정 의존성을 도입할 수 있는 옵션을 제공합니다.

이러한 옵션을 제공하는 근거는 특정 시나리오에서 특정 기능 부분을 그러한 방식으로 읽거나 코딩하는 것이 훨씬 쉬울 수 있기 때문입니다.

그러나 스프링 프레임워크는 (거의) 항상 선택권을 제공합니다: 특정 사용 사례나 시나리오에 가장 적합한 옵션에 대해 정보에 입각한 결정을 내릴 자유가 있습니다.

이 장과 관련된 선택 중 하나는 어떤 AOP 프레임워크(그리고 어떤 AOP 스타일)를 선택할 것인가입니다. AspectJ, 스프링 AOP 또는 둘 다를 선택할 수 있습니다.

`@AspectJ` 어노테이션 스타일 접근 방식 또는 스프링 XML 구성 스타일 접근 방식 중 하나를 선택할 수도 있습니다.

이 장에서 `@AspectJ` 스타일 접근 방식을 먼저 소개하기로 선택한 것이 스프링 팀이 스프링 XML 구성 스타일보다 `@AspectJ` 어노테이션 스타일 접근 방식을 선호한다는 표시로 받아들여서는 안 됩니다.

---

**전체 주제: 스프링 AOP의 기능과 목표 (Spring AOP Capabilities and Goals)**

이 부분은 스프링 프레임워크에 포함된 AOP 기능이 **어떤 특징**을 가지고 있으며, **어떤 목표**를 가지고 설계되었는지를 설명합니다. 스프링 AOP가 모든 것을 다 하려고 하지 않는다는 점과, 스프링 IoC 컨테이너와의 긴밀한 통합을 중시한다는 점을 강조합니다.

**핵심 아이디어:** 스프링 AOP는 가장 강력한 AOP 프레임워크가 되는 것보다, 스프링 IoC와 잘 통합되어 엔터프라이즈 애플리케이션의 일반적인 문제(트랜잭션, 보안 등)를 **쉽고 실용적으로 해결**하는 데 초점을 맞춘다.

---

**1. 스프링 AOP의 구현 특징:**

- **순수 자바 구현:** 스프링 AOP는 100% 자바로 구현되었습니다. 즉, AspectJ처럼 별도의 컴파일러나 특별한 빌드 과정이 **필요 없습니다.** 일반 자바 개발 환경에서 바로 사용할 수 있습니다.
- **클래스 로더 제어 불필요:** 클래스 로더의 동작 방식을 변경하거나 제어할 필요가 없습니다. 덕분에 복잡한 클래스 로더 계층 구조를 가진 **서블릿 컨테이너(Tomcat 등)나 애플리케이션 서버(JBoss 등) 환경에서도 문제없이 잘 작동**합니다.

---

**2. 스프링 AOP의 기능 범위 (한계점 명시):**

- **메소드 실행 조인 포인트만 지원:** 스프링 AOP는 현재 **메소드가 실행되는 시점**만을 조인 포인트(AOP를 적용할 시점)로 지원합니다.
- **필드 가로채기 미지원:** 특정 필드의 값을 읽거나 쓰는 시점을 가로채는 기능(Field Interception)은 **지원하지 않습니다.** (이론적으로 추가는 가능하지만 현재는 없음)
- **AspectJ와의 비교:** 만약 필드 접근 시점 등 **메소드 실행 외의 다양한 조인 포인트**에 AOP를 적용하고 싶다면, 더 강력하고 포괄적인 AOP 기능을 제공하는 **AspectJ**를 사용하는 것을 고려해야 합니다.

---

**3. 스프링 AOP의 설계 목표 (가장 중요한 부분):**

- **최고 기능 목표 아님:** 스프링 AOP의 목표는 AspectJ처럼 세상에서 가장 많은 AOP 기능을 제공하는 것이 **아닙니다.**
- **IoC와의 긴밀한 통합:** 스프링 AOP의 **핵심 목표**는 **스프링 IoC 컨테이너와 매우 긴밀하게 통합**되어, 스프링을 사용하는 개발자들이 **AOP를 쉽고 자연스럽게** 적용할 수 있도록 하는 것입니다.
- **실용적인 문제 해결:** 엔터프라이즈 애플리케이션 개발 시 자주 마주치는 **공통적인 문제들(횡단 관심사 - 트랜잭션, 보안, 로깅 등)** 을 해결하는 데 필요한 AOP 기능을 **효과적으로 제공**하는 데 집중합니다.
- **빈 기반 구성:** 스프링 AOP의 애스펙트(Aspect)는 스프링 IoC 컨테이너가 관리하는 **일반 빈(Bean)** 으로 정의하고 구성합니다. 이는 스프링의 다른 기능들과 일관된 방식으로 AOP를 설정하고 관리할 수 있게 해줍니다. (다른 AOP 프레임워크와의 차별점)

---

**4. 스프링 AOP의 적합성 및 AspectJ와의 관계:**

- **한계:** 스프링 AOP는 프록시 기반으로 동작하기 때문에, 아주 세밀한 객체(예: 도메인 객체 자체)에 직접 어드바이스를 적용하는 것은 어렵거나 비효율적일 수 있습니다.
- **적합한 경우:** 대부분의 엔터프라이즈 애플리케이션에서 발생하는 AOP 요구사항(특히 서비스 계층의 트랜잭션 관리, 보안 적용 등)은 스프링 AOP만으로도 **충분히 효과적으로 해결**할 수 있습니다.
- **AspectJ는 경쟁자가 아닌 보완재:** 스프링은 AspectJ를 경쟁 상대로 보지 않습니다. 오히려 **상호 보완적인 관계**로 봅니다.
  - 스프링 AOP: 간단하고 IoC와 통합된 AOP가 필요할 때.
  - AspectJ: 필드 접근 등 더 강력하고 다양한 조인 포인트 지원이나 컴파일/로드 타임 위빙이 필요할 때.
- **통합 지원:** 스프링은 **AspectJ와의 완벽한 통합**을 지원합니다. 즉, 스프링 애플리케이션 내에서 스프링 AOP와 AspectJ를 함께 사용하거나, AspectJ 방식으로 정의된 애스펙트를 스프링 AOP가 관리하도록 할 수 있습니다. 스프링의 IoC 컨테이너 위에서 두 기술을 조화롭게 사용할 수 있습니다.

---

**5. 스프링의 개발 철학: 비침투성(Non-invasiveness)**

- **핵심 원칙:** 스프링 프레임워크는 개발자의 **비즈니스 로직 코드나 도메인 모델**이 **프레임워크 자체에 대한 의존성(특정 클래스 상속, 인터페이스 구현 등)을 갖도록 강요하지 않는 것**을 목표로 합니다. (가능한 한 POJO - Plain Old Java Object 유지)
- **선택권 제공:** 하지만 특정 기능을 더 쉽게 사용하기 위해 스프링 관련 클래스나 어노테이션을 사용할 수 있는 **옵션**을 제공하기도 합니다. 스프링은 개발자가 상황에 맞게 **최적의 방식을 선택할 수 있도록 자유**를 주는 것을 중요하게 생각합니다.
- **AOP 스타일 선택:** AOP를 사용할 때도 마찬가지입니다.
  - **프레임워크:** 스프링 AOP, AspectJ, 또는 둘 다 사용 가능.
  - **선언 스타일:** `@AspectJ` 어노테이션 스타일, 스프링 XML 구성 스타일 중 선택 가능.
  - **선호도:** 이 문서에서 `@AspectJ` 스타일을 먼저 소개한다고 해서 스프링 팀이 XML 스타일보다 어노테이션 스타일을 더 선호한다는 의미는 아닙니다. 각 방식의 장단점을 이해하고 선택하는 것이 중요합니다. (자세한 비교는 다른 섹션에서)

**요약:**

스프링 AOP는 순수 자바로 구현되어 사용이 간편하고 서블릿/애플리케이션 서버 환경에 적합합니다. **메소드 실행 조인 포인트**만 지원하며 필드 가로채기는 지원하지 않는 등 기능 범위에는 한계가 있습니다. 가장 중요한 목표는 **스프링 IoC 컨테이너와의 긴밀한 통합**을 통해 엔터프라이즈 애플리케이션의 **일반적인 횡단 관심사 문제를 실용적으로 해결**하는 것입니다. AspectJ와는 경쟁 관계가 아닌 **보완 관계**이며, 스프링은 AspectJ와의 통합을 지원합니다. 스프링의 **비침투성 철학**에 따라 개발자는 AOP 프레임워크와 선언 스타일을 유연하게 선택할 수 있습니다.
