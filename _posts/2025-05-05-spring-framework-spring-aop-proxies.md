---
title: AOP Proxies
description: 
author: laze
date: 2025-05-05 00:00:11 +0900
categories: [Dev, SpringBoot]
tags: [SpringBoot]
---
**AOP Proxies**

스프링 AOP는 기본적으로 AOP 프록시에 표준 JDK 동적 프록시(dynamic proxies)를 사용합니다.

이를 통해 모든 인터페이스 (또는 인터페이스 세트)를 프록시할 수 있습니다.

스프링 AOP는 CGLIB 프록시를 사용할 수도 있습니다.

이는 인터페이스가 아닌 클래스를 프록시하는 데 필요합니다.

기본적으로 비즈니스 객체가 인터페이스를 구현하지 않는 경우 CGLIB가 사용됩니다.

클래스보다는 인터페이스를 대상으로 프로그래밍하는 것이 좋은 습관이므로, 비즈니스 클래스는 일반적으로 하나 이상의 비즈니스 인터페이스를 구현합니다.

인터페이스에 선언되지 않은 메소드를 어드바이스해야 하거나 프록시된 객체를 구체적인 타입으로 메소드에 전달해야 하는 (바라건대 드문) 경우에는 CGLIB 사용을 강제할 수 있습니다.

스프링 AOP가 프록시 기반(proxy-based)이라는 사실을 파악하는 것이 중요합니다.

---

**전체 주제: AOP 프록시 (AOP Proxies)**

이 부분은 스프링 AOP가 부가 기능(어드바이스)을 적용하기 위해 사용하는 **프록시(Proxy) 패턴**과 그 구체적인 **두 가지 구현 방식 (JDK 동적 프록시, CGLIB 프록시)** 에 대해 설명합니다.

**핵심 아이디어:** 스프링 AOP는 실제 대상 객체(Target)를 직접 건드리지 않고, 대신 대상 객체를 **감싸는 가짜 객체(프록시)** 를 만들어서 부가 기능을 처리한다. 이 프록시를 만드는 방법에는 두 가지 표준 기술이 있다.

---

**1. 프록시 기반 AOP (Proxy-based AOP):**

- **개념:** 대상 객체(Target) 앞에 **대리인(프록시)** 을 내세우는 방식입니다.
- **동작:**
  1. 클라이언트(다른 빈)는 프록시 객체를 실제 대상 객체인 것처럼 사용합니다.
  2. 클라이언트가 프록시의 메소드를 호출하면, 프록시는 중간에서 요청을 가로챕니다.
  3. 프록시는 설정된 AOP 규칙(어드바이스)에 따라 부가 기능(예: 트랜잭션 시작, 로그 기록)을 먼저 수행합니다.
  4. 그런 다음, 프록시는 **실제 대상 객체의 원래 메소드를 호출**합니다.
  5. 대상 객체의 메소드 실행이 끝나면, 프록시는 다시 부가 기능(예: 트랜잭션 커밋, 로그 기록)을 수행합니다.
  6. 최종 결과를 클라이언트에게 반환합니다.
- **핵심:** 실제 대상 객체의 코드를 수정하지 않고도, 프록시를 통해 부가 기능을 투명하게 적용할 수 있습니다.

---

**2. 스프링 AOP의 프록시 생성 방식:**

스프링 AOP는 이 프록시 객체를 **런타임(Runtime)** 에 **동적으로 생성**하며, 상황에 따라 다음 두 가지 기술 중 하나를 **자동으로 선택하거나 개발자가 지정**할 수 있습니다.

- **(1) JDK 동적 프록시 (Dynamic Proxies) - 기본 방식:**
  - **사용 조건:** 프록시를 만들려는 **대상 객체(Target)가 하나 이상의 인터페이스를 구현(implements)하고 있을 때** 사용됩니다. (스프링 AOP의 **기본 전략**)
  - **동작 원리:** 자바 JDK에서 기본으로 제공하는 `java.lang.reflect.Proxy` 클래스를 사용하여, 대상 객체가 구현한 **인터페이스(들)를 똑같이 구현하는 프록시 클래스를 런타임에 동적으로 생성**합니다.
  - **결과:** 생성된 프록시 객체는 대상 객체가 구현한 **인터페이스 타입**으로 취급될 수 있습니다.
  - **장점:** JDK 표준 기능이므로 별도 라이브러리가 필요 없습니다. 인터페이스 기반 설계와 잘 맞습니다.
  - **단점:** **인터페이스가 없는 클래스**는 프록시할 수 없습니다. 인터페이스에 정의되지 않은 대상 클래스 고유의 메소드는 프록시를 통해 호출할 수 없습니다 (호출 자체가 안됨).
- **(2) CGLIB 프록시:**
  - **사용 조건:** 프록시를 만들려는 **대상 객체가 인터페이스를 구현하고 있지 않은 경우** (즉, 구체적인 클래스만 있는 경우) 자동으로 사용됩니다. 또는 개발자가 명시적으로 CGLIB 사용을 강제할 수도 있습니다.
  - **동작 원리:** **CGLIB 라이브러리**를 사용하여, 대상 객체 클래스를 **상속(extends)하는 자식 클래스를 런타임에 동적으로 생성**합니다. 이 자식 클래스가 프록시 역할을 하며, 부모 클래스(대상 객체 클래스)의 메소드를 오버라이드하여 부가 기능을 추가합니다.
  - **결과:** 생성된 프록시 객체는 **원본 클래스 타입**으로 취급될 수 있습니다.
  - **장점:** **인터페이스가 없는 클래스**도 프록시를 만들 수 있습니다. 대상 클래스에만 정의된 메소드도 프록시를 통해 호출하고 어드바이스를 적용할 수 있습니다.
  - **단점:**
    - CGLIB 라이브러리가 필요합니다 (스프링은 내장하고 있음).
    - 대상 클래스나 어드바이스를 적용할 메소드가 **`final`로 선언되어 있으면 프록시를 생성할 수 없습니다** (상속/오버라이드 불가).
    - JDK 동적 프록시보다 약간의 성능 오버헤드가 있을 수 있습니다 (현대 JVM에서는 차이가 미미할 수 있음).

---

**3. 스프링의 선택 및 개발자 고려 사항:**

- **자동 선택:** 스프링 AOP는 기본적으로 대상 객체가 인터페이스를 구현하면 JDK 동적 프록시를, 구현하지 않으면 CGLIB 프록시를 사용합니다.
- **인터페이스 기반 프로그래밍 권장:** 스프링은 일반적으로 **인터페이스를 기반으로 프로그래밍하는 것을 좋은 습관**으로 권장합니다. 이렇게 하면 기본적으로 JDK 동적 프록시가 사용되어 유연성이 높아집니다.
- **CGLIB 사용 강제:** 다음과 같은 (드문) 경우에는 CGLIB 사용을 명시적으로 강제해야 할 수 있습니다 (`proxy-target-class="true"` 설정 등):
  - 대상 객체가 인터페이스를 구현하더라도, **인터페이스에 선언되지 않은 대상 클래스의 고유 메소드**에 어드바이스를 적용하고 싶을 때.
  - 프록시 객체 자체를 **구체적인 클래스 타입**으로 캐스팅하여 사용해야 할 때.
- **프록시 기반 이해의 중요성:** 스프링 AOP가 프록시 기반이라는 점을 이해하는 것은 매우 중요합니다. 예를 들어, 프록시 내부에서 **자기 자신의 다른 메소드를 직접 호출(`this.someMethod()`)** 하면 AOP(트랜잭션 등)가 적용되지 않는 문제 등이 발생할 수 있습니다. (프록시를 거치지 않고 원본 객체의 메소드를 직접 호출하게 되므로) 이에 대한 자세한 내용은 AOP 프록시 이해하기(Understanding AOP Proxies) 섹션에서 다룹니다.

**요약:**

스프링 AOP는 부가 기능을 적용하기 위해 **런타임 프록시**를 사용합니다. 대상 객체가 인터페이스를 구현하면 **JDK 동적 프록시**(기본)를, 그렇지 않으면 **CGLIB 프록시**(클래스 상속)를 사용합니다. 인터페이스 기반 프로그래밍이 권장되며, 특정 상황에서는 CGLIB 사용을 강제할 수 있습니다. 스프링 AOP가 프록시 기반이라는 점은 AOP 적용 방식과 잠재적인 문제점을 이해하는 데 중요한 기초가 됩니다.
