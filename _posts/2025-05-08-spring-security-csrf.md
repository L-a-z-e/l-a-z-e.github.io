---
title: Protection Against Exploits - CSRF
description: 
author: laze
date: 2025-05-08 00:00:04 +0900
categories: [Dev, SpringSecurity]
tags: [SpringSecurity]
---
# CSRF

## 사이트 간 요청 위조 (CSRF - Cross Site Request Forgery)

Spring은 사이트 간 요청 위조(CSRF) 공격으로부터 보호하기 위한 포괄적인 지원을 제공합니다.

다음 섹션에서는 다음 내용을 살펴봅니다:

- CSRF 공격이란 무엇인가?
- CSRF 공격으로부터 보호하기
- CSRF 고려 사항

이 문서 부분에서는 CSRF 보호의 일반적인 주제에 대해 설명합니다.

서블릿 및 웹플럭스 기반 애플리케이션의 CSRF 보호에 대한 특정 정보는 관련 섹션을 참조하세요.

### CSRF 공격이란 무엇인가?

CSRF 공격을 이해하는 가장 좋은 방법은 구체적인 예를 살펴보는 것입니다.

여러분의 은행 웹사이트가 현재 로그인한 사용자로부터 다른 은행 계좌로 돈을 이체할 수 있는 양식을 제공한다고 가정해 봅시다.

예를 들어, 이체 양식은 다음과 같을 수 있습니다:

**이체 양식**

```html
<form method="post"
	action="/transfer">
<input type="text"
	name="amount"/>
<input type="text"
	name="routingNumber"/>
<input type="text"
	name="account"/>
<input type="submit"
	value="Transfer"/>
</form>

```

해당 HTTP 요청은 다음과 같을 수 있습니다:

**이체 HTTP 요청**

```
POST /transfer HTTP/1.1
Host: bank.example.com
Cookie: JSESSIONID=randomid
Content-Type: application/x-www-form-urlencoded

amount=100.00&routingNumber=1234&account=9876
```

이제 여러분이 은행 웹사이트에 인증한 후 로그아웃하지 않고 악의적인 웹사이트를 방문했다고 가정해 봅시다.

악의적인 웹사이트에는 다음 양식이 포함된 HTML 페이지가 있습니다:

**악의적인 이체 양식**

```html
<form method="post"
	action="<https://bank.example.com/transfer>">
<input type="hidden"
	name="amount"
	value="100.00"/>
<input type="hidden"
	name="routingNumber"
	value="evilsRoutingNumber"/>
<input type="hidden"
	name="account"
	value="evilsAccountNumber"/>
<input type="submit"
	value="Win Money!"/>
</form>
```

여러분은 돈을 얻고 싶어서 제출 버튼을 클릭합니다.

그 과정에서 의도치 않게 악의적인 사용자에게 100달러를 이체했습니다.

이는 악의적인 웹사이트가 여러분의 쿠키를 볼 수는 없지만, 여러분의 은행과 관련된 쿠키는 여전히 요청과 함께 전송되기 때문에 발생합니다.

더 나쁜 것은 이 모든 과정이 JavaScript를 사용하여 자동화될 수 있다는 것입니다.

즉, 버튼을 클릭할 필요조차 없었다는 의미입니다.

더욱이 XSS 공격의 희생양이 된 정직한 사이트를 방문할 때도 똑같이 쉽게 발생할 수 있습니다.

그렇다면 이러한 공격으로부터 사용자를 어떻게 보호할 수 있을까요?

### CSRF 공격으로부터 보호하기

CSRF 공격이 가능한 이유는 피해자의 웹사이트에서 보낸 HTTP 요청과 공격자의 웹사이트에서 보낸 요청이 정확히 동일하기 때문입니다.

이는 악의적인 웹사이트에서 오는 요청을 거부하고 은행 웹사이트에서 오는 요청만 허용할 방법이 없다는 것을 의미합니다.

CSRF 공격으로부터 보호하려면 악의적인 사이트가 제공할 수 없는 무언가가 요청에 포함되어 두 요청을 구별할 수 있도록 해야 합니다.

Spring은 CSRF 공격으로부터 보호하기 위한 두 가지 메커니즘을 제공합니다:

- 동기화 토큰 패턴 (Synchronizer Token Pattern)
- 세션 쿠키에 SameSite 속성 지정

두 보호 방법 모두 안전한 메소드(Safe Methods)가 읽기 전용이어야 합니다.

### 안전한 메소드는 읽기 전용이어야 합니다

CSRF에 대한 두 가지 보호 방법 중 어느 것이든 작동하려면 애플리케이션은 "안전한" HTTP 메소드가 읽기 전용인지 확인해야 합니다.

즉, HTTP GET, HEAD, OPTIONS, TRACE 메소드를 사용하는 요청은 애플리케이션의 상태를 변경해서는 안 됩니다.

### 동기화 토큰 패턴

CSRF 공격으로부터 보호하는 가장 지배적이고 포괄적인 방법은 동기화 토큰 패턴을 사용하는 것입니다.

이 해결책은 각 HTTP 요청이 세션 쿠키 외에도 CSRF 토큰이라는 안전한 임의 생성 값을 HTTP 요청에 포함하도록 요구하는 것입니다.

HTTP 요청이 제출되면 서버는 예상 CSRF 토큰을 조회하고 HTTP 요청의 실제 CSRF 토큰과 비교해야 합니다.

값이 일치하지 않으면 HTTP 요청은 거부되어야 합니다.

이것이 작동하는 핵심은 실제 CSRF 토큰이 브라우저에 의해 자동으로 포함되지 않는 HTTP 요청 부분에 있어야 한다는 것입니다.

예를 들어, HTTP 매개변수나 HTTP 헤더에 실제 CSRF 토큰을 요구하면 CSRF 공격으로부터 보호할 수 있습니다.

쿠키에 실제 CSRF 토큰을 요구하는 것은 쿠키가 브라우저에 의해 HTTP 요청에 자동으로 포함되기 때문에 작동하지 않습니다.

애플리케이션의 상태를 업데이트하는 각 HTTP 요청에 대해서만 실제 CSRF 토큰을 요구하도록 기대를 완화할 수 있습니다.

그렇게 하려면 애플리케이션은 안전한 HTTP 메소드가 읽기 전용인지 확인해야 합니다.

이는 외부 사이트에서 웹사이트로 연결하는 것을 허용하고 싶기 때문에 사용성을 향상시킵니다.

또한 HTTP GET에 임의의 토큰을 포함하고 싶지 않습니다.

이는 토큰이 유출될 수 있기 때문입니다.

동기화 토큰 패턴을 사용할 때 예제가 어떻게 변경되는지 생각해 봅시다.

실제 CSRF 토큰이 `_csrf`라는 HTTP 매개변수에 있어야 한다고 가정합니다.

애플리케이션의 이체 양식은 다음과 같습니다:

**동기화 토큰 양식**

```html
<form method="post"
	action="/transfer">
<input type="hidden"
	name="_csrf"
	value="4bfd1575-3ad1-4d21-96c7-4ef2d9f86721"/>
<input type="text"
	name="amount"/>
<input type="text"
	name="routingNumber"/>
<input type="hidden"
	name="account"/>
<input type="submit"
	value="Transfer"/>
</form>
```

이제 양식에는 CSRF 토큰 값이 있는 숨겨진 입력 필드가 포함됩니다.

동일 출처 정책(same origin policy)이 악의적인 사이트가 응답을 읽을 수 없도록 보장하므로 외부 사이트는 CSRF 토큰을 읽을 수 없습니다.

돈을 이체하는 해당 HTTP 요청은 다음과 같습니다:

**동기화 토큰 요청**

```
POST /transfer HTTP/1.1
Host: bank.example.com
Cookie: JSESSIONID=randomid
Content-Type: application/x-www-form-urlencoded

amount=100.00&routingNumber=1234&account=9876&_csrf=4bfd1575-3ad1-4d21-96c7-4ef2d9f86721
```

HTTP 요청에 이제 안전한 임의의 값을 가진 `_csrf` 매개변수가 포함되어 있음을 알 수 있습니다.

악의적인 웹사이트는 `_csrf` 매개변수에 대한 올바른 값을 제공할 수 없으며 (악의적인 웹사이트에 명시적으로 제공되어야 함) 서버가 실제 CSRF 토큰을 예상 CSRF 토큰과 비교할 때 이체는 실패합니다.

### SameSite 속성

CSRF 공격으로부터 보호하는 새로운 방법은 쿠키에 `SameSite` 속성을 지정하는 것입니다.

서버는 쿠키를 설정할 때 `SameSite` 속성을 지정하여 외부 사이트에서 올 때 쿠키를 보내지 않아야 함을 나타낼 수 있습니다.

Spring Security는 세션 쿠키 생성을 직접 제어하지 않으므로 `SameSite` 속성을 지원하지 않습니다.

Spring Session은 서블릿 기반 애플리케이션에서 `SameSite` 속성을 지원합니다.

Spring Framework의 `CookieWebSessionIdResolver`는 WebFlux 기반 애플리케이션에서 `SameSite` 속성을 기본적으로 지원합니다.

`SameSite` 속성이 있는 HTTP 응답 헤더의 예는 다음과 같을 수 있습니다:

**SameSite HTTP 응답**

```
Set-Cookie: JSESSIONID=randomid; Domain=bank.example.com; Secure; HttpOnly; SameSite=Lax
```

`SameSite` 속성에 대한 유효한 값은 다음과 같습니다:

- **Strict**: 지정된 경우 동일 사이트(same-site)에서 오는 모든 요청에 쿠키가 포함됩니다. 그렇지 않으면 쿠키는 HTTP 요청에 포함되지 않습니다.
- **Lax**: 지정된 경우 동일 사이트에서 오거나 요청이 최상위 탐색(top-level navigations)에서 오고 메소드가 읽기 전용일 때 쿠키가 전송됩니다. 그렇지 않으면 쿠키는 HTTP 요청에 포함되지 않습니다.

`SameSite` 속성을 사용하여 예제를 어떻게 보호할 수 있는지 생각해 봅시다.

은행 애플리케이션은 세션 쿠키에 `SameSite` 속성을 지정하여 CSRF로부터 보호할 수 있습니다.

세션 쿠키에 `SameSite` 속성이 설정되면 브라우저는 은행 웹사이트에서 오는 요청과 함께 `JSESSIONID` 쿠키를 계속 보냅니다.

그러나 브라우저는 더 이상 악의적인 웹사이트에서 오는 이체 요청과 함께 `JSESSIONID` 쿠키를 보내지 않습니다.

악의적인 웹사이트에서 오는 이체 요청에 세션이 더 이상 존재하지 않으므로 애플리케이션은 CSRF 공격으로부터 보호됩니다.

`SameSite` 속성을 사용하여 CSRF 공격으로부터 보호할 때 알아야 할 몇 가지 중요한 고려 사항이 있습니다.

`SameSite` 속성을 `Strict`로 설정하면 더 강력한 방어를 제공하지만 사용자를 혼란스럽게 할 수 있습니다.

`social.example.com`에서 호스팅되는 소셜 미디어 사이트에 로그인 상태를 유지하는 사용자를 생각해 봅시다.

사용자는 `email.example.org`에서 소셜 미디어 사이트 링크가 포함된 이메일을 받습니다.

사용자가 링크를 클릭하면 소셜 미디어 사이트에 인증될 것으로 당연히 예상합니다.

그러나 `SameSite` 속성이 `Strict`이면 쿠키가 전송되지 않으므로 사용자는 인증되지 않습니다.

또 다른 명백한 고려 사항은 `SameSite` 속성이 사용자를 보호하려면 브라우저가 `SameSite` 속성을 지원해야 한다는 것입니다.

대부분의 최신 브라우저는 `SameSite` 속성을 지원합니다.

그러나 여전히 사용 중인 구형 브라우저는 지원하지 않을 수 있습니다.

이러한 이유로 일반적으로 CSRF 공격에 대한 유일한 보호책보다는 심층 방어(defense in depth)로 `SameSite` 속성을 사용하는 것이 좋습니다.

### 언제 CSRF 보호를 사용해야 하는가

언제 CSRF 보호를 사용해야 할까요?

일반 사용자가 브라우저로 처리할 수 있는 모든 요청에 대해 CSRF 보호를 사용하는 것이 좋습니다.

브라우저가 아닌 클라이언트만 사용하는 서비스를 만드는 경우 CSRF 보호를 비활성화하고 싶을 것입니다.

### CSRF 보호와 JSON

일반적인 질문은 "JavaScript로 만든 JSON 요청을 보호해야 합니까?"입니다.

간단한 대답은 "상황에 따라 다릅니다."입니다.

그러나 JSON 요청에 영향을 줄 수 있는 CSRF 악용 사례가 있으므로 매우 주의해야 합니다.

예를 들어, 악의적인 사용자는 다음 양식을 사용하여 JSON으로 CSRF를 만들 수 있습니다:

**JSON을 사용한 CSRF 양식**

```html
<form action="<https://bank.example.com/transfer>" method="post" enctype="text/plain">
	<input name='{"amount":100,"routingNumber":"evilsRoutingNumber","account":"evilsAccountNumber", "ignore_me":"' value='test"}' type='hidden'>
	<input type="submit"
		value="Win Money!"/>
</form>
```

이는 다음 JSON 구조를 생성합니다:

**JSON을 사용한 CSRF 요청**

```json
{ "amount": 100,
"routingNumber": "evilsRoutingNumber",
"account": "evilsAccountNumber",
"ignore_me": "=test"
}
```

애플리케이션이 `Content-Type` 헤더를 확인하지 않으면 이 악용에 노출됩니다.

설정에 따라 `Content-Type`을 확인하는 Spring MVC 애플리케이션도 URL 접미사를 `.json`으로 끝나도록 업데이트하여 다음과 같이 악용될 수 있습니다:

**JSON을 사용한 CSRF Spring MVC 양식**

```html
<form action="<https://bank.example.com/transfer.json>" method="post" enctype="text/plain">
	<input name='{"amount":100,"routingNumber":"evilsRoutingNumber","account":"evilsAccountNumber", "ignore_me":"' value='test"}' type='hidden'>
	<input type="submit"
		value="Win Money!"/>
</form>
```

### CSRF와 상태 비저장(Stateless) 브라우저 애플리케이션

애플리케이션이 상태 비저장이라면 어떨까요?

그렇다고 해서 반드시 보호된다는 의미는 아닙니다.

실제로 사용자가 특정 요청에 대해 웹 브라우저에서 어떤 작업도 수행할 필요가 없다면 여전히 CSRF 공격에 취약할 가능성이 높습니다.

예를 들어, 인증을 위해 모든 상태를 포함하는 사용자 지정 쿠키(JSESSIONID 대신)를 사용하는 애플리케이션을 생각해 봅시다.

CSRF 공격이 발생하면 JSESSIONID 쿠키가 이전 예에서 전송된 것과 같은 방식으로 사용자 지정 쿠키가 요청과 함께 전송됩니다. 이

애플리케이션은 CSRF 공격에 취약합니다.

기본 인증(basic authentication)을 사용하는 애플리케이션도 CSRF 공격에 취약합니다.

JSESSIONID 쿠키가 이전 예에서 전송된 것과 같은 방식으로 브라우저가 모든 요청에 사용자 이름과 비밀번호를 자동으로 포함하기 때문에 애플리케이션이 취약합니다.

### CSRF 고려 사항

CSRF 공격에 대한 보호를 구현할 때 고려해야 할 몇 가지 특별한 사항이 있습니다.

### 로그인

로그인 요청 위조를 방지하려면 로그인 HTTP 요청을 CSRF 공격으로부터 보호해야 합니다.

악의적인 사용자가 피해자의 민감한 정보를 읽지 못하도록 하려면 로그인 요청 위조를 방지해야 합니다.

공격은 다음과 같이 수행됩니다:

1. 악의적인 사용자가 악의적인 사용자의 자격 증명으로 CSRF 로그인을 수행합니다. 이제 피해자는 악의적인 사용자로 인증됩니다.
2. 그런 다음 악의적인 사용자는 피해자를 속여 손상된 웹사이트를 방문하고 민감한 정보를 입력하도록 합니다.
3. 정보는 악의적인 사용자의 계정과 연결되므로 악의적인 사용자는 자신의 자격 증명으로 로그인하여 피해자의 민감한 정보를 볼 수 있습니다.

로그인 HTTP 요청이 CSRF 공격으로부터 보호되도록 하는 데 있어 가능한 복잡성은 사용자가 세션 시간 초과를 경험하여 요청이 거부될 수 있다는 것입니다.

세션 시간 초과는 로그인하는 데 세션이 필요하다고 예상하지 않는 사용자에게는 놀라운 일입니다.

자세한 내용은 CSRF와 세션 시간 초과를 참조하세요.

### 로그아웃

로그아웃 요청 위조를 방지하려면 로그아웃 HTTP 요청을 CSRF 공격으로부터 보호해야 합니다.

악의적인 사용자가 피해자의 민감한 정보를 읽지 못하도록 하려면 로그아웃 요청 위조를 방지해야 합니다.

공격에 대한 자세한 내용은 이 블로그 게시물을 참조하세요.

로그아웃 HTTP 요청이 CSRF 공격으로부터 보호되도록 하는 데 있어 가능한 복잡성은 사용자가 세션 시간 초과를 경험하여 요청이 거부될 수 있다는 것입니다.

세션 시간 초과는 로그아웃하는 데 세션이 필요하다고 예상하지 않는 사용자에게는 놀라운 일입니다.

### CSRF와 세션 시간 초과

대부분의 경우 예상 CSRF 토큰은 세션에 저장됩니다.

즉, 세션이 만료되자마자 서버는 예상 CSRF 토큰을 찾지 못하고 HTTP 요청을 거부합니다.

시간 초과를 해결하기 위한 몇 가지 옵션(각각 장단점이 있음)이 있습니다:

- 시간 초과를 완화하는 가장 좋은 방법은 JavaScript를 사용하여 양식 제출 시 CSRF 토큰을 요청하는 것입니다. 그런 다음 양식이 CSRF 토큰으로 업데이트되고 제출됩니다.
- 또 다른 옵션은 사용자에게 세션이 곧 만료될 것임을 알리는 JavaScript를 사용하는 것입니다. 사용자는 버튼을 클릭하여 계속하고 세션을 새로 고칠 수 있습니다.
- 마지막으로 예상 CSRF 토큰을 쿠키에 저장할 수 있습니다. 이렇게 하면 예상 CSRF 토큰이 세션보다 오래 지속될 수 있습니다.

예상 CSRF 토큰이 기본적으로 쿠키에 저장되지 않는 이유를 물을 수 있습니다.

이는 다른 도메인에서 헤더(예: 쿠키 지정)를 설정할 수 있는 알려진 악용 사례가 있기 때문입니다.

이는 Ruby on Rails가 더 이상 `X-Requested-With` 헤더가 있을 때 CSRF 검사를 건너뛰지 않는 이유와 같습니다.

악용을 수행하는 방법에 대한 자세한 내용은 이 [webappsec.org](http://webappsec.org/) 스레드를 참조하세요.

또 다른 단점은 상태(즉, 시간 초과)를 제거하면 토큰이 손상된 경우 강제로 무효화할 수 있는 기능을 잃게 된다는 것입니다.

### 멀티파트 (파일 업로드)

CSRF 공격으로부터 멀티파트 요청(파일 업로드)을 보호하면 닭이 먼저냐 달걀이 먼저냐 하는 문제가 발생합니다.

CSRF 공격이 발생하는 것을 방지하려면 실제 CSRF 토큰을 얻기 위해 HTTP 요청의 본문을 읽어야 합니다.

그러나 본문을 읽는다는 것은 파일이 업로드된다는 것을 의미하며, 이는 외부 사이트가 파일을 업로드할 수 있음을 의미합니다.

`multipart/form-data`와 함께 CSRF 보호를 사용하는 두 가지 옵션이 있습니다:

1. 본문에 CSRF 토큰 배치
2. URL에 CSRF 토큰 배치

각 옵션에는 장단점이 있습니다.

Spring Security의 CSRF 보호를 멀티파트 파일 업로드와 통합하기 전에 먼저 CSRF 보호 없이 업로드할 수 있는지 확인해야 합니다.

Spring에서 멀티파트 양식을 사용하는 방법에 대한 자세한 내용은 Spring 참조의 1.1.11. 멀티파트 리졸버 섹션과 `MultipartFilter` Javadoc을 참조하세요.

### 본문에 CSRF 토큰 배치

첫 번째 옵션은 요청 본문에 실제 CSRF 토큰을 포함하는 것입니다.

본문에 CSRF 토큰을 배치하면 권한 부여가 수행되기 전에 본문을 읽습니다.

즉, 누구나 서버에 임시 파일을 배치할 수 있습니다. 그러나 권한 있는 사용자만 애플리케이션에서 처리되는 파일을 제출할 수 있습니다.

일반적으로 임시 파일 업로드는 대부분의 서버에 거의 영향을 미치지 않아야 하므로 이 방법이 권장됩니다.

### URL에 CSRF 토큰 포함

권한 없는 사용자가 임시 파일을 업로드하는 것을 허용할 수 없는 경우 대안은 양식의 `action` 속성에 예상 CSRF 토큰을 쿼리 매개변수로 포함하는 것입니다.

이 방법의 단점은 쿼리 매개변수가 유출될 수 있다는 것입니다.

보다 일반적으로 민감한 데이터는 유출되지 않도록 본문이나 헤더 내에 배치하는 것이 모범 사례로 간주됩니다.

자세한 정보는 RFC 2616 섹션 15.1.3 URI에 민감한 정보 인코딩에서 찾을 수 있습니다.

### HiddenHttpMethodFilter

일부 애플리케이션은 양식 매개변수를 사용하여 HTTP 메소드를 재정의할 수 있습니다.

예를 들어, 다음 양식은 HTTP 메소드를 post가 아닌 delete로 처리할 수 있습니다.

**CSRF 숨겨진 HTTP 메소드 양식**

```html
<form action="/process"
	method="post">
	<!-- ... -->
	<input type="hidden"
		name="_method"
		value="delete"/>
</form>
```

HTTP 메소드 재정의는 필터에서 발생합니다.

해당 필터는 Spring Security의 지원 앞에 배치되어야 합니다.

재정의는 post에서만 발생하므로 실제로 실제 문제를 일으킬 가능성은 거의 없습니다.

그러나 여전히 Spring Security의 필터 앞에 배치하는 것이 모범 사례입니다.

---

### 😈 내 요청을 도둑맞았다고? CSRF 공격 막아내기!

"사이트 간 요청 위조"라는 말, 좀 어렵죠? 쉽게 말해 **"나도 모르게 내 이름으로 다른 웹사이트에 이상한 요청이 보내지는 공격"** 이라고 생각하면 됩니다. 마치 누군가 내 도장을 훔쳐서 이상한 계약서에 날인하는 것과 같아요.

### 1. CSRF 공격, 대체 뭔가요? (은행 이체 예시로 이해하기 💸)

상상해 봅시다.

1. **정상 상황:** 여러분이 `mybank.com` 은행 사이트에 로그인해서 친구에게 100원을 이체하려고 해요. 이체 폼을 작성하고 "이체하기" 버튼을 누르면, 서버로 다음과 같은 요청이 갑니다.
  - **요청 내용:** "[mybank.com/transfer](http://mybank.com/transfer) 주소로, 금액: 100원, 받는 계좌: 친구계좌"
  - **중요!** 이때 브라우저는 `mybank.com`에 대한 여러분의 **로그인 정보(쿠키)**를 함께 보냅니다. 그래서 은행 서버는 "아, 로그인한 OOO님이 보내는 요청이구나!" 하고 이체를 실행해요.
2. **CSRF 공격 상황:**
  - 여러분이 `mybank.com`에 로그인한 상태에서, 로그아웃하지 않고 **나쁜 해커가 만든 `evil.com` 사이트**를 방문했어요.
  - `evil.com`에는 "공짜 돈 받기!" 같은 솔깃한 버튼이 있고, 그 버튼 뒤에는 **여러분의 은행([mybank.com](http://mybank.com/))으로 돈을 이체하는 가짜 폼**이 숨겨져 있어요.

      ```html
      <!-- evil.com 에 숨겨진 나쁜 폼 -->
      <form method="post" action="<https://mybank.com/transfer>">
          <input type="hidden" name="amount" value="1000000"/> <!-- 금액: 백만원 -->
          <input type="hidden" name="account" value="해커계좌"/> <!-- 받는 계좌: 해커 계좌 -->
          <input type="submit" value="공짜 돈 받기!"/>
      </form>
      ```

  - 여러분이 "공짜 돈 받기!" 버튼을 **클릭하는 순간!**
    - 나도 모르게 `mybank.com/transfer`로 **해커에게 백만원을 이체하라는 요청**이 보내집니다.
    - **가장 무서운 점:** 브라우저는 이 요청을 보낼 때도 `mybank.com`에 대한 **여러분의 로그인 정보(쿠키)**를 함께 보냅니다!
    - 은행 서버는 "아, 로그인한 OOO님이 보내는 요청이구나! 해커에게 백만원 이체해드려야지!" 하고 **실제로 이체를 실행**해 버립니다. 😱

**왜 이런 일이 가능할까요?**

- 은행 서버 입장에서는 **정상적인 사용자가 보낸 요청인지, `evil.com`을 통해 위조된 요청인지 구분할 방법이 없기 때문**입니다. 두 요청 모두 사용자의 유효한 쿠키를 가지고 있으니까요.
- 심지어 JavaScript를 사용하면 버튼 클릭 없이 페이지 방문만으로도 이런 공격이 자동으로 실행될 수 있습니다.

### 2. CSRF 공격, 어떻게 막을 수 있을까요? (Spring Security의 방패 🛡️)

핵심은 **"이 요청이 진짜 우리 웹사이트에서 온 건지, 아니면 다른 엉뚱한 곳에서 온 건지 구별할 수 있는 표식"** 을 만드는 것입니다. Spring Security는 주로 두 가지 방법을 사용해요.

**방법 1: 동기화 토큰 패턴 (Synchronizer Token Pattern) - 가장 강력하고 일반적인 방법!**

이건 마치 "우리끼리만 아는 암호"를 사용하는 것과 같아요.

1. **서버의 역할:**
  - 사용자가 우리 웹사이트에 접속하면, 서버는 **아무도 예측할 수 없는 임의의 문자열(CSRF 토큰)**을 만듭니다.
  - 이 토큰을 사용자의 세션에 저장하고, 동시에 웹 페이지의 폼(form) 안에 숨겨진 필드(`_csrf` 라는 이름으로)에 넣어둡니다.

      ```html
      <!-- 은행 사이트의 안전한 이체 폼 (CSRF 토큰 포함) -->
      <form method="post" action="/transfer">
          <input type="hidden" name="_csrf" value="서버가만든랜덤토큰값"/> <!-- 중요! -->
          <input type="text" name="amount"/>
          <input type="text" name="account"/>
          <input type="submit" value="이체하기"/>
      </form>
      ```

2. **요청 시:**
  - 사용자가 "이체하기" 버튼을 누르면, 폼 데이터와 함께 숨겨진 `_csrf` 토큰 값도 서버로 전송됩니다.
3. **서버의 검증:**
  - 서버는 요청받은 `_csrf` 토큰 값과 사용자의 세션에 저장해둔 토큰 값을 비교합니다.
  - **두 값이 일치하면?** "아, 이건 우리 웹사이트에서 정상적으로 보낸 요청이구나!" -> 이체 실행!
  - **두 값이 일치하지 않으면? (또는 토큰이 없으면?)** "어? 이 요청 뭔가 이상한데? 다른 곳에서 온 건가?" -> 요청 거부! (CSRF 공격 차단!)

**왜 이게 효과가 있을까요?**

- `evil.com` 같은 외부 사이트는 우리 서버가 생성한 CSRF 토큰 값을 **알 수 없습니다.** (동일 출처 정책 때문에 다른 사이트의 페이지 내용을 맘대로 읽을 수 없어요.)
- 따라서 `evil.com`에서 위조된 요청을 보내도, 올바른 CSRF 토큰 값을 함께 보낼 수 없어서 서버에서 차단됩니다.

**중요! 안전한 HTTP 메소드 (GET, HEAD, OPTIONS, TRACE)는 읽기 전용이어야 해요!**
CSRF 보호는 주로 상태를 변경하는 요청(POST, PUT, DELETE 등)에 적용됩니다. GET 요청 같은 경우는 보통 데이터를 조회만 하기 때문에 CSRF 토큰 검사를 생략할 수 있어요. (GET 요청에 토큰을 넣으면 URL에 토큰이 노출되어 유출될 위험도 있고요.)

**방법 2: SameSite 쿠키 속성 (새로운 방어법, 보조 역할)**

쿠키에 `SameSite`라는 특별한 꼬리표를 붙이는 방법이에요.

- **`Set-Cookie: JSESSIONID=...; SameSite=Lax`** (또는 `SameSite=Strict`)
- **`SameSite=Strict`:** 쿠키는 **정확히 동일한 사이트에서 오는 요청에만** 첨부됩니다. 다른 사이트에서 우리 사이트로 링크를 타고 들어올 때도 쿠키가 전송되지 않아서, 사용자가 로그인되어 있음에도 불구하고 로그아웃된 것처럼 보일 수 있는 불편함이 있어요.
- **`SameSite=Lax` (권장):** 동일 사이트 요청에는 쿠키를 보내고, **다른 사이트에서 우리 사이트로 오는 요청 중에서도 최상위 탐색(주소창에 URL 직접 입력, 링크 클릭 등)이고 GET 같은 안전한 메소드일 때만** 쿠키를 보냅니다. `evil.com`에서 `mybank.com`으로 POST 요청을 보내는 CSRF 공격 상황에서는 쿠키를 보내지 않아 공격을 막아줍니다.

**왜 이게 효과가 있을까요?**

- `evil.com`에서 `mybank.com`으로 위조된 요청을 보낼 때, 브라우저가 `SameSite` 속성을 보고 "어? 이건 다른 사이트에서 온 요청이네? 쿠키 보내지 말아야지!" 하고 쿠키 전송을 막아버립니다.
- 쿠키(로그인 정보)가 없으니 은행 서버는 "로그인 안 된 사용자의 요청이네?" 하고 요청을 거부합니다.

**주의점:**

- `SameSite` 속성은 비교적 최신 기능이라 **구형 브라우저는 지원하지 않을 수 있어요.**
- 그래서 `SameSite`는 **단독 방어책보다는 동기화 토큰 패턴과 함께 사용하는 "심층 방어" 전략**으로 쓰는 것이 좋습니다.
- Spring Security는 세션 쿠키 생성을 직접 제어하지 않아서, `SameSite` 설정은 Spring Session이나 Spring Framework 자체 기능을 통해 해야 합니다.

### 3. CSRF 보호, 언제 써야 할까요? 🤔

- **일반 사용자가 브라우저를 통해 하는 모든 요청**에는 CSRF 보호를 사용하는 것이 좋습니다. (특히 상태를 변경하는 POST, PUT, DELETE 요청)
- 만약 여러분의 서비스가 **브라우저가 아닌 순수 API 클라이언트(앱, 다른 서버 등)하고만 통신한다면,** CSRF 보호를 꺼도 될 수 있습니다. (이런 클라이언트는 쿠키를 자동으로 보내지 않으므로 CSRF 공격의 대상이 되기 어렵습니다.)

### 4. 잠깐, JSON 요청도 CSRF 공격당할 수 있나요? 😨

네, **상황에 따라 가능합니다!** "JSON API는 CSRF 안전해~"라고 생각하면 안 돼요.

만약 서버가 `Content-Type` 헤더를 제대로 검증하지 않거나, URL 확장자(`.json`)만으로 JSON 요청을 처리한다면, 해커가 `<form enctype="text/plain">` 같은 트릭을 써서 CSRF 공격을 시도할 수 있습니다.

따라서 JSON 요청이라도 **상태를 변경하는 요청이라면 동기화 토큰 방식 등으로 CSRF 보호를 적용하는 것이 안전합니다.**

### 5. 상태 비저장(Stateless) 애플리케이션도 CSRF에 안전할까요? 🤔

**아니요, 꼭 그렇지는 않습니다!** "상태 비저장"이라는 것이 CSRF로부터 안전하다는 의미는 아니에요.

- 만약 세션 쿠키(JSESSIONID) 대신 **모든 인증 정보를 담은 커스텀 쿠키**를 사용한다면, 그 커스텀 쿠키도 CSRF 공격 시 함께 전송될 수 있어서 여전히 취약합니다.
- *HTTP 기본 인증(Basic Authentication)**을 사용하는 경우에도, 브라우저가 요청마다 아이디/비밀번호를 자동으로 포함해서 보내기 때문에 CSRF 공격에 취약할 수 있습니다.

### 6. CSRF 보호 시 특별히 고려할 점들 🧐

- **로그인/로그아웃 요청도 CSRF 보호해야 하나요?**
  - **네, 하는 것이 좋습니다!**
  - **로그인 CSRF 공격:** 해커가 자신의 계정으로 사용자를 몰래 로그인시킨 후, 사용자가 민감한 정보를 입력하면 그 정보가 해커 계정에 저장되게 할 수 있습니다.
  - **로그아웃 CSRF 공격:** 사용자를 몰래 로그아웃시켜 불편을 초래하거나, 중요한 작업을 방해할 수 있습니다.
  - **문제점:** CSRF 토큰은 보통 세션에 저장되는데, 세션이 만료된 상태에서 로그인/로그아웃을 시도하면 토큰이 없어서 요청이 거부될 수 있습니다. (사용자는 "로그인/아웃하는데 왜 세션이 필요해?" 하고 당황할 수 있죠.)
    - **해결책:** JavaScript로 CSRF 토큰을 다시 요청하거나, 세션 만료 임박 알림, 또는 CSRF 토큰을 세션이 아닌 쿠키에 저장하는 방법 등이 있지만 각각 장단점이 있습니다. (토큰을 쿠키에 저장하면 다른 종류의 공격에 취약해질 수 있는 등...)
- **파일 업로드(Multipart 요청)는 어떻게 하죠?**
  - 파일 업로드 시 CSRF 토큰을 검증하려면 요청 본문을 읽어야 하는데, 본문을 읽는다는 것은 이미 파일이 서버에 (임시로라도) 업로드된다는 뜻입니다. 즉, 공격자가 악성 파일을 올릴 수도 있다는 딜레마가 생깁니다.
  - **옵션 1 (권장): CSRF 토큰을 요청 본문에 포함.** 이 경우 누구나 임시 파일을 서버에 올릴 순 있지만, 실제 처리는 인증되고 CSRF 토큰이 유효한 사용자만 가능합니다. 대부분의 경우 임시 파일 업로드는 큰 문제가 되지 않습니다.
  - **옵션 2: CSRF 토큰을 URL의 쿼리 파라미터에 포함.** (예: `<form action="/upload?_csrf=토큰값">`) 이 방법은 파일이 업로드되기 전에 토큰 검증이 가능하지만, URL에 민감한 정보(토큰)가 노출될 수 있다는 단점이 있습니다.
- **HiddenHttpMethodFilter를 사용한다면?**
  - 폼에서 `_method` 파라미터를 사용해 POST 요청을 PUT이나 DELETE 요청처럼 다루는 경우, 이 `HiddenHttpMethodFilter`는 Spring Security 필터보다 **먼저** 실행되어야 합니다.

---

**오늘의 핵심 요약:**

1. **CSRF는 나도 모르게 내 권한으로 악의적인 요청이 전송되는 공격!** (쿠키가 함께 전송되기 때문)
2. **동기화 토큰 패턴이 주된 방어법!** (서버가 발급한 예측 불가능한 토큰을 요청 시 함께 보내 검증)
3. **`SameSite` 쿠키 속성은 보조 방어법!** (다른 사이트에서 오는 요청에 쿠키 전송을 제한)
4. **상태를 변경하는 모든 요청(POST, PUT, DELETE 등)은 CSRF 보호 대상!** (JSON 요청 포함)
5. **로그인/로그아웃 요청도 CSRF 보호하는 것이 좋지만, 세션 타임아웃 시 고려할 점이 있음!**
6. Spring Security는 기본적으로 CSRF 보호 기능을 켜두지만, 상황에 맞게 설정을 이해하고 사용하는 것이 중요!
