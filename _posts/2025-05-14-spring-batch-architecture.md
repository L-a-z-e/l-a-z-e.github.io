---
title: Spring Batch - Architecture
description: 
author: laze
date: 2025-05-14 00:00:03 +0900
categories: [Dev, SpringBatch]
tags: [SpringBatch]
---
**Spring Batch 아키텍처**

Spring Batch는 확장성과 다양한 최종 사용자 그룹을 염두에 두고 설계되었습니다.

최종 사용자 개발자를 위한 확장성과 사용 편의성을 지원하는 계층형 아키텍처를 보여줍니다.

이 계층형 아키텍처는 애플리케이션(Application), 코어(Core), 인프라스트럭처(Infrastructure)라는 세 가지 주요 상위 수준 구성 요소를 강조합니다.

애플리케이션에는 Spring Batch를 사용하여 개발자가 작성한 모든 배치 작업과 사용자 정의 코드가 포함됩니다.

배치 코어에는 배치 작업을 시작하고 제어하는 데 필요한 핵심 런타임 클래스가 포함되어 있습니다.

여기에는 JobLauncher, Job, Step에 대한 구현이 포함됩니다.

애플리케이션과 코어 모두 공통 인프라스트럭처 위에 구축됩니다.

이 인프라스트럭처에는 애플리케이션 개발자(ItemReader 및 ItemWriter와 같은 리더 및 라이터)와 코어 프레임워크 자체(자체 라이브러리인 재시도(retry)) 모두에서 사용되는 공통 리더 및 라이터와 서비스(예: RetryTemplate)가 포함됩니다.

**일반적인 배치 원칙 및 지침**

배치 솔루션을 구축할 때 다음 주요 원칙, 지침 및 일반적인 고려 사항을 고려해야 합니다.

- 배치 아키텍처는 일반적으로 온라인 아키텍처에 영향을 미치며 그 반대의 경우도 마찬가지임을 기억하십시오. 가능하면 공통 빌딩 블록을 사용하여 두 아키텍처와 환경을 모두 염두에 두고 설계하십시오.
- 최대한 단순화하고 단일 배치 애플리케이션에서 복잡한 논리 구조를 구축하는 것을 피하십시오.
- 데이터 처리와 저장을 물리적으로 가깝게 유지하십시오 (즉, 처리가 발생하는 곳에 데이터를 보관하십시오).
- 특히 I/O와 같은 시스템 리소스 사용을 최소화하십시오. 가능한 한 많은 작업을 내부 메모리에서 수행하십시오.
- 불필요한 물리적 I/O를 피하기 위해 애플리케이션 I/O(SQL 문 분석)를 검토하십시오. 특히 다음과 같은 네 가지 일반적인 결함을 찾아야 합니다.
  - 데이터를 한 번 읽고 캐시하거나 작업 저장소에 보관할 수 있는 경우에도 모든 트랜잭션에 대해 데이터를 읽는 경우.
  - 동일한 트랜잭션에서 이전에 데이터를 읽었던 트랜잭션에 대해 데이터를 다시 읽는 경우.
  - 불필요한 테이블 또는 인덱스 스캔을 유발하는 경우.
  - SQL 문의 WHERE 절에 키 값을 지정하지 않는 경우.
- 배치 실행 중에 동일한 작업을 두 번 수행하지 마십시오. 예를 들어 보고 목적으로 데이터 요약이 필요한 경우, 보고 애플리케이션이 동일한 데이터를 다시 처리할 필요가 없도록 데이터가 초기에 처리될 때 (가능한 경우) 저장된 총계를 증가시켜야 합니다.
- 프로세스 중 시간 소모적인 재할당을 피하기 위해 배치 애플리케이션 시작 시 충분한 메모리를 할당하십시오.
- 데이터 무결성과 관련하여 항상 최악의 상황을 가정하십시오. 데이터 무결성을 유지하기 위해 적절한 검사 및 레코드 유효성 검사를 삽입하십시오.
- 가능한 경우 내부 유효성 검사를 위해 체크섬(checksum)을 구현하십시오. 예를 들어, 플랫 파일에는 파일의 총 레코드 수와 키 필드의 집계를 알려주는 트레일러 레코드가 있어야 합니다.
- 현실적인 데이터 볼륨으로 운영 환경과 유사한 환경에서 가능한 한 빨리 스트레스 테스트를 계획하고 실행하십시오.
- 대규모 배치 시스템에서는 백업이 어려울 수 있으며, 특히 시스템이 연중무휴(24x7) 온라인 애플리케이션과 동시에 실행되는 경우 더욱 그렇습니다. 데이터베이스 백업은 일반적으로 온라인 설계에서 잘 처리되지만 파일 백업도 마찬가지로 중요하게 고려해야 합니다. 시스템이 플랫 파일에 의존하는 경우 파일 백업 절차는 마련되고 문서화되어야 할 뿐만 아니라 정기적으로 테스트되어야 합니다.

**배치 처리 전략**

배치 시스템의 설계 및 구현을 돕기 위해 기본 배치 애플리케이션 빌딩 블록 및 패턴이 샘플 구조 차트 및 코드 셸 형태로 설계자와 프로그래머에게 제공되어야 합니다. 배치 작업을 설계하기 시작할 때 비즈니스 로직은 다음 표준 빌딩 블록을 사용하여 구현할 수 있는 일련의 단계로 분해되어야 합니다.

- **변환 애플리케이션 (Conversion Applications):** 외부 시스템에서 제공하거나 생성하는 각 파일 유형에 대해 제공된 트랜잭션 레코드를 처리에 필요한 표준 형식으로 변환하는 변환 애플리케이션을 만들어야 합니다. 이러한 유형의 배치 애플리케이션은 부분적으로 또는 전체적으로 변환 유틸리티 모듈로 구성될 수 있습니다 (기본 배치 서비스 참조).
- **유효성 검사 애플리케이션 (Validation Applications):** 유효성 검사 애플리케이션은 모든 입력 및 출력 레코드가 정확하고 일관성이 있는지 확인합니다. 유효성 검사는 일반적으로 파일 헤더 및 트레일러, 체크섬 및 유효성 검사 알고리즘, 레코드 수준 교차 확인을 기반으로 합니다.
- **추출 애플리케이션 (Extract Applications):** 추출 애플리케이션은 데이터베이스 또는 입력 파일에서 레코드 세트를 읽고 미리 정의된 규칙에 따라 레코드를 선택한 다음 레코드를 출력 파일에 씁니다.
- **추출/업데이트 애플리케이션 (Extract/Update Applications):** 추출/업데이트 애플리케이션은 데이터베이스 또는 입력 파일에서 레코드를 읽고 각 입력 레코드에서 발견된 데이터를 기반으로 데이터베이스 또는 출력 파일을 변경합니다.
- **처리 및 업데이트 애플리케이션 (Processing and Updating Applications):** 처리 및 업데이트 애플리케이션은 추출 또는 유효성 검사 애플리케이션의 입력 트랜잭션에 대한 처리를 수행합니다. 처리는 일반적으로 처리에 필요한 데이터를 얻기 위해 데이터베이스를 읽고, 잠재적으로 데이터베이스를 업데이트하고, 출력 처리를 위한 레코드를 생성하는 작업을 포함합니다.
- **출력/포맷 애플리케이션 (Output/Format Applications):** 출력/포맷 애플리케이션은 입력 파일을 읽고 이 레코드의 데이터를 표준 형식에 따라 재구성한 다음 인쇄 또는 다른 프로그램이나 시스템으로 전송하기 위한 출력 파일을 생성합니다.

또한, 앞서 언급한 빌딩 블록을 사용하여 구축할 수 없는 비즈니스 로직에 대해서는 기본 애플리케이션 셸이 제공되어야 합니다.

주요 빌딩 블록 외에도 각 애플리케이션은 다음과 같은 하나 이상의 표준 유틸리티 단계를 사용할 수 있습니다.

- **정렬 (Sort):** 입력 파일을 읽고 레코드의 정렬 키 필드에 따라 레코드가 재정렬된 출력 파일을 생성하는 프로그램입니다. 정렬은 일반적으로 표준 시스템 유틸리티에 의해 수행됩니다.
- **분할 (Split):** 단일 입력 파일을 읽고 필드 값을 기반으로 각 레코드를 여러 출력 파일 중 하나에 쓰는 프로그램입니다. 분할은 맞춤형으로 제작하거나 매개변수 기반 표준 시스템 유틸리티로 수행할 수 있습니다.
- **병합 (Merge):** 여러 입력 파일에서 레코드를 읽고 입력 파일의 결합된 데이터로 하나의 출력 파일을 생성하는 프로그램입니다. 병합은 맞춤형으로 제작하거나 매개변수 기반 표준 시스템 유틸리티로 수행할 수 있습니다.

배치 애플리케이션은 입력 소스에 따라 추가로 분류할 수 있습니다.

- **데이터베이스 기반 애플리케이션 (Database-driven applications):** 데이터베이스에서 검색된 행 또는 값에 의해 구동됩니다.
- **파일 기반 애플리케이션 (File-driven applications):** 파일에서 검색된 레코드 또는 값에 의해 구동됩니다.
- **메시지 기반 애플리케이션 (Message-driven applications):** 메시지 큐에서 검색된 메시지에 의해 구동됩니다.

모든 배치 시스템의 기초는 처리 전략입니다.

전략 선택에 영향을 미치는 요인으로는 예상 배치 시스템 볼륨, 온라인 시스템 또는 다른 배치 시스템과의 동시성, 사용 가능한 배치 창 등이 있습니다. (더 많은 기업이 연중무휴(24x7) 운영을 원함에 따라 명확한 배치 창이 사라지고 있다는 점에 유의하십시오).

배치의 일반적인 처리 옵션은 (구현 복잡성 증가 순으로) 다음과 같습니다.

1. 오프라인 모드에서 배치 창 동안의 일반 처리.
2. 동시 배치 또는 온라인 처리.
3. 동시에 여러 다른 배치 실행 또는 작업의 병렬 처리.
4. 파티셔닝 (동시에 동일한 작업의 여러 인스턴스 처리).
5. 위 옵션들의 조합.

이러한 옵션 중 일부 또는 전부는 상용 스케줄러에서 지원될 수 있습니다.

이 섹션의 나머지 부분에서는 이러한 처리 옵션에 대해 자세히 설명합니다.

일반적으로 배치 프로세스에서 채택하는 커밋 및 잠금 전략은 수행되는 처리 유형에 따라 다르며 온라인 잠금 전략도 동일한 원칙을 사용해야 한다는 점에 유의하십시오.

따라서 배치 아키텍처는 전체 아키텍처를 설계할 때 단순한 사후 고려 사항이 될 수 없습니다.

잠금 전략은 일반 데이터베이스 잠금만 사용하거나 아키텍처에 추가적인 사용자 정의 잠금 서비스를 구현하는 것일 수 있습니다.

잠금 서비스는 데이터베이스 잠금을 추적하고(예: 전용 데이터베이스 테이블에 필요한 정보 저장) 데이터베이스 작업을 요청하는 애플리케이션 프로그램에 권한을 부여하거나 거부합니다.

잠금 상황 발생 시 배치 작업 중단을 피하기 위해 이 아키텍처에 재시도 로직을 구현할 수도 있습니다.

1. **배치 창에서의 일반 처리**
   온라인 사용자나 다른 배치 프로세스에서 업데이트되는 데이터가 필요하지 않은 별도의 배치 창에서 실행되는 간단한 배치 프로세스의 경우 동시성은 문제가 되지 않으며 배치 실행 종료 시 단일 커밋을 수행할 수 있습니다.

   대부분의 경우 더 강력한 접근 방식이 더 적절합니다. 배치 시스템은 시간이 지남에 따라 복잡성과 처리하는 데이터 볼륨 모두에서 증가하는 경향이 있다는 점을 명심하십시오. 잠금 전략이 없고 시스템이 여전히 단일 커밋 지점에 의존하는 경우 배치 프로그램을 수정하는 것이 어려울 수 있습니다. 따라서 가장 간단한 배치 시스템이라도 재시작-복구 옵션을 위한 커밋 로직의 필요성과 이 섹션의 뒷부분에서 설명하는 더 복잡한 경우에 대한 정보를 고려하십시오.

2. **동시 배치 또는 온라인 처리**
   온라인 사용자가 동시에 업데이트할 수 있는 데이터를 처리하는 배치 애플리케이션은 온라인 사용자가 몇 초 이상 필요로 할 수 있는 데이터(데이터베이스 또는 파일)를 잠그지 않아야 합니다. 또한 업데이트는 몇 개의 트랜잭션마다 데이터베이스에 커밋되어야 합니다. 이렇게 하면 다른 프로세스에서 사용할 수 없는 데이터 부분과 데이터가 사용할 수 없는 경과 시간을 최소화할 수 있습니다.

   물리적 잠금을 최소화하는 또 다른 옵션은 낙관적 잠금 패턴 또는 비관적 잠금 패턴 중 하나로 구현된 논리적 행 수준 잠금을 사용하는 것입니다.

   **낙관적 잠금(Optimistic locking)** 은 레코드 경합 가능성이 낮다고 가정합니다. 일반적으로 배치 및 온라인 처리 모두에서 동시에 사용되는 각 데이터베이스 테이블에 타임스탬프 열을 삽입하는 것을 의미합니다. 애플리케이션이 처리를 위해 행을 가져올 때 타임스탬프도 가져옵니다. 그런 다음 애플리케이션이 처리된 행을 업데이트하려고 할 때 WHERE 절에 원래 타임스탬프를 사용합니다. 타임스탬프가 일치하면 데이터와 타임스탬프가 업데이트됩니다. 타임스탬프가 일치하지 않으면 다른 애플리케이션이 가져오기와 업데이트 시도 사이에 동일한 행을 업데이트했음을 나타냅니다. 따라서 업데이트를 수행할 수 없습니다.

   **비관적 잠금(Pessimistic locking)** 은 레코드 경합 가능성이 높다고 가정하므로 검색 시 물리적 또는 논리적 잠금을 얻어야 하는 모든 잠금 전략입니다. 한 가지 유형의 비관적 논리적 잠금은 데이터베이스 테이블에 전용 잠금 열을 사용합니다. 애플리케이션이 업데이트를 위해 행을 검색할 때 잠금 열에 플래그를 설정합니다. 플래그가 설정되면 동일한 행을 검색하려는 다른 애플리케이션은 논리적으로 실패합니다. 플래그를 설정한 애플리케이션이 행을 업데이트하면 플래그도 지워 다른 애플리케이션이 행을 검색할 수 있게 됩니다. 초기 가져오기와 플래그 설정 사이에도 데이터 무결성이 유지되어야 합니다(예: SELECT FOR UPDATE와 같은 데이터베이스 잠금 사용). 또한 이 방법은 사용자가 레코드를 잠근 상태에서 점심을 먹으러 간 경우 잠금이 해제되도록 하는 시간 초과 메커니즘을 구축하는 것이 다소 쉽다는 점을 제외하고는 물리적 잠금과 동일한 단점을 겪는다는 점에 유의하십시오.

   이러한 패턴은 배치 처리에 반드시 적합한 것은 아니지만 동시 배치 및 온라인 처리에 사용될 수 있습니다(예: 데이터베이스가 행 수준 잠금을 지원하지 않는 경우). 일반적으로 낙관적 잠금은 온라인 애플리케이션에 더 적합하고 비관적 잠금은 배치 애플리케이션에 더 적합합니다. 논리적 잠금을 사용할 때마다 논리적 잠금으로 보호되는 데이터 엔터티에 액세스하는 모든 애플리케이션에 동일한 체계를 사용해야 합니다.

   이 두 가지 솔루션 모두 단일 레코드 잠금만 처리한다는 점에 유의하십시오. 종종 논리적으로 관련된 레코드 그룹을 잠가야 할 수도 있습니다. 물리적 잠금을 사용하면 잠재적인 교착 상태(deadlock)를 피하기 위해 이를 매우 신중하게 관리해야 합니다. 논리적 잠금을 사용하면 보호하려는 논리적 레코드 그룹을 이해하고 잠금이 일관되고 교착 상태가 발생하지 않도록 보장할 수 있는 논리적 잠금 관리자를 구축하는 것이 일반적으로 가장 좋습니다. 이 논리적 잠금 관리자는 일반적으로 잠금 관리, 경합 보고, 시간 초과 메커니즘 및 기타 문제에 대해 자체 테이블을 사용합니다.

3. **병렬 처리 (Parallel Processing)**
   병렬 처리를 사용하면 여러 배치 실행 또는 작업을 병렬로 실행하여 총 경과 배치 처리 시간을 최소화할 수 있습니다. 작업이 동일한 파일, 데이터베이스 테이블 또는 인덱스 공간을 공유하지 않는 한 이는 문제가 되지 않습니다. 공유하는 경우 이 서비스는 파티션된 데이터를 사용하여 구현해야 합니다. 또 다른 옵션은 제어 테이블을 사용하여 상호 의존성을 유지 관리하는 아키텍처 모듈을 구축하는 것입니다. 제어 테이블에는 각 공유 리소스와 애플리케이션에서 사용 중인지 여부에 대한 행이 포함되어야 합니다. 병렬 작업의 배치 아키텍처 또는 애플리케이션은 해당 테이블에서 정보를 검색하여 필요한 리소스에 액세스할 수 있는지 여부를 결정합니다.

   데이터 액세스가 문제가 되지 않으면 병렬 처리는 병렬로 처리하기 위해 추가 스레드를 사용하여 구현할 수 있습니다. 메인프레임 환경에서는 모든 프로세스에 적절한 CPU 시간을 보장하기 위해 전통적으로 병렬 작업 클래스가 사용되었습니다. 그럼에도 불구하고 솔루션은 실행 중인 모든 프로세스에 대해 시간 조각(time slices)을 보장할 만큼 충분히 강력해야 합니다.

   병렬 처리의 다른 주요 문제로는 로드 밸런싱과 파일, 데이터베이스 버퍼 풀 등과 같은 일반 시스템 리소스의 가용성이 있습니다. 또한 제어 테이블 자체가 쉽게 중요한 리소스가 될 수 있다는 점에 유의하십시오.

4. **파티셔닝 (Partitioning)**
   파티셔닝을 사용하면 대규모 배치 애플리케이션의 여러 버전을 동시에 실행할 수 있습니다. 이는 긴 배치 작업 처리에 필요한 경과 시간을 줄이기 위한 것입니다.
5. 성공적으로 파티셔닝할 수 있는 프로세스는 입력 파일을 분할하거나 기본 데이터베이스 테이블을 파티셔닝하여 애플리케이션이 서로 다른 데이터 세트에 대해 실행될 수 있도록 하는 프로세스입니다.

   또한 파티션된 프로세스는 할당된 데이터 세트만 처리하도록 설계되어야 합니다. 파티셔닝 아키텍처는 데이터베이스 설계 및 데이터베이스 파티셔닝 전략과 밀접하게 연관되어야 합니다.

   데이터베이스 파티셔닝이 반드시 데이터베이스의 물리적 파티셔닝을 의미하는 것은 아닙니다(대부분의 경우 권장되지만).

   아키텍처는 파티션 수를 동적으로 구성할 수 있도록 유연해야 합니다. 자동 및 사용자 제어 구성을 모두 고려해야 합니다. 자동 구성은 입력 파일 크기 및 입력 레코드 수와 같은 매개변수를 기반으로 할 수 있습니다.

   **4.1 파티셔닝 접근 방식**
   파티셔닝 접근 방식 선택은 사례별로 수행해야 합니다. 다음 목록은 가능한 몇 가지 파티셔닝 접근 방식을 설명합니다.

  1. **레코드 세트의 고정되고 균등한 분할**
     이는 입력 레코드 세트를 균등한 수의 부분으로 나누는 것을 포함합니다(예: 10개, 각 부분은 전체 레코드 세트의 정확히 1/10을 가짐). 그런 다음 각 부분은 배치/추출 애플리케이션의 한 인스턴스에 의해 처리됩니다.

     이 접근 방식을 사용하려면 레코드 세트를 분할하기 위한 전처리가 필요합니다. 이 분할의 결과는 배치/추출 애플리케이션에 입력으로 사용하여 해당 부분만 처리하도록 제한할 수 있는 하한 및 상한 배치 번호입니다.

     전처리는 레코드 세트의 각 부분의 경계를 계산하고 결정해야 하므로 오버헤드가 클 수 있습니다.

  2. **키 열별 분할**
     이는 위치 코드와 같은 키 열별로 입력 레코드 세트를 분할하고 각 키의 데이터를 배치 인스턴스에 할당하는 것을 포함합니다. 이를 달성하기 위해 열 값은 다음 중 하나일 수 있습니다.
    - 파티셔닝 테이블(이 섹션의 뒷부분에서 설명)에 의해 배치 인스턴스에 할당됩니다.
    - 값의 일부(예: 0000-0999, 1000-1999 등)에 의해 배치 인스턴스에 할당됩니다.

     옵션 1에서는 새 값을 추가하면 새 값이 특정 인스턴스에 추가되도록 배치 또는 추출을 수동으로 재구성해야 합니다.

     옵션 2에서는 모든 값이 배치 작업의 인스턴스에 의해 처리되도록 보장합니다. 그러나 한 인스턴스에서 처리되는 값의 수는 열 값의 분포에 따라 달라집니다(0000-0999 범위에는 많은 위치가 있고 1000-1999 범위에는 거의 없을 수 있음). 이 옵션에서는 데이터 범위를 파티셔닝을 염두에 두고 설계해야 합니다.

     두 옵션 모두에서 레코드를 배치 인스턴스에 최적으로 균등하게 분배할 수는 없습니다. 사용되는 배치 인스턴스 수에 대한 동적 구성이 없습니다.

  3. **뷰(View)별 분할**
     이 접근 방식은 기본적으로 데이터베이스 수준에서 키 열별 분할입니다. 레코드 세트를 뷰로 나누는 것을 포함합니다. 이러한 뷰는 처리 중에 배치 애플리케이션의 각 인스턴스에서 사용됩니다. 분할은 데이터를 그룹화하여 수행됩니다.

     이 옵션을 사용하면 배치 애플리케이션의 각 인스턴스가 특정 뷰(기본 테이블 대신)를 사용하도록 구성되어야 합니다. 또한 새 데이터 값을 추가하면 이 새 데이터 그룹을 뷰에 포함해야 합니다. 인스턴스 수 변경으로 인해 뷰가 변경되므로 동적 구성 기능이 없습니다.

  4. **처리 표시자 추가**
     이는 표시기 역할을 하는 새 열을 입력 테이블에 추가하는 것을 포함합니다. 전처리 단계로 모든 표시기는 처리되지 않은 것으로 표시됩니다. 배치 애플리케이션의 레코드 가져오기 단계에서 개별 레코드가 처리되지 않은 것으로 표시된 조건으로 레코드를 읽고, 일단 읽으면(잠금 포함) 처리 중으로 표시됩니다. 해당 레코드가 완료되면 표시기는 완료 또는 오류로 업데이트됩니다. 추가 열이 레코드가 한 번만 처리되도록 보장하므로 변경 없이 배치 애플리케이션의 여러 인스턴스를 시작할 수 있습니다.

     이 옵션을 사용하면 테이블의 I/O가 동적으로 증가합니다. 업데이트 배치 애플리케이션의 경우 어쨌든 쓰기가 발생해야 하므로 이 영향은 줄어듭니다.

  5. **테이블을 플랫 파일로 추출**
     이 접근 방식은 테이블을 플랫 파일로 추출하는 것을 포함합니다. 그런 다음 이 파일을 여러 세그먼트로 분할하여 배치 인스턴스의 입력으로 사용할 수 있습니다.

     이 옵션을 사용하면 테이블을 파일로 추출하고 분할하는 추가 오버헤드가 다중 파티셔닝 효과를 상쇄할 수 있습니다. 파일 분할 스크립트를 변경하여 동적 구성을 달성할 수 있습니다.

  6. **해싱 열 사용**
     이 체계는 드라이버 레코드를 검색하는 데 사용되는 데이터베이스 테이블에 해시 열(키 또는 인덱스)을 추가하는 것을 포함합니다. 이 해시 열에는 배치 애플리케이션의 어떤 인스턴스가 이 특정 행을 처리하는지 결정하는 표시기가 있습니다. 예를 들어, 시작할 배치 인스턴스가 3개 있는 경우 'A' 표시기는 인스턴스 1에서 처리할 행을 표시하고, 'B' 표시기는 인스턴스 2에서 처리할 행을 표시하고, 'C' 표시기는 인스턴스 3에서 처리할 행을 표시합니다.

     그런 다음 레코드를 검색하는 데 사용되는 프로시저에는 특정 표시기로 표시된 모든 행을 선택하는 추가 WHERE 절이 있습니다. 이 테이블의 삽입에는 인스턴스 중 하나(예: 'A')로 기본 설정되는 마커 필드 추가가 포함됩니다.

     다른 인스턴스 간의 로드를 재분배하는 등 표시기를 업데이트하는 데 간단한 배치 애플리케이션이 사용됩니다. 충분히 많은 수의 새 행이 추가되면 이 배치를 실행하여(배치 창을 제외한 언제든지) 새 행을 다른 인스턴스에 재분배할 수 있습니다.

     배치 애플리케이션의 추가 인스턴스는 새 인스턴스 수로 작업하도록 표시기를 재분배하기 위해 (앞 단락에서 설명한 대로) 배치 애플리케이션을 실행하기만 하면 됩니다.


    **4.2 데이터베이스 및 애플리케이션 설계 원칙**
    
    파티션된 데이터베이스 테이블에 대해 실행되고 키 열 접근 방식을 사용하는 다중 파티션 애플리케이션을 지원하는 아키텍처에는 파티션 매개변수를 저장하기 위한 중앙 파티션 저장소(repository)가 포함되어야 합니다. 이는 유연성을 제공하고 유지 관리성을 보장합니다. 저장소는 일반적으로 파티션 테이블로 알려진 단일 테이블로 구성됩니다.
    
    파티션 테이블에 저장된 정보는 정적이며 일반적으로 DBA가 유지 관리해야 합니다. 테이블은 다중 파티션 애플리케이션의 각 파티션에 대한 정보 행 하나로 구성되어야 합니다. 테이블에는 프로그램 ID 코드, 파티션 번호(파티션의 논리적 ID), 이 파티션에 대한 데이터베이스 키 열의 하한값, 이 파티션에 대한 데이터베이스 키 열의 상한값에 대한 열이 있어야 합니다.
    
    프로그램 시작 시 프로그램 ID와 파티션 번호는 아키텍처(특히 제어 처리 태스크릿)에서 애플리케이션으로 전달되어야 합니다. 키 열 접근 방식을 사용하는 경우 이러한 변수는 파티션 테이블을 읽어 애플리케이션이 처리할 데이터 범위를 결정하는 데 사용됩니다. 또한 파티션 번호는 다음을 위해 처리 전반에 걸쳐 사용되어야 합니다.
    
    - 병합 프로세스가 제대로 작동하도록 출력 파일 또는 데이터베이스 업데이트에 추가합니다.
    - 정상 처리를 배치 로그에 보고하고 모든 오류를 아키텍처 오류 처리기에 보고합니다.
    
    **4.3 교착 상태(Deadlock) 최소화**
    
    애플리케이션이 병렬로 실행되거나 파티션될 때 데이터베이스 리소스 경합 및 교착 상태가 발생할 수 있습니다. 데이터베이스 설계 팀이 데이터베이스 설계의 일부로 잠재적인 경합 상황을 최대한 제거하는 것이 중요합니다.
    
    또한 개발자는 데이터베이스 인덱스 테이블이 교착 상태 방지 및 성능을 염두에 두고 설계되었는지 확인해야 합니다.
    
    교착 상태 또는 핫스팟은 종종 로그 테이블, 제어 테이블 및 잠금 테이블과 같은 관리 또는 아키텍처 테이블에서 발생합니다. 이러한 영향도 고려해야 합니다. 현실적인 스트레스 테스트는 아키텍처의 가능한 병목 현상을 식별하는 데 중요합니다.
    
    데이터 충돌의 영향을 최소화하기 위해 아키텍처는 데이터베이스에 연결하거나 교착 상태가 발생할 때 서비스(예: 대기 및 재시도 간격)를 제공해야 합니다. 이는 특정 데이터베이스 반환 코드에 반응하고 즉각적인 오류를 발생시키는 대신 미리 결정된 시간 동안 기다렸다가 데이터베이스 작업을 재시도하는 내장 메커니즘을 의미합니다.
    
    **4.4 매개변수 전달 및 유효성 검사**
    
    파티션 아키텍처는 애플리케이션 개발자에게 비교적 투명해야 합니다. 아키텍처는 다음을 포함하여 파티션 모드에서 애플리케이션을 실행하는 것과 관련된 모든 작업을 수행해야 합니다.
    
    - 애플리케이션 시작 전에 파티션 매개변수 검색.
    - 애플리케이션 시작 전에 파티션 매개변수 유효성 검사.
    - 시작 시 애플리케이션에 매개변수 전달.
    
    유효성 검사에는 다음을 확인하는 검사가 포함되어야 합니다.
    
    - 애플리케이션에 전체 데이터 범위를 포괄할 수 있는 충분한 파티션이 있는지 확인합니다.
    - 파티션 사이에 간격이 없는지 확인합니다.
    - 데이터베이스가 파티션된 경우 단일 파티션이 데이터베이스 파티션에 걸쳐 있지 않은지 확인하기 위해 추가 유효성 검사가 필요할 수 있습니다.
    
    또한 아키텍처는 파티션 통합을 고려해야 합니다. 주요 질문은 다음과 같습니다.
    
    - 다음 작업 단계로 넘어가기 전에 모든 파티션이 완료되어야 합니까?
    - 파티션 중 하나가 중단되면 어떻게 됩니까?

---

## Spring Batch 튼튼하게 짓기! - 아키텍처와 전략 파헤치기 🏛️

우리가 집을 지을 때 설계도가 중요하듯이, Spring Batch 애플리케이션을 만들 때도 그 구조(아키텍처)를 이해하는 것이 매우 중요해요. 그리고 어떤 방식으로 데이터를 처리할지(전략) 결정하는 것도 중요하죠.

### 🏗️ Spring Batch의 설계도: 계층형 아키텍처

Spring Batch는 크게 세 개의 층으로 이루어져 있다고 생각할 수 있어요. 마치 3층짜리 건물처럼요!

[그림 1. Spring Batch 계층형 아키텍처 (머릿속으로 상상해주세요!)]

- **3층: 애플리케이션 (Application) - "우리가 만드는 것"**
  - 이곳은 우리가 직접 코드를 작성하는 공간이에요. 우리가 만들고 싶은 **배치 작업(Job)**이나, 데이터를 어떻게 읽고, 가공하고, 쓸지에 대한 **우리만의 규칙(Custom Code)**들이 여기에 해당돼요.
  - **예시:** "매일 고객 데이터를 읽어서, VIP 고객을 선별하고, 그 결과를 파일로 저장하는 작업"을 만든다면, 이 작업 내용 전체가 '애플리케이션' 층에 속해요.
- **2층: 배치 코어 (Batch Core) - "Spring Batch의 심장"**
  - 이곳은 Spring Batch가 실제로 작업을 시작하고, 제어하고, 관리하는 데 필요한 **핵심 부품들**이 모여 있는 곳이에요. 우리가 직접 만들기보다는 Spring Batch가 제공하는 부품들을 가져다 쓰는 거죠.
  - 주요 부품:
    - **JobLauncher:** 배치 작업을 "시작!" 시켜주는 실행기.
    - **Job:** 하나의 배치 작업 전체를 의미해요. (예: "월말 정산 작업")
    - **Step:** Job을 구성하는 독립적인 단계들이에요. 하나의 Job은 여러 Step으로 이루어질 수 있어요. (예: "데이터 읽기 Step", "데이터 처리 Step", "데이터 쓰기 Step")
  - **예시:** 우리가 만든 "VIP 고객 선별 작업(Job)"을 `JobLauncher`가 실행시키고, 이 Job은 "고객 데이터 읽기(Step)", "VIP 고객 필터링(Step)", "결과 파일 저장(Step)" 같은 여러 단계(Step)들로 구성될 수 있어요.
- **1층: 인프라스트럭처 (Infrastructure) - "모두가 함께 쓰는 도구 상자"**
  - 이곳은 '애플리케이션' 층과 '배치 코어' 층 모두에서 공통적으로 사용하는 **기반 기술이나 도구들**이 있는 곳이에요.
  - 주요 도구:
    - **Readers/Writers (ItemReader, ItemWriter):** 파일에서 데이터를 읽거나(Reader), 데이터베이스에 데이터를 쓰는(Writer) 것과 같이 데이터 입출력을 담당하는 도구들이에요. (우리가 직접 만들거나, Spring Batch가 제공하는 것을 사용해요)
    - **서비스 (Services):** 예를 들어, 작업 중 문제가 생겼을 때 자동으로 몇 번 더 시도해보는 **재시도(Retry) 기능** 같은 유용한 서비스들이 있어요.
  - **예시:** "고객 데이터를 파일에서 읽어올 때" 사용하는 `ItemReader`나, "결과를 데이터베이스에 저장할 때" 사용하는 `ItemWriter` 등이 인프라스트럭처에 속해요. 작업 실패 시 재시도를 도와주는 `RetryTemplate` 같은 것도 여기에 포함돼요.

**핵심 포인트:**

- Spring Batch는 **애플리케이션, 코어, 인프라스트럭처** 3개의 계층으로 구성되어 있어요.
- **애플리케이션:** 개발자가 직접 만드는 배치 로직.
- **코어:** 배치 실행 및 제어를 위한 핵심 엔진 (Job, Step, JobLauncher 등).
- **인프라스트럭처:** 공통으로 사용되는 데이터 입출력 도구 및 서비스.
- 이런 계층 구조 덕분에 개발자는 **비즈니스 로직(애플리케이션)에 집중**할 수 있고, 필요에 따라 기능을 **확장하거나 변경하기 쉬워요.**

---

### 💡 배치 시스템 만들 때 꼭 기억해야 할 것들! (일반 원칙 및 지침)

훌륭한 배치 시스템을 만들려면 몇 가지 중요한 원칙들을 기억해야 해요. 이건 Spring Batch 뿐만 아니라 일반적인 배치 시스템 설계에도 도움이 되는 내용이에요.

1. **온라인 시스템과의 조화 🤝:** 배치 시스템은 혼자 돌아가는 외톨이가 아니에요. 실시간으로 사용자와 상호작용하는 온라인 시스템(예: 웹사이트)에 영향을 줄 수 있고, 반대로 영향을 받을 수도 있어요. 처음부터 둘 다 고려해서 설계해야 해요.
2. **단순함이 최고! (Keep It Simple) ✨:** 하나의 배치 작업에 너무 많은 복잡한 로직을 넣지 마세요. 간단하고 명확하게 만드는 것이 좋아요.
3. **데이터는 처리하는 곳 가까이! 🚚:** 데이터를 처리하는 프로그램과 데이터가 저장된 곳(데이터베이스, 파일 서버 등)은 물리적으로 가까이 있는 게 좋아요. 데이터 이동 시간을 줄여서 성능을 높일 수 있거든요. (네트워크 지연 최소화!)
4. **자원 아껴 쓰기 (특히 I/O) 💾:** 시스템 자원(CPU, 메모리, 디스크 등)을 효율적으로 사용해야 해요. 특히 파일이나 데이터베이스를 읽고 쓰는 작업(I/O)은 느리기 때문에 최소화하는 게 중요해요. 가능하면 메모리 안에서 많은 작업을 처리하세요.
5. **불필요한 I/O는 NO! 🙅‍♀️ (SQL 꼼꼼히 보기):**
  - 매번 똑같은 데이터를 읽지 말고, 한 번 읽어서 캐시(임시 저장)하거나 메모리에 보관해두세요.
  - 같은 작업 안에서 이미 읽었던 데이터를 또 읽지 마세요.
  - SQL 쿼리가 불필요하게 테이블 전체를 훑거나(Table Scan) 인덱스를 제대로 못 타는지 확인하세요.
  - SQL의 `WHERE` 절에 검색 조건을 명확히 지정해서 필요한 데이터만 가져오세요.
6. **한 번에 끝내기! (중복 작업 X) ☝️:** 배치 작업 중에 같은 일을 두 번 하지 마세요. 예를 들어, 보고서를 만들기 위해 데이터를 요약해야 한다면, 처음 데이터를 처리할 때 미리 요약 정보를 업데이트해두세요. 나중에 보고서 만들 때 또다시 전체 데이터를 처리할 필요가 없도록요.
7. **메모리는 넉넉하게 시작! 🧠:** 작업 시작할 때 필요한 메모리를 충분히 할당해주세요. 중간에 메모리가 부족해서 다시 할당받는 건 시간이 오래 걸릴 수 있어요.
8. **데이터는 소중하니까! (데이터 무결성) 🛡️:** 데이터가 깨지거나 잘못될 수 있다는 최악의 상황을 항상 가정하세요. 중간중간 데이터가 올바른지 검사하고, 문제가 있으면 기록하는 로직을 꼭 넣으세요.
  - **체크섬(Checksum):** 파일의 맨 마지막에 "이 파일에는 총 몇 개의 레코드가 있고, 중요한 값들을 다 더하면 얼마야!" 같은 정보를 기록해서 파일이 온전한지 검증할 수 있어요.
9. **실전처럼 테스트! (스트레스 테스트) 🏋️‍♂️:** 실제 운영 환경과 최대한 비슷한 환경에서, 실제 데이터만큼 많은 양으로 미리 테스트(스트레스 테스트)를 해봐야 해요. 그래야 예상치 못한 문제를 미리 발견할 수 있어요.
10. **백업은 필수! (특히 파일) 💿:** 대규모 배치 시스템에서는 데이터 백업이 중요해요. 데이터베이스 백업은 잘 되어 있는 경우가 많지만, 배치 작업이 파일에 의존한다면 파일 백업도 아주 중요해요. 백업 계획을 세우고, 문서화하고, 정기적으로 테스트해야 해요.

**핵심 포인트:**

- 배치 시스템은 **온라인 시스템과 함께 고려**해야 하며, **단순하고 효율적으로** 만들어야 해요.
- **I/O 최소화, 중복 작업 방지, 충분한 메모리 확보, 데이터 무결성 검증, 철저한 테스트, 확실한 백업**이 중요해요.

---

### 🛠️ 배치 작업, 어떻게 조립할까? (배치 처리 전략)

배치 작업을 설계할 때는 마치 레고 블록을 조립하듯, 비즈니스 로직을 여러 단계로 나누고, 각 단계에 맞는 표준적인 처리 방식(빌딩 블록)을 적용할 수 있어요.

**대표적인 배치 애플리케이션 유형 (빌딩 블록):**

- **변환 (Conversion):** 외부 시스템에서 받은 파일을 우리 시스템이 이해할 수 있는 표준 형식으로 바꾸는 작업. (예: CSV 파일을 XML 파일로 변환)
- **유효성 검사 (Validation):** 입력 데이터나 출력 데이터가 정확하고 일관성 있는지 확인하는 작업. (예: 고객 정보 파일의 전화번호 형식이 올바른지 검사)
- **추출 (Extract):** 데이터베이스나 파일에서 특정 조건에 맞는 데이터만 골라내서 다른 곳으로 옮기는 작업. (예: "서울"에 사는 고객 정보만 추출)
- **추출/업데이트 (Extract/Update):** 데이터를 읽어서, 그 내용을 바탕으로 데이터베이스나 파일을 수정하는 작업.
- **처리 및 업데이트 (Processing & Updating):** 데이터를 읽고, 복잡한 비즈니스 로직을 적용하여 처리하고, 그 결과를 데이터베이스에 반영하거나 새로운 데이터를 생성하는 작업. (가장 일반적인 형태)
- **출력/포맷 (Output/Format):** 데이터를 읽어서, 정해진 형식(보고서, 전송용 파일 등)으로 만들어 출력하는 작업.

**추가로 사용될 수 있는 유틸리티 단계:**

- **정렬 (Sort):** 데이터를 특정 기준(예: 고객 이름순)으로 정렬.
- **분할 (Split):** 하나의 파일을 여러 개의 작은 파일로 나눔. (예: 주문 데이터를 지역별 파일로 분리)
- **병합 (Merge):** 여러 개의 파일을 하나의 파일로 합침.

**데이터 입력 소스에 따른 분류:**

- **데이터베이스 기반:** 데이터베이스에서 데이터를 읽어와 처리.
- **파일 기반:** 파일에서 데이터를 읽어와 처리.
- **메시지 기반:** 메시지 큐(MQ)에서 메시지를 받아와 처리.

**가장 중요한 건 "처리 전략"!**

어떤 전략으로 배치 시스템을 운영할지는 여러 요소를 고려해서 결정해야 해요.

- **처리할 데이터 양 (Volume):** 얼마나 많은 데이터를 처리해야 하는가?
- **온라인 시스템과의 동시성 (Concurrency):** 배치 작업 중에도 온라인 시스템이 계속 돌아가야 하는가?
- **배치 작업 시간 (Batch Window):** 배치 작업을 실행할 수 있는 시간이 얼마나 되는가? (요즘엔 24시간 서비스가 많아서 이 "창"이 점점 줄어들고 있어요!)

**일반적인 배치 처리 옵션 (복잡도 순):**

1. **단독 실행 (Normal processing in a batch window):**
  - 가장 간단한 방식. 온라인 시스템이 멈춘 심야 시간(배치 창)에 배치 작업 혼자 돌아가는 거예요. 다른 시스템과 데이터 충돌 걱정이 적어요.
  - **주의!** 데이터가 많아지거나 로직이 복잡해지면 이 방식만으로는 부족할 수 있어요. 처음부터 작업 실패 시 재시작/복구를 위한 **커밋(Commit) 전략**을 잘 세워야 해요. (예: 1000건 처리마다 커밋)
2. **온라인 시스템과 함께 실행 (Concurrent batch or on-line processing):**
  - 온라인 사용자가 쓰는 데이터를 배치 작업도 동시에 건드려야 할 때 사용해요.
  - **핵심:** 배치 작업이 데이터를 너무 오래 붙잡고 있으면(Lock) 온라인 사용자가 불편하겠죠? 그래서 아주 짧은 시간만 잠그고, 자주 커밋해서 다른 작업들이 데이터를 쓸 수 있게 해줘야 해요.
  - **잠금(Locking) 전략이 중요!**
    - **낙관적 잠금 (Optimistic Locking):** "충돌 별로 안 나겠지?" 하는 긍정적인 가정. 데이터를 읽을 때 버전 정보(예: 타임스탬프)도 같이 읽어와요. 나중에 수정할 때, 버전 정보가 그대로면 수정 성공! 버전 정보가 바뀌었으면 "어? 누가 먼저 바꿨네!" 하고 실패 처리해요. (주로 온라인 시스템에 적합)
    - **비관적 잠금 (Pessimistic Locking):** "충돌 날 것 같아!" 하는 비관적인 가정. 데이터를 읽을 때부터 "이거 내가 쓸 거니까 아무도 건드리지 마!" 하고 잠가버려요. (주로 배치 시스템에 적합)
    - 이런 잠금 방식은 하나의 레코드에 대한 것이고, 여러 레코드를 논리적으로 묶어서 잠가야 할 때는 더 복잡한 **논리적 잠금 관리자**가 필요할 수 있어요.
3. **여러 작업 동시에 돌리기 (Parallel Processing):**
  - 서로 다른 여러 개의 배치 작업(Job)이나 실행(Run)을 동시에 돌려서 전체 처리 시간을 줄이는 거예요.
  - **조건:** 작업들이 같은 파일이나 데이터베이스 테이블을 동시에 건드리지 않아야 해요. 만약 공유해야 한다면, 데이터를 잘 나눠서(파티셔닝) 처리하거나, 어떤 작업이 어떤 자원을 쓰고 있는지 알려주는 **제어 테이블(Control Table)** 같은 걸 사용해야 해요.
  - **고려사항:** CPU, 메모리 같은 시스템 자원이 충분한지, 작업 부하가 잘 분산되는지(로드 밸런싱) 신경 써야 해요.
4. **하나의 작업을 쪼개서 동시에 돌리기 (Partitioning):**
  - 이게 바로 앞에서 잠깐 언급했던 **파티셔닝**이에요! 아주 큰 작업 하나를 여러 개의 작은 조각으로 나눠서, 여러 컴퓨터(또는 여러 스레드)에서 동시에 촥촥촥! 처리하는 거예요.
  - **목표:** 아주 긴~~ 배치 작업의 처리 시간을 획기적으로 줄이는 것!
  - **조건:** 입력 데이터를 잘게 나눌 수 있거나, 데이터베이스 테이블을 여러 영역으로 나눌 수 있어야 해요. 그리고 각 조각(파티션)은 자기가 맡은 데이터만 처리하도록 잘 설계해야 해요.
  - **파티셔닝 방법들 (엄청 다양해요!):**
    1. **똑같이 나누기:** 전체 데이터를 N 등분해서 각자 처리. (미리 나누는 작업 필요)
    2. **기준값(Key)으로 나누기:** 지역 코드, 고객 ID 범위 등으로 나눠서 처리. (데이터 분포에 따라 한쪽에 몰릴 수 있음)
    3. **데이터베이스 뷰(View)로 나누기:** 특정 조건에 맞는 데이터만 보여주는 뷰를 여러 개 만들어서 각자 처리.
    4. **"나 처리 중!" 표시하기 (Processing Indicator):** 데이터에 "처리 중" 표시를 추가해서, 여러 작업이 동시에 달려들어도 한 데이터는 한 번만 처리되도록 하는 방식.
    5. **파일로 빼서 나누기:** 큰 테이블 데이터를 일단 파일로 다 뽑아낸 다음, 그 파일을 여러 개로 쪼개서 각자 처리.
    6. **해시값으로 나누기:** 데이터에 해시값을 부여해서, 특정 해시값을 가진 데이터는 특정 작업이 처리하도록 분배.
  - **파티셔닝할 때 중요한 것들:**
    - **중앙 관리소 (Partition Repository):** 어떤 파티션이 어떤 데이터를 처리할지 정보를 저장하는 곳(파티션 테이블)이 있으면 좋아요.
    - **교착 상태 (Deadlock) 조심!** 여러 작업이 동시에 데이터베이스 자원을 쓰려고 하다가 서로 발목을 잡는 상황을 최대한 피해야 해요. 데이터베이스 설계, 인덱스 설계를 잘해야 하고, 문제가 생겼을 때 잠시 기다렸다가 다시 시도하는(Wait-and-Retry) 기능도 필요해요.
    - **파라미터 전달 및 검증:** 각 파티션 작업에게 "너는 이만큼의 데이터만 처리해!" 하고 정보를 잘 전달하고, 그 정보가 올바른지 검증해야 해요.
    - **파티션 작업 관리:** 모든 파티션 작업이 다 끝나야 다음 단계로 넘어갈지, 중간에 하나라도 실패하면 어떻게 할지 등을 결정해야 해요.

**핵심 포인트:**

- 배치 작업은 **표준적인 빌딩 블록** (변환, 검증, 추출 등)으로 구성될 수 있어요.
- 처리 전략은 **데이터 양, 동시성, 작업 시간** 등을 고려하여 선택해야 해요.
- **단독 실행, 동시 실행 (잠금 중요!), 병렬 처리, 파티셔닝 (대용량 처리에 효과적!)** 등 다양한 전략이 있어요.
- 특히 **파티셔닝**은 대용량 데이터를 빠르게 처리하기 위한 강력한 기술이며, 다양한 접근 방식과 고려 사항이 있어요.
