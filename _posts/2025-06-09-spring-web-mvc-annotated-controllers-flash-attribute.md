---
title: Spring Web MVC - Annotated Controllers (FlashAttributes)
description: 
author: laze
date: 2025-06-09 00:00:01 +0900
categories: [Dev, SpringWebMVC]
tags: [SpringWebMVC]
---
### Flash Attributes (플래시 속성)

플래시 속성(Flash attributes)은 한 요청이 다른 요청에서 사용될 속성을 저장할 수 있는 방법을 제공합니다.

이는 주로 리다이렉트 시에 가장 흔하게 필요합니다.

예를 들어, Post-Redirect-Get 패턴이 그렇습니다.

플래시 속성은 리다이렉트 전에 (일반적으로 세션에) 임시로 저장되었다가, 리다이렉트 후의 요청에서 사용 가능하게 되고 즉시 제거됩니다.

스프링 MVC는 플래시 속성을 지원하기 위한 두 가지 주요 추상화(abstractions)를 가지고 있습니다.

`FlashMap`은 플래시 속성을 담는 데 사용되고, `FlashMapManager`는 `FlashMap` 인스턴스를 저장, 검색 및 관리하는 데 사용됩니다.

플래시 속성 지원은 항상 "켜져 있으며(on)" 명시적으로 활성화할 필요가 없습니다.

그러나 사용되지 않으면 HTTP 세션 생성을 유발하지 않습니다.

각 요청마다, 이전 요청에서 전달된 속성을 가진 "입력(input)" `FlashMap`(있는 경우)과 후속 요청을 위해 저장할 속성을 가진 "출력(output)" `FlashMap`이 있습니다.

두 `FlashMap` 인스턴스 모두 스프링 MVC 어디에서나 `RequestContextUtils`의 정적 메소드를 통해 접근할 수 있습니다.

어노테이션 기반 컨트롤러는 일반적으로 `FlashMap`을 직접 다룰 필요가 없습니다.

대신, `@RequestMapping` 메소드는 `RedirectAttributes` 타입의 인자를 받아 리다이렉트 시나리오를 위한 플래시 속성을 추가하는 데 사용할 수 있습니다.

`RedirectAttributes`를 통해 추가된 플래시 속성은 자동으로 "출력" `FlashMap`으로 전파됩니다.

유사하게, 리다이렉트 후에는 "입력" `FlashMap`의 속성들이 대상 URL을 서비스하는 컨트롤러의 `Model`에 자동으로 추가됩니다.

### 요청과 플래시 속성 매칭하기

플래시 속성의 개념은 다른 많은 웹 프레임워크에도 존재하며, 때때로 동시성 문제(concurrency issues)에 노출될 수 있다는 것이 입증되었습니다.

이는 정의상 플래시 속성이 다음 요청까지 저장되어야 하기 때문입니다.

그러나 바로 "다음" 요청이 의도된 수신자가 아니라 다른 비동기 요청(예: 폴링 또는 리소스 요청)일 수 있으며, 이 경우 플래시 속성이 너무 일찍 제거됩니다.

이러한 문제의 가능성을 줄이기 위해, `RedirectView`는 자동으로 `FlashMap` 인스턴스에 대상 리다이렉트 URL의 경로(path)와 쿼리 파라미터(query parameters)로 "스탬프(stamps)"를 찍습니다.

결과적으로, 기본 `FlashMapManager`는 "입력" `FlashMap`을 찾을 때 이 정보를 들어오는 요청과 매칭시킵니다.

이것이 동시성 문제의 가능성을 완전히 제거하지는 않지만, 리다이렉트 URL에 이미 사용 가능한 정보를 통해 크게 줄여줍니다.

따라서, 플래시 속성은 주로 리다이렉트 시나리오에 사용하는 것을 권장합니다.

---

### **학습 목표 제시**

이 챕터를 학습하고 나면, 학생은 다음을 이해하고 수행할 수 있게 됩니다:

1. **플래시 속성의 개념과 동작 원리 심층 이해:** 플래시 속성이 왜 필요하며, 어떻게 (세션을 통해) 임시 저장되고, 리다이렉트 후 요청에서 어떻게 사용된 후 제거되는지 그 생명주기와 메커니즘을 정확히 이해합니다.
2. **`FlashMap`과 `FlashMapManager`의 역할 인지:** 플래시 속성 지원의 핵심 내부 구성 요소인 `FlashMap`과 `FlashMapManager`가 어떤 역할을 하는지 개념적으로 이해합니다. (직접 사용할 일은 적더라도)
3. **플래시 속성 사용 시 동시성 문제 가능성 및 스프링 MVC의 완화 전략 이해:** 플래시 속성이 어떤 상황에서 동시성 문제를 겪을 수 있는지, 그리고 스프링 MVC가 이를 어떻게 완화하려고 하는지 (`RedirectView`의 URL 스탬핑) 이해합니다.

---

### **핵심 개념 설명**

**플래시 속성이란 무엇이고, 왜 필요할까요? (복습 및 심화)**

이미 알고 계시겠지만, 플래시 속성은 **한 번의 리다이렉트를 거쳐 데이터를 전달하는 데 사용되는 특별한 종류의 속성**입니다.

- **"Flash" (번쩍임):** 이름처럼, 리다이렉트된 후의 요청에서 딱 한 번 사용(조회)되고 나면 바로 사라집니다. 마치 카메라 플래시처럼 잠깐 번쩍하고 마는 거죠.
- **주 사용처: Post-Redirect-Get (PRG) 패턴:**
  1. **Post:** 사용자가 폼을 제출 (예: 게시글 작성, 주문 완료).
  2. **Redirect:** 서버는 데이터를 처리하고, 클라이언트에게 다른 URL로 리다이렉트하라고 응답. 이때, "게시글이 성공적으로 등록되었습니다."와 같은 메시지를 플래시 속성으로 전달.
  3. **Get:** 클라이언트는 새로운 URL로 GET 요청을 보내고, 서버는 결과 페이지를 보여줌. 이 페이지에서 플래시 속성으로 전달된 메시지를 표시. 만약 사용자가 이 페이지에서 새로고침(F5)을 해도, 플래시 속성은 이미 사라졌으므로 메시지가 반복해서 나타나지 않습니다. (이것이 중요한 장점!)

**플래시 속성의 동작 원리 (내부 메커니즘)**

1. **속성 추가 (리다이렉트 전 요청):**
  - 개발자는 컨트롤러에서 `RedirectAttributes`의 `addFlashAttribute("이름", 값)` 메소드를 사용하여 플래시 속성을 추가합니다.
  - 스프링 MVC는 이 속성들을 **"출력(output)" `FlashMap`*이라는 특별한 저장소에 담습니다.
  - 리다이렉트가 결정되면, 이 "출력" `FlashMap`의 내용은 **HTTP 세션에 임시로 저장**됩니다. (이때, `FlashMap` 자체는 세션에 저장될 때 만료 시간이나 대상 경로 같은 추가 정보를 가질 수 있습니다.)
2. **리다이렉트 발생:**
  - 클라이언트는 서버로부터 리다이렉트 응답(예: HTTP 302)을 받고, 새로운 URL로 다시 요청을 보냅니다.
3. **속성 사용 (리다이렉트 후 요청):**
  - 새로운 요청이 서버에 도착하면, 스프링 MVC는 HTTP 세션에서 이전에 저장해둔 `FlashMap`이 있는지 확인합니다.
  - 만약 있다면, 해당 `FlashMap`의 내용을 꺼내어 **"입력(input)" `FlashMap`*으로 만듭니다.
  - 그리고 이 "입력" `FlashMap`에 있는 속성들을 **컨트롤러의 `Model` 객체에 자동으로 추가**해줍니다.
  - 따라서 리다이렉트된 요청을 처리하는 컨트롤러나 뷰에서는 마치 일반적인 모델 속성처럼 플래시 속성 값에 접근할 수 있습니다.
  - **중요:** 이렇게 "입력" `FlashMap`에서 속성을 읽어 `Model`에 추가하고 나면, **해당 플래시 속성들은 세션에서 즉시 제거됩니다.** (그래서 딱 한 번만 사용 가능)

**플래시 속성 지원은 항상 "켜져 있다"**

- 개발자가 플래시 속성을 사용하기 위해 특별한 설정을 할 필요는 없습니다.
- 만약 플래시 속성을 전혀 사용하지 않는다면, 불필요하게 HTTP 세션이 생성되지 않습니다. 즉, 필요할 때만 동작합니다.

**`FlashMap`과 `FlashMapManager`**

- **`FlashMap`:** 플래시 속성들을 담는 바구니와 같습니다. `Map`과 유사한 형태로 이름-값 쌍을 저장합니다. 또한, 만료 시간이나 대상 URL 같은 메타데이터도 가질 수 있습니다.
- **`FlashMapManager`:** 이 `FlashMap` 바구니들을 관리하는 매니저입니다.
  - 리다이렉트 전에 "출력" `FlashMap`을 (주로 세션에) 저장합니다.
  - 리다이렉트 후에 들어온 요청에 대해 (주로 세션에서) "입력" `FlashMap`을 찾아 꺼내줍니다.
  - `FlashMap`의 생명주기를 관리합니다 (예: 만료된 `FlashMap` 정리).

  > 학생분께서 직접 FlashMap이나 FlashMapManager를 코드로 다룰 일은 거의 없을 겁니다. RedirectAttributes를 사용하는 것만으로도 충분합니다. 하지만 내부적으로 이런 요소들이 동작하고 있다는 것을 이해하면 도움이 됩니다.
>

**`RequestContextUtils`**

- 만약 어노테이션 기반 컨트롤러가 아닌 곳(예: 필터, 인터셉터, 또는 뷰 기술 내부)에서 플래시 속성에 접근해야 할 필요가 있다면, `RequestContextUtils` 클래스의 정적 메소드들(`getInputFlashMap(request)`, `getOutputFlashMap(request)`)을 사용할 수 있습니다. 하지만 일반적인 컨트롤러 개발에서는 거의 필요 없습니다.

### **주요 용어 해설 (복습 및 추가)**

- **"입력(input)" `FlashMap`:** 현재 요청에서 사용할 수 있도록 이전 요청에서 전달된 플래시 속성들을 담고 있는 `FlashMap`.
- **"출력(output)" `FlashMap`:** 현재 요청에서 다음 요청으로 전달하기 위해 설정한 플래시 속성들을 담고 있는 `FlashMap`. 리다이렉트 시 이 내용이 세션 등으로 저장됩니다.
- **동시성 문제 (Concurrency Issue):** 여러 작업(여기서는 여러 HTTP 요청)이 동시에 실행될 때, 공유 자원(여기서는 플래시 속성)에 대한 접근 순서나 타이밍 때문에 예기치 않은 결과가 발생하는 문제입니다.
- **폴링 (Polling):** 클라이언트가 일정한 주기로 서버에게 새로운 정보가 있는지 계속 물어보는 방식.
- **URL 스탬핑 (URL Stamping):** `RedirectView`가 플래시 속성을 저장할 때, 해당 속성이 사용될 것으로 예상되는 리다이렉트 대상 URL 정보(경로, 쿼리 파라미터)를 함께 기록해두는 것.

### **요청과 플래시 속성 매칭하기 (동시성 문제 완화)**

**문제 상황:**

플래시 속성은 "다음 요청"을 위해 저장됩니다. 그런데 요즘 웹 애플리케이션은 사용자가 페이지를 보고 있는 동안에도 백그라운드에서 여러 비동기 요청(AJAX 요청, 웹소켓, 서버 센트 이벤트 등)을 보낼 수 있습니다.

만약 사용자가 A 작업을 하고 리다이렉트되면서 플래시 메시지 "A 작업 완료!"를 받기로 했는데, 리다이렉트된 페이지가 로드되기 *직전에* 백그라운드에서 B라는 비동기 요청이 먼저 서버에 도달했다고 가정해봅시다. 서버는 이 B 요청을 "다음 요청"으로 오인하여 "A 작업 완료!" 플래시 메시지를 B 요청에게 줘버리고 세션에서 지워버릴 수 있습니다. 그러면 정작 사용자가 보게 될 리다이렉트된 페이지에서는 메시지가 보이지 않게 되는 문제가 발생할 수 있습니다. 이것이 동시성 문제입니다.

**스프링 MVC의 해결 노력:**

이런 문제를 완전히 없애기는 어렵지만, 스프링 MVC는 `RedirectView`를 통해 다음과 같은 방법으로 완화하려고 합니다:

1. **URL 스탬핑:** `RedirectAttributes`를 통해 플래시 속성을 추가하고 리다이렉트가 발생하면, `RedirectView`는 생성되는 `FlashMap`에 **리다이렉트 대상 URL의 정보(경로와 쿼리 파라미터)를 "스탬프"처럼 찍어둡니다.**
2. **매칭 로직:** 이후 요청이 들어왔을 때, `FlashMapManager`는 세션에서 `FlashMap`을 꺼낼 때, **현재 들어온 요청의 URL 정보와 `FlashMap`에 찍힌 스탬프 정보가 일치하는지 확인**합니다. 일치하는 경우에만 해당 `FlashMap`을 "입력" `FlashMap`으로 간주하고 내용을 전달합니다.

**예시:**

- 사용자가 `/orders`로 POST 요청 (주문 생성).
- 서버는 `redirectAttributes.addFlashAttribute("message", "주문 성공!");`을 하고 `return "redirect:/orders/confirmation?orderId=123";`로 리다이렉트.
- 이때 생성되는 `FlashMap`에는 `message` 속성과 함께, 대상 URL 정보 (`/orders/confirmation?orderId=123`)가 스탬프로 찍힙니다.
- 만약 리다이렉트 직후 `/some/other/async/request`라는 비동기 요청이 먼저 서버에 도달해도, 이 요청의 URL은 스탬프와 일치하지 않으므로 `FlashMapManager`는 `message`를 이 요청에게 주지 않습니다.
- 이후 사용자의 브라우저가 실제로 `/orders/confirmation?orderId=123`으로 GET 요청을 보내면, 이 URL은 스탬프와 일치하므로 `message` 플래시 속성이 정상적으로 전달됩니다.

**한계 및 권장 사항:**

- 이 스탬핑 방식은 동시성 문제를 "크게 줄여주지만", "완전히 제거하지는 못합니다". (예: 만약 비동기 요청도 우연히 같은 대상 URL로 요청한다면?)
- 따라서, **플래시 속성은 주로 일반적인 동기식 리다이렉트 시나리오(사용자 행동에 따른 페이지 이동)에 사용하는 것이 가장 안전하고 권장됩니다.** 복잡한 비동기 통신이 많은 환경에서는 플래시 속성 외의 다른 메시지 전달 방식을 고려할 수도 있습니다.

### **"왜?" 라는 질문에 대한 답변**

**플래시 속성의 내부 메커니즘(`FlashMap`, `FlashMapManager`, URL 스탬핑)은 왜 이렇게 설계되었을까요?**

1. **상태 비저장(Stateless) HTTP의 한계 극복:** HTTP는 기본적으로 상태를 유지하지 않습니다. 각 요청은 독립적입니다. 하지만 리다이렉트 시에는 이전 요청의 결과를 다음 요청에게 전달해야 하는 "상태 유지"의 필요성이 생깁니다. 세션을 임시 저장소로 사용하는 것은 이러한 한계를 극복하는 일반적인 방법입니다.
2. **데이터의 일회성 보장 및 자동 정리:** "작업 완료" 메시지 등은 딱 한 번만 보여주는 것이 적절합니다. 플래시 속성은 사용 후 즉시 제거되도록 설계되어 개발자가 수동으로 세션에서 데이터를 지우는 번거로움을 덜어줍니다. 이는 코드의 깔끔함과 버그 방지에 기여합니다.
3. **URL 오염 방지:** 중요한 정보는 아니지만 사용자에게 알려줘야 할 내용(예: 알림 메시지)을 URL에 모두 담으면 URL이 지저분해지고 길어집니다. 플래시 속성은 이를 깔끔하게 해결합니다.
4. **동시성 문제에 대한 현실적인 고려:** 웹 환경의 복잡성을 인지하고, 발생 가능한 동시성 문제를 최소화하려는 노력이 URL 스탬핑 기능에 반영되어 있습니다. 완벽하진 않지만, 실용적인 수준에서 문제를 완화합니다.
5. **개발 편의성 제공 (`RedirectAttributes`):** 개발자가 세션 관리나 `FlashMap`의 저수준 API를 직접 다루지 않고도, `RedirectAttributes`라는 고수준의 편리한 인터페이스를 통해 플래시 속성을 쉽게 사용할 수 있도록 추상화했습니다.

결국, 플래시 속성과 관련된 스프링 MVC의 설계는 "어떻게 하면 리다이렉트 상황에서 데이터를 안전하고, 편리하며, 예측 가능하게 전달할 수 있을까?"라는 고민에 대한 해답이라고 볼 수 있습니다.

### **주의사항 및 Best Practice (복습 및 강조)**

1. **주로 리다이렉트 시나리오에 사용:** 플래시 속성의 설계 목적과 동시성 문제 완화 전략을 고려할 때, 가장 적합한 사용처는 사용자의 명시적인 행동에 따른 페이지 리다이렉트입니다.
2. **세션 사용 인지:** 플래시 속성은 내부적으로 HTTP 세션을 사용합니다. 이는 대부분의 웹 애플리케이션에서 문제가 되지 않지만, 극단적으로 세션 사용을 피해야 하는 환경이라면 대안을 고려해야 합니다. (하지만 이런 경우는 드뭅니다.)
3. **너무 많은 데이터 저장 지양:** 플래시 속성도 세션에 저장되므로, 매우 큰 객체나 많은 양의 데이터를 플래시 속성으로 전달하는 것은 세션 부하를 유발할 수 있습니다. 간단한 메시지나 식별자 정도를 전달하는 것이 일반적입니다.
4. **`RedirectAttributes` 사용 생활화:** 컨트롤러에서 플래시 속성을 추가할 때는 항상 `RedirectAttributes`를 사용하는 것이 표준적이고 권장되는 방식입니다.

### **이전 학습 내용과의 연관성**

- **`RedirectAttributes`:** 이번 챕터는 이전 챕터에서 배운 `RedirectAttributes.addFlashAttribute()`의 내부 동작을 상세히 설명하는 내용입니다. 두 챕터는 매우 밀접하게 연결됩니다.
- **HTTP 세션:** 플래시 속성의 임시 저장소로 HTTP 세션이 사용된다는 점은, 앞으로 배울 세션 관리(@SessionAttributes, HttpSession 직접 사용 등)와도 연결고리가 됩니다.
- **스프링 MVC 요청 처리 흐름:** 플래시 속성이 "출력 FlashMap"에서 세션으로, 다시 세션에서 "입력 FlashMap"으로, 그리고 최종적으로 Model로 전달되는 과정은 스프링 MVC의 요청 처리 생명주기 내에서 일어납니다.

---
