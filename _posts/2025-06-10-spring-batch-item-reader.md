---
title: Spring Batch - ItemReader
description: 
author: laze
date: 2025-06-10 00:00:02 +0900
categories: [Dev, SpringBatch]
tags: [SpringBatch]
---
### 아이템 리더 (ItemReader)

단순한 개념이지만, `ItemReader`는 다양한 유형의 입력으로부터 데이터를 제공하는 수단입니다. 가장 일반적인 예는 다음과 같습니다:

- **플랫 파일(Flat File):** 플랫 파일 아이템 리더는 플랫 파일에서 데이터 라인을 읽습니다. 이 파일은 일반적으로 파일 내 고정된 위치 또는 특정 구분 문자(예: 쉼표)로 정의된 데이터 필드를 가진 레코드를 설명합니다.
- **XML:** XML 아이템 리더는 객체의 파싱, 매핑 및 유효성 검사에 사용되는 기술과 독립적으로 XML을 처리합니다. 입력 데이터는 XSD 스키마에 대한 XML 파일의 유효성 검사를 허용합니다.
- **데이터베이스(Database):** 데이터베이스 리소스에 접근하여 결과 집합(resultsets)을 반환하며, 이는 처리를 위해 객체로 매핑될 수 있습니다. 기본 SQL 아이템 리더 구현은 객체를 반환하기 위해 `RowMapper`를 호출하고, 재시작이 필요한 경우 현재 행을 추적하며, 기본 통계를 저장하고, 나중에 설명할 몇 가지 트랜잭션 향상 기능을 제공합니다.

더 많은 가능성이 있지만, 이 챕터에서는 기본적인 것들에 초점을 맞춥니다. 사용 가능한 모든 `ItemReader` 구현의 전체 목록은 부록 A에서 찾을 수 있습니다.

`ItemReader`는 다음 인터페이스 정의와 같이 일반적인 입력 작업을 위한 기본 인터페이스입니다:

```java
public interface ItemReader<T> {

    T read() throws Exception, UnexpectedInputException, ParseException, NonTransientResourceException;

}
```

`read` 메서드는 `ItemReader`의 가장 본질적인 계약을 정의합니다.

이를 호출하면 하나의 아이템을 반환하거나, 더 이상 아이템이 없으면 `null`을 반환합니다.

아이템은 파일의 한 줄, 데이터베이스의 한 행 또는 XML 파일의 한 요소를 나타낼 수 있습니다.

일반적으로 이러한 아이템들은 사용 가능한 도메인 객체(예: `Trade`, `Foo` 등)로 매핑될 것으로 예상되지만, 계약상 그렇게 해야 할 의무는 없습니다.

`ItemReader` 인터페이스의 구현은 전진 전용(forward only)으로 예상됩니다.

그러나 기본 리소스가 트랜잭션(예: JMS 큐)인 경우, 롤백 시나리오에서 `read`를 호출하면 후속 호출에서 동일한 논리적 아이템을 반환할 수 있습니다.

또한 `ItemReader`가 처리할 아이템이 없다고 해서 예외가 발생하는 것은 아니라는 점에 유의할 가치가 있습니다.

예를 들어, 0개의 결과를 반환하는 쿼리로 구성된 데이터베이스 `ItemReader`는 `read`의 첫 번째 호출에서 `null`을 반환합니다.

---

### **학습 목표 제시**

이번 "ItemReader" 챕터를 통해 학생분은 다음을 이해하고 배울 수 있습니다:

1. **`ItemReader`의 역할과 중요성 이해:** Spring Batch에서 데이터 입력의 시작점으로서 `ItemReader`가 어떤 역할을 하는지, 왜 필요한지를 파악합니다.
2. **`ItemReader` 인터페이스의 핵심 계약 파악:** `ItemReader` 인터페이스의 `read()` 메서드가 어떻게 동작하고, 무엇을 반환하며, 어떤 예외를 던질 수 있는지 이해합니다.
3. **다양한 `ItemReader` 구현 유형 인지:** 플랫 파일, XML, 데이터베이스 등 일반적인 데이터 소스에 대한 `ItemReader` 구현 유형들을 인지하고, 각 유형이 어떤 특징을 가지는지 간략하게 이해합니다.

---

### **핵심 개념 설명**

이 챕터의 핵심은 **"Spring Batch가 어떻게 다양한 소스로부터 데이터를 읽어오는가?"** 이며, 그 중심에는 `ItemReader` 인터페이스가 있습니다.

### 1. `ItemReader`란 무엇인가?

- **개념:** 말 그대로 "아이템(데이터 하나하나)을 읽어오는 녀석"입니다. 배치 처리의 첫 단계로, 파일, 데이터베이스, 메시징 큐 등 다양한 데이터 소스로부터 데이터를 하나씩 순차적으로 읽어와 다음 단계(주로 `ItemProcessor`나 `ItemWriter`)로 전달하는 역할을 합니다.
- **비유:**
  - **책 읽는 사람:** 책(데이터 소스)에서 한 문장(아이템)씩 읽어서 이해(처리)하는 사람.
  - **자판기:** 동전(입력)을 넣으면 상품(아이템)을 하나씩 내어주는 기계.
  - **컨베이어 벨트 시작점:** 원재료(데이터)를 하나씩 벨트 위에 올려놓는 작업자.
- **중요성:**
  - **데이터 소스의 추상화:** `ItemReader` 인터페이스를 사용함으로써, 개발자는 데이터 소스의 종류(파일, DB 등)에 크게 구애받지 않고 일관된 방식으로 데이터를 읽는 로직을 작성할 수 있습니다. Spring Batch는 다양한 종류의 데이터 소스를 위한 `ItemReader` 구현체들을 제공합니다.
  - **청크 기반 처리의 시작:** Spring Batch는 대용량 데이터를 효율적으로 처리하기 위해 "청크(Chunk)" 단위로 작업을 수행합니다. `ItemReader`는 이 청크를 구성할 아이템들을 하나씩 읽어오는 역할을 합니다.
- **"왜 필요한가?"**:
  - 모든 배치 작업은 처리할 데이터가 있어야 시작됩니다. `ItemReader`는 이 데이터를 공급하는 표준화된 방법을 제공하여, 개발자가 데이터 소스의 복잡한 세부 사항에 신경 쓰지 않고 비즈니스 로직에 집중할 수 있도록 돕습니다.
  - 다양한 데이터 소스를 지원해야 하는 요구사항을 충족시키기 위해, 각 소스에 맞는 읽기 전략을 캡슐화한 컴포넌트가 필요합니다.

### 2. `ItemReader` 인터페이스 살펴보기

```java
public interface ItemReader<T> {

    T read() throws Exception, UnexpectedInputException, ParseException, NonTransientResourceException;

}
```

- **`T` (제네릭 타입 파라미터):** `ItemReader`가 읽어올 아이템의 타입을 나타냅니다. 예를 들어, CSV 파일에서 고객 정보를 읽는다면 `T`는 `Customer` 클래스가 될 수 있습니다.
- **`read()` 메서드:**
  - **핵심 계약:** 이 인터페이스의 유일한 메서드이자 가장 중요한 부분입니다. 호출될 때마다 데이터 소스로부터 **하나의 아이템**을 읽어서 반환합니다.
  - **반환 값:**
    - 성공적으로 아이템을 읽으면 해당 아이템 객체 (`T` 타입)를 반환합니다.
    - **더 이상 읽을 아이템이 없으면 `null`을 반환합니다.** 이것이 매우 중요합니다! `null`은 "데이터 끝"을 의미하며, Spring Batch는 이를 보고 해당 스텝의 읽기 작업을 종료합니다.
  - **예외 (Exceptions):**
    - `Exception`: 일반적인 예외 상황.
    - `UnexpectedInputException`: 예상치 못한 입력 형식이나 데이터로 인해 더 이상 진행이 불가능할 때 발생합니다. (예: 파일 형식이 완전히 잘못된 경우)
    - `ParseException`: 데이터를 특정 객체로 파싱(변환)하는 과정에서 오류가 발생했을 때 사용됩니다. (예: 문자열을 숫자로 변환하려는데 "abc" 같은 값이 들어온 경우)
    - `NonTransientResourceException`: 일시적이지 않은, 즉 재시도해도 해결되기 어려운 리소스 관련 문제가 발생했을 때 사용됩니다. (예: 파일이 존재하지 않거나, DB 연결이 끊어졌는데 복구 불가능한 경우)
      - *Transient vs. Non-Transient*: "Transient"는 "일시적인"이라는 뜻입니다. `TransientResourceException`이라면 잠시 후 재시도하면 성공할 수도 있는 문제(예: 네트워크 잠깐 불안정)를 의미하지만, `NonTransientResourceException`은 좀 더 심각하고 지속적인 문제를 나타냅니다.
- **전진 전용 (Forward Only):** 일반적으로 `ItemReader`는 데이터를 앞으로만 읽어 나갑니다. 한번 읽은 아이템을 다시 뒤로 돌아가서 읽는 기능(rewind)은 기본적으로 지원하지 않습니다. (물론, 특정 구현체는 내부적으로 그러한 기능을 가질 수도 있지만, 인터페이스 계약 자체는 전진만 가정합니다.)
- **트랜잭션 리소스와 롤백:** 만약 `ItemReader`가 트랜잭션 리소스(예: JMS 메시지 큐)에서 데이터를 읽는 경우, 트랜잭션이 롤백되면 다음 `read()` 호출 시 이전에 읽었던 (하지만 커밋되지 않은) 동일한 아이템을 다시 반환할 수 있습니다. 이는 "메시지 소비가 완료되지 않았으므로 다시 처리해야 한다"는 의미입니다.
- **데이터 없음 != 예외:** `read()` 메서드가 `null`을 반환하는 것은 "더 이상 읽을 데이터가 없다"는 정상적인 상황이지, 예외 상황이 아닙니다.

### 3. 일반적인 `ItemReader` 구현 유형

문서에서는 세 가지 주요 유형을 언급하고 있습니다.

- **플랫 파일 (Flat File `ItemReader`s):**
  - **대상:** CSV (쉼표로 구분된 값), TSV (탭으로 구분된 값) 파일, 또는 고정 길이 필드로 구성된 텍스트 파일 등.
  - **동작:** 파일에서 한 줄씩 읽어와, 각 줄을 필드로 나누고(구분자 기반 또는 고정 길이 기반), 이 필드들을 사용자가 정의한 객체(예: `Customer`, `Product`)로 매핑합니다.
  - **주요 클래스:** `FlatFileItemReader`
  - **비유:** 엑셀 시트에서 한 행씩 읽어서 각 셀의 값을 가져오는 것과 유사합니다.
- **XML (`ItemReader`s):**
  - **대상:** XML 파일.
  - **동작:** XML 문서를 파싱하여 특정 태그나 요소들을 하나의 아이템 단위로 읽어옵니다. XSD 스키마를 사용한 유효성 검증도 지원할 수 있습니다.
  - **주요 클래스:** `StaxEventItemReader` (StAX API 기반)
  - **비유:** 복잡한 구조의 XML 문서에서 특정 주문 정보( `<order> ... </order>`) 덩어리만 쏙쏙 뽑아내는 것과 같습니다.
- **데이터베이스 (Database `ItemReader`s):**
  - **대상:** 관계형 데이터베이스 (RDBMS).
  - **동작:** SQL 쿼리를 실행하여 결과 집합(ResultSet)을 가져오고, 각 행(row)을 `RowMapper`를 사용해 자바 객체로 변환하여 아이템으로 제공합니다. 재시작 지원을 위해 현재 읽고 있는 행의 위치를 관리하고, 기본적인 통계 정보도 제공합니다.
  - **주요 클래스:** `JdbcCursorItemReader`, `JdbcPagingItemReader`, `JpaPagingItemReader`, `HibernateCursorItemReader` 등. (커서 방식과 페이징 방식이 있습니다.)
  - **비유:** 데이터베이스 테이블에서 SQL로 원하는 데이터를 조회한 후, 결과 테이블의 각 행을 하나의 데이터 객체로 변환하여 가져오는 것과 같습니다.
- **기타:** 이 외에도 JMS 큐에서 메시지를 읽는 `JmsItemReader`, MongoDB에서 데이터를 읽는 `MongoItemReader`, Neo4j에서 데이터를 읽는 `Neo4jItemReader` 등 다양한 구현체들이 존재합니다. (부록 A 참조)

---

### **주요 용어 해설**

- **플랫 파일 (Flat File):** 특별한 구조 없이 단순 텍스트로 이루어진 파일. 각 줄이 하나의 레코드를 나타내고, 필드들은 구분자나 고정된 위치로 구분됩니다. (예: CSV, TXT)
- **XSD (XML Schema Definition):** XML 문서의 구조와 데이터 타입을 정의하는 표준. XML 파일의 유효성을 검증하는 데 사용됩니다.
- **`RowMapper`:** 데이터베이스의 결과 집합(ResultSet)에서 한 행의 데이터를 가져와 자바 객체로 변환하는 역할을 하는 인터페이스입니다. (주로 JDBC 사용 시 등장)
- **전진 전용 (Forward Only):** 데이터를 한 방향으로만 순차적으로 읽어나가는 방식. 이전 데이터로 되돌아가지 않습니다.
- **트랜잭셔널 리소스 (Transactional Resource):** 트랜잭션의 ACID(원자성, 일관성, 고립성, 지속성) 속성을 지원하는 데이터 소스입니다. (예: 데이터베이스, JMS 큐)
- **`UnexpectedInputException`:** `ItemReader`가 처리할 수 없는, 예상치 못한 형식의 입력을 만났을 때 발생하는 예외.
- **`ParseException`:** 입력 데이터를 특정 도메인 객체로 변환(파싱)하는 과정에서 오류가 발생했을 때 던져지는 예외.
- **`NonTransientResourceException`:** 일시적이지 않은, 즉 재시도해도 해결되기 어려운 영구적인 리소스 문제 발생 시 던져지는 예외.

---

### **코드 예제 및 분석 (인터페이스 정의)**

```java
public interface ItemReader<T> { // <T>는 이 ItemReader가 반환할 아이템의 타입을 나타냅니다.

    // 이 메서드가 ItemReader의 핵심입니다.
    // 호출될 때마다 하나의 아이템을 읽어 반환하거나,
    // 더 이상 아이템이 없으면 null을 반환합니다.
    T read() throws Exception, // 일반적인 모든 예외를 포괄
                     UnexpectedInputException, // 예상치 못한 입력 형식 오류
                     ParseException,           // 데이터 파싱(변환) 오류
                     NonTransientResourceException; // 영구적인 리소스 오류 (예: 파일 없음)
}

```

- 이 인터페이스는 매우 단순합니다. 단 하나의 메서드 `read()`만을 가지고 있습니다.
- 이 단순함이 바로 `ItemReader`의 강력함입니다. 어떤 복잡한 데이터 소스라도 결국 "하나씩 읽어서 반환한다"는 이 단순한 계약만 지키면 Spring Batch의 청크 기반 처리 흐름에 통합될 수 있습니다.
- 개발자는 특정 데이터 소스에 맞는 `ItemReader` 구현체를 선택하거나 직접 만들고, Spring Batch는 이 `read()` 메서드를 반복적으로 호출하여 데이터를 가져옵니다. `read()`가 `null`을 반환할 때까지 이 과정이 반복됩니다.

---

### **"왜?" 라는 질문에 대한 답변**

- **왜 `read()` 메서드는 아이템이 없을 때 예외 대신 `null`을 반환할까?**
  - 데이터의 끝에 도달하는 것은 오류 상황이 아니라, 매우 일반적이고 예상된 흐름의 종료 조건이기 때문입니다. 예외는 예상치 못한 문제 상황을 처리하기 위한 메커니즘입니다. 만약 데이터의 끝을 예외로 처리한다면, 모든 배치 잡은 정상 종료 시 항상 "데이터 없음 예외"를 잡아서 처리해야 하는 불필요한 코드가 추가될 것입니다. `null` 반환은 이 흐름을 훨씬 깔끔하고 직관적으로 만듭니다.
- **왜 `ItemReader`는 일반적으로 "전진 전용(Forward Only)"인가?**
  - **효율성:** 대부분의 대용량 데이터 처리 시나리오에서는 데이터를 처음부터 끝까지 순차적으로 한 번만 읽는 것이 가장 효율적입니다. 데이터를 임의로 접근하거나 뒤로 돌아가는 기능은 추가적인 복잡성과 리소스 소모(예: 메모리에 모든 데이터를 올려놓거나, 인덱싱 필요)를 유발할 수 있습니다.
  - **스트리밍 처리:** `ItemReader`는 스트리밍 방식으로 데이터를 처리하는 데 적합합니다. 즉, 전체 데이터를 메모리에 로드하지 않고 필요한 만큼만 읽어서 처리하고 다음 데이터로 넘어갑니다. 이는 메모리 사용량을 최소화하고 대용량 파일을 처리할 수 있게 합니다. "전진 전용"은 이러한 스트리밍 모델과 잘 맞습니다.
  - **단순성:** 인터페이스 계약을 단순하게 유지하여 다양한 구현체를 만들기 쉽게 합니다.

---

### **주의사항 및 Best Practice**

1. **상태 관리 주의 (Stateful):** `ItemReader` 구현체는 내부적으로 현재 어디까지 읽었는지 상태를 유지해야 합니다 (예: 파일의 현재 라인 번호, 데이터베이스 커서의 위치). 따라서 스레드 환경에서 사용할 때는 상태가 올바르게 관리되도록 주의해야 합니다. `@StepScope`를 사용하여 각 스텝 실행마다 새로운 인스턴스를 갖도록 하는 것이 일반적인 해결책입니다.
2. **리소스 정리:** 만약 `ItemReader`가 파일 핸들이나 데이터베이스 커넥션과 같은 외부 리소스를 사용한다면, 해당 리소스가 적절한 시점에 해제되도록 보장해야 합니다. `ItemStream` 인터페이스를 함께 구현하여 `open()`, `close()` 메서드 내에서 리소스 초기화 및 정리를 수행하는 것이 좋습니다. (이 내용은 다음 챕터들에서 더 자세히 다뤄질 것입니다.)
3. **예외 처리의 명확성:** `read()` 메서드에서 발생하는 예외는 그 의미가 명확해야 합니다. 재시도 가능한 문제인지, 아니면 해당 아이템을 건너뛰어야 하는 문제인지, 혹은 전체 잡을 중단해야 하는 심각한 문제인지 구분하여 적절한 예외를 던져야 합니다. Spring Batch는 이러한 예외 유형에 따라 skip, retry 등의 정책을 적용할 수 있습니다.
4. **적절한 `ItemReader` 선택:** 처리하려는 데이터 소스의 특성(파일, DB, 메시지 큐 등)과 데이터의 양, 성능 요구사항 등을 고려하여 Spring Batch가 제공하는 다양한 `ItemReader` 구현체 중 가장 적합한 것을 선택해야 합니다. 예를 들어, 데이터베이스에서 매우 많은 양의 데이터를 읽을 때는 커서 기반보다는 페이징 기반의 `ItemReader`가 더 효율적일 수 있습니다.

---

### **이전 학습 내용과의 연관성**

- **`@StepScope` 및 지연 바인딩 (이전 챕터):** `ItemReader`는 종종 파일 경로와 같이 실행 시점에 결정되는 값을 필요로 합니다. 이전 챕터에서 배운 `@StepScope`와 `@Value` 어노테이션을 사용하여 `JobParameters`나 `ExecutionContext`로부터 이러한 값들을 주입받아 `ItemReader`를 설정하는 경우가 많습니다.
- **청크 기반 처리 (Spring Batch의 핵심 개념):** `ItemReader`는 청크 지향 처리(Chunk-Oriented Processing)의 첫 번째 단계입니다. 여기서 아이템을 하나씩 읽어 모으고, 정해진 청크 크기만큼 아이템이 모이면 `ItemProcessor`와 `ItemWriter`에게 전달됩니다.
- **`Job`과 `Step` (기본 구성 요소):** `ItemReader`는 `Step`을 구성하는 핵심 컴포넌트 중 하나입니다. `Step` 내에서 `reader()`, `processor()`, `writer()` 메서드를 통해 설정됩니다.

---
