---
title: Spring Batch - ItemWriter
description: 
author: laze
date: 2025-06-11 00:00:02 +0900
categories: [Dev, SpringBatch]
tags: [SpringBatch]
---
### ItemWriter

`ItemWriter`는 기능적으로 `ItemReader`와 유사하지만 반대의 작업을 수행합니다.

리소스는 여전히 위치를 찾고, 열고, 닫아야 하지만, 읽어들이는 대신 기록(write out)한다는 점에서 다릅니다.

데이터베이스나 큐의 경우, 이러한 작업은 삽입(inserts), 갱신(updates), 또는 전송(sends)일 수 있습니다.

출력물의 직렬화 형식은 각 배치 잡(job)에 따라 다릅니다.

`ItemReader`와 마찬가지로, `ItemWriter`는 다음 인터페이스 정의와 같이 상당히 일반적인 인터페이스입니다:

```java
public interface ItemWriter<T> {

    void write(Chunk<? extends T> items) throws Exception;

}
```

`ItemReader`의 `read`와 마찬가지로, `write`는 `ItemWriter`의 기본 계약을 제공합니다.

열려 있는 동안 전달된 아이템 목록을 기록하려고 시도합니다.

일반적으로 아이템들이 함께 '배치(batched)'되어 청크(chunk)로 만들어진 다음 출력될 것으로 예상되기 때문에, 인터페이스는 아이템 자체 대신 아이템 목록을 받습니다.

목록을 기록한 후, `write` 메서드에서 반환하기 전에 필요할 수 있는 모든 플러시(flushing) 작업을 수행할 수 있습니다.

예를 들어, Hibernate DAO에 기록하는 경우, 각 아이템에 대해 한 번씩 여러 번의 `write` 호출이 이루어질 수 있습니다.

그런 다음 라이터는 반환하기 전에 하이버네이트 세션에 대해 `flush`를 호출할 수 있습니다.

---

### **학습 목표 제시**

이번 "ItemWriter" 챕터를 통해 학생분은 다음을 이해하고 배울 수 있습니다:

1. **`ItemWriter`의 역할과 중요성 이해:** Spring Batch에서 처리된 데이터를 최종 목적지에 기록하는 `ItemWriter`의 기능과 배치 처리 흐름에서의 중요성을 파악합니다.
2. **`ItemWriter` 인터페이스의 핵심 계약 파악:** `ItemWriter` 인터페이스의 `write()` 메서드가 어떻게 동작하고, 어떤 파라미터를 받으며, 어떤 작업을 수행하는지 이해합니다. 특히, 단일 아이템이 아닌 아이템 목록(청크)을 처리하는 이유를 이해합니다.
3. **다양한 `ItemWriter` 구현 유형 및 고려사항 인지:** 일반적인 데이터 목적지(플랫 파일, XML, 데이터베이스 등)에 대한 `ItemWriter` 구현 유형들을 인지하고, 데이터 쓰기 작업 시 고려해야 할 사항(예: 플러시)을 간략하게 이해합니다.

---

### **핵심 개념 설명**

이 챕터의 핵심은 **"Spring Batch가 처리된 데이터를 다양한 목적지에 어떻게 기록하는가?"** 이며, 그 중심에는 `ItemWriter` 인터페이스가 있습니다.

### 1. `ItemWriter`란 무엇인가?

- **개념:** 말 그대로 "아이템(처리된 데이터)을 쓰는 녀석"입니다. `ItemReader`가 데이터를 읽어오는 시작점이라면, `ItemWriter`는 처리된 결과를 최종 목적지(파일, 데이터베이스, 메시징 큐 등)에 기록하는 종착점입니다.
- **비유:**
  - **보고서 작성자:** 분석된 정보(처리된 데이터)를 바탕으로 최종 보고서(출력)를 작성하는 사람.
  - **택배 포장 및 발송 직원:** 주문 처리된 상품(처리된 데이터)을 포장하여 고객(목적지)에게 발송하는 직원.
  - **공장의 최종 제품 포장 라인:** 완성된 제품(처리된 데이터)을 상자에 담아 출고 준비를 하는 과정.
- **중요성:**
  - **데이터 목적지의 추상화:** `ItemWriter` 인터페이스를 통해 개발자는 데이터가 저장될 구체적인 방식(파일 쓰기, DB 삽입 등)에 크게 신경 쓰지 않고 일관된 방식으로 데이터를 기록하는 로직을 작성할 수 있습니다. Spring Batch는 다양한 목적지를 위한 `ItemWriter` 구현체들을 제공합니다.
  - **청크 기반 처리의 마무리:** `ItemReader`와 `ItemProcessor`를 거쳐 모인 아이템들의 "청크(Chunk)"를 한 번에 받아 목적지에 기록합니다.
- **"왜 필요한가?"**:
  - 배치 처리의 결과물은 어딘가에 저장되거나 다른 시스템으로 전달되어야 의미가 있습니다. `ItemWriter`는 이러한 결과물을 안전하고 효율적으로 목적지에 전달하는 표준화된 방법을 제공합니다.
  - 다양한 출력 형식과 저장 매체를 지원하기 위해, 각 목적지에 맞는 쓰기 전략을 캡슐화한 컴포넌트가 필요합니다.

### 2. `ItemWriter` 인터페이스 살펴보기

```java
public interface ItemWriter<T> {

    void write(Chunk<? extends T> items) throws Exception;

}

```

- **`T` (제네릭 타입 파라미터):** `ItemWriter`가 기록할 아이템의 타입을 나타냅니다. 이 타입은 보통 `ItemProcessor`의 출력 타입과 일치하거나, `ItemProcessor`가 없다면 `ItemReader`의 아이템 타입과 일치합니다.
- **`write(Chunk<? extends T> items)` 메서드:**
  - **핵심 계약:** 이 인터페이스의 유일한 메서드입니다. `Chunk` 객체로 랩핑된 아이템들의 리스트를 인자로 받아서, 이 아이템들을 한 번에 목적지에 기록하려고 시도합니다.
  - **`Chunk<? extends T> items` 파라미터:**
    - `ItemReader`의 `read()`가 **단일 아이템**을 반환하는 것과 대조적으로, `ItemWriter`의 `write()`는 **아이템들의 리스트 (정확히는 `Chunk` 객체)**를 받습니다.
    - **"왜 리스트(청크)로 받을까?"**: 이것이 바로 Spring Batch의 **청크 지향 처리(Chunk-Oriented Processing)**의 핵심입니다. 여러 아이템을 모아서 한 번의 쓰기 작업(또는 한 트랜잭션 내의 여러 쓰기 작업)으로 처리하는 것이, 아이템 하나하나를 개별적으로 쓰는 것보다 훨씬 효율적이기 때문입니다 (특히 데이터베이스 I/O나 파일 I/O에서). 네트워크 오버헤드나 디스크 접근 횟수를 줄일 수 있습니다.
    - `Chunk`는 내부적으로 `List<? extends T>`를 가지고 있습니다. `? extends T`는 `T` 타입 또는 `T`를 상속받은 모든 하위 타입의 아이템들을 이 청크에 포함할 수 있다는 의미입니다.
  - **반환 값:** `void`입니다. `write()` 메서드는 성공적으로 작업을 마치면 아무것도 반환하지 않습니다. 문제가 발생하면 예외를 던집니다.
  - **예외 (Exceptions):**
    - `Exception`: 쓰기 작업 중 발생할 수 있는 모든 일반적인 예외를 포괄합니다. (예: 파일 쓰기 권한 없음, 데이터베이스 연결 오류, 데이터 형식 제약 조건 위반 등)
- **리소스 관리:** `ItemReader`와 마찬가지로, `ItemWriter`도 파일 핸들이나 데이터베이스 연결과 같은 외부 리소스를 사용할 수 있습니다. 이러한 리소스는 적절한 시점에 열리고(opened), 사용 후에는 닫혀야(closed) 합니다. `ItemStream` 인터페이스를 함께 구현하여 `open()`과 `close()`에서 이러한 관리를 수행하는 것이 일반적입니다.
- **플러시 (Flushing):**
  - `write()` 메서드는 전달받은 아이템 목록을 기록한 후, 필요한 경우 내부 버퍼에 있는 데이터를 실제 목적지로 완전히 내보내는 **플러시(flush)** 작업을 수행할 수 있습니다.
  - 예를 들어, Hibernate를 사용하여 데이터베이스에 여러 아이템을 저장하는 경우, 각 아이템에 대해 `save()` 또는 `persist()`를 호출한 후, `write()` 메서드가 반환하기 전에 Hibernate 세션의 `flush()`를 호출하여 변경사항을 데이터베이스에 실제 반영할 수 있습니다. 파일에 쓸 때도 내부 버퍼를 비우는 플러시 작업이 필요할 수 있습니다.

### 3. 일반적인 `ItemWriter` 구현 유형

`ItemReader`와 유사하게, 다양한 목적지에 데이터를 쓰기 위한 `ItemWriter` 구현체들이 있습니다.

- **플랫 파일 (Flat File `ItemWriter`s):**
  - **목적지:** CSV, TSV, 고정 길이 텍스트 파일 등.
  - **동작:** 처리된 객체들을 특정 형식(예: 쉼표로 구분된 문자열)으로 변환하여 파일에 한 줄씩 기록합니다.
  - **주요 클래스:** `FlatFileItemWriter`
- **XML (`ItemWriter`s):**
  - **목적지:** XML 파일.
  - **동작:** 처리된 객체들을 XML 구조에 맞게 마샬링(marshalling)하여 파일에 기록합니다.
  - **주요 클래스:** `StaxEventItemWriter`
- **데이터베이스 (Database `ItemWriter`s):**
  - **목적지:** 관계형 데이터베이스 (RDBMS).
  - **동작:** 처리된 객체들을 데이터베이스 테이블에 삽입(insert), 갱신(update), 또는 삭제(delete)합니다. JDBC나 JPA, Hibernate 등 다양한 기술을 기반으로 한 구현체들이 있습니다.
  - **주요 클래스:** `JdbcBatchItemWriter` (JDBC 일괄 업데이트), `JpaItemWriter` (JPA 사용), `HibernateItemWriter` (Hibernate 사용)
- **기타:** JMS 큐로 메시지를 전송하는 `JmsItemWriter`, MongoDB에 데이터를 쓰는 `MongoItemWriter`, Elasticsearch에 데이터를 인덱싱하는 `ElasticsearchItemWriter` 등 다양한 구현체들이 존재합니다.

---

### **주요 용어 해설**

- **청크 (Chunk):** `ItemReader`가 읽고 `ItemProcessor`가 처리한 아이템들을 일정 개수만큼 묶은 단위. `ItemWriter`는 이 청크 단위로 데이터를 받아 처리합니다.
- **플러시 (Flush):** 버퍼에 임시로 저장되어 있던 데이터를 실제 물리적인 저장소(파일, 데이터베이스 등)로 완전히 내보내는 작업입니다. 데이터 유실을 방지하고 일관성을 유지하기 위해 필요합니다.
- **직렬화 (Serialization):** 객체를 파일에 저장하거나 네트워크로 전송하기 쉬운 형태로 변환하는 과정. `ItemWriter`는 객체를 특정 형식(텍스트, XML, JSON 등)으로 직렬화하여 출력합니다.
- **마샬링 (Marshalling):** 객체를 XML 문서 형태로 변환하는 과정. XML `ItemWriter`에서 사용됩니다. (반대는 언마샬링 - XML을 객체로 변환)
- **DAO (Data Access Object):** 데이터베이스와 같은 영속성 저장소에 접근하는 로직을 캡슐화한 객체.

---

### **코드 예제 및 분석 (인터페이스 정의)**

```java
public interface ItemWriter<T> { // <T>는 이 ItemWriter가 처리할 아이템의 타입을 나타냅니다.

    // 이 메서드가 ItemWriter의 핵심입니다.
    // 청크 단위로 묶인 아이템 리스트(items)를 받아,
    // 이 아이템들을 목적지에 기록(write)합니다.
    void write(Chunk<? extends T> items) throws Exception;
    // Chunk<? extends T> items:
    //    - Chunk: 아이템들의 묶음을 나타내는 Spring Batch의 객체. 내부적으로 List를 가짐.
    //    - ? extends T: T 타입이거나 T를 상속받은 모든 타입의 아이템을 처리할 수 있음을 의미.
    // throws Exception: 쓰기 작업 중 발생할 수 있는 모든 예외.
}

```

- `ItemReader`와 마찬가지로 인터페이스 자체는 매우 단순합니다. 단 하나의 `write()` 메서드만 정의되어 있습니다.
- `read()`는 아이템을 *하나씩* 반환하지만, `write()`는 아이템 *묶음(청크)*을 받는다는 점이 가장 큰 차이점입니다.
- 이 인터페이스를 구현하는 클래스는 `items` 파라미터로 받은 `Chunk` 내의 모든 아이템들을 특정 로직에 따라 파일, 데이터베이스 등에 저장하는 코드를 `write()` 메서드 내에 작성해야 합니다.

---

### **"왜?" 라는 질문에 대한 답변**

- **왜 `ItemWriter`는 단일 아이템이 아니라 `Chunk` (아이템 리스트)를 받을까?**
  - **성능 최적화:** 앞서 언급했듯이, 여러 아이템을 모아 한 번에 처리하는 것이 I/O 작업(디스크 접근, 네트워크 통신)의 오버헤드를 줄여 훨씬 효율적입니다. 데이터베이스에 데이터를 삽입할 때, INSERT 문을 100번 실행하는 것보다, 100개의 데이터를 모아 배치(batch) INSERT를 한 번 실행하는 것이 성능상 유리합니다. 파일에 쓸 때도 여러 줄을 모아 한 번에 쓰는 것이 더 빠릅니다.
  - **트랜잭션 관리 용이성:** 청크 단위로 작업을 묶으면, 해당 청크 전체의 성공 또는 실패를 하나의 트랜잭션으로 관리하기 용이합니다. 만약 청크 내의 아이템 중 하나라도 쓰기 작업에 실패하면, 해당 청크 전체의 작업을 롤백할 수 있습니다. (Spring Batch의 기본 트랜잭션 전략)
- **`write()` 메서드에서 플러시(flush)는 왜 중요할까?**
  - 많은 I/O 작업은 성능 향상을 위해 내부적으로 버퍼(buffer)를 사용합니다. 데이터를 쓸 때 즉시 물리적인 저장소에 쓰는 것이 아니라, 일단 버퍼에 모아두었다가 버퍼가 차거나 특정 조건이 되면 한꺼번에 내보냅니다.
  - `write()` 메서드가 단순히 버퍼에만 데이터를 쓰고 반환하면, 실제로는 데이터가 아직 저장되지 않은 상태일 수 있습니다. 만약 이때 시스템에 문제가 생기면 데이터가 유실될 수 있습니다.
  - 따라서 `write()` 메서드 내에서 (또는 트랜잭션 커밋 직전에) 명시적으로 플러시를 호출하여 버퍼의 내용을 실제 저장소로 보내는 것이 데이터의 안전한 저장을 보장하는 데 중요합니다. Spring Batch 프레임워크는 트랜잭션 관리와 함께 이러한 플러시 시점을 적절히 제어해줍니다.

---

### **주의사항 및 Best Practice**

1. **상태 관리 및 스레드 안전성:** `ItemWriter`도 상태를 가질 수 있습니다 (예: 현재 열려있는 파일 핸들러). 멀티스레드 환경이나 병렬 처리 시에는 스레드 안전성을 고려해야 합니다. 일반적으로 `@StepScope`를 사용하여 각 스텝(또는 스레드별 스텝)마다 독립적인 인스턴스를 사용하도록 합니다.
2. **리소스 관리의 중요성:** `ItemStream` 인터페이스를 함께 구현하여 `open()`, `update()`, `close()` 메서드에서 리소스(파일, DB 커넥션 등)를 올바르게 열고 닫아야 합니다. 특히 `close()`에서 리소스를 확실히 해제하지 않으면 리소스 누수(leak)가 발생할 수 있습니다.
3. **예외 처리 전략:** `write()` 메서드에서 예외가 발생했을 때, 해당 청크 전체를 실패로 처리할지, 아니면 문제가 된 아이템만 건너뛰고 나머지는 계속 처리할지(skip) 등을 결정해야 합니다. Spring Batch는 이러한 예외 처리 전략을 설정할 수 있는 기능을 제공합니다.
4. **성능 고려:**
  - **배치(Batch) 작업 활용:** 데이터베이스에 쓸 때는 JDBC의 배치 업데이트 기능을 활용하는 `JdbcBatchItemWriter` 등을 사용하여 성능을 향상시키세요.
  - **버퍼 크기 조절:** 파일에 쓸 때 적절한 버퍼 크기를 설정하면 I/O 성능에 영향을 줄 수 있습니다.
  - **비동기 `ItemWriter` (AsyncItemWriter):** I/O 작업이 매우 오래 걸리는 경우, `AsyncItemWriter` (Spring Batch Extensions 제공) 등을 고려하여 쓰기 작업을 비동기적으로 처리함으로써 전체 처리 시간을 단축시킬 수도 있습니다. (고급 주제)
5. **적절한 `ItemWriter` 선택:** `ItemReader`와 마찬가지로, 데이터를 기록할 목적지의 특성과 성능 요구사항을 고려하여 가장 적합한 `ItemWriter` 구현체를 선택해야 합니다.

---

### **이전 학습 내용과의 연관성**

- **`ItemReader`:** `ItemWriter`는 `ItemReader`가 읽어온 (그리고 선택적으로 `ItemProcessor`가 가공한) 데이터를 최종적으로 처리하는 역할을 합니다. 이 둘은 청크 기반 처리의 시작과 끝을 담당합니다.
- **`ItemProcessor` (다음 챕터에서 배울 수 있음):** `ItemReader`가 읽은 데이터를 `ItemWriter`가 쓰기 전에 변환하거나 필터링하는 중간 처리 단계입니다. `ItemProcessor`의 결과물이 `ItemWriter`의 입력이 됩니다.
- **청크 지향 처리:** `ItemWriter`는 청크 단위로 아이템을 받아 처리함으로써 이 패러다임의 핵심적인 부분을 담당합니다. `commit-interval` (청크 크기) 설정이 `ItemWriter`의 `write()` 메서드가 한 번에 처리하는 아이템의 양을 결정합니다.
- **`@StepScope` 및 지연 바인딩:** `ItemWriter`도 출력 파일 경로 등 실행 시점에 결정되는 값을 필요로 할 수 있습니다. 이때 `@StepScope`와 SpEL을 사용하여 `JobParameters` 등으로부터 값을 주입받을 수 있습니다.

---
