---
title: Backend 기초 지식
description: Backend 기초 지식
author: laze
date: 2025-06-22 00:00:05 +0900
categories: [Dev, Backend]
tags: [Backend]
---
### Index

Part1. 처음 만나는 백엔드

- Chaper 1 백엔드 시작하기
  - 웹 개발의 구조


    - 프론트엔드 개발
        
        사용자가 보는 화면 (User Interface) 개발
        
    - 백엔드 개발
        
        사용자가 보지 못하는 영역 서버와 데이터베이스를 관리하는 일
        
        사용자가 요청한 작업을 처리할 수 있도록 웹 애플리케이션의 내부 기능 개발
        
    - 프론트엔드와 백엔드를 구분하는 이유
        - 프론트엔드 : 더 나은 사용자 경험을 제공하고 최신 상태의 데이터를 제공하는 일에 집중
        - 백엔드 : 대규모 데이터와 트래픽을 처리하는 서버 개발 및 운영에 집중
        - UX : 사용자가 웹 애플리케이션을 사용하는 동안 느끼는 전반적인 만족도와 편의성
    - 서버의 동작원리
        - 클라이언트-서버 모델
            
            Server - 제공하는 측
            
            - 웹 서버 : 클라이언트와 웹 애플리케이션 서버 사이에서 클라이언트의 요청을 받고 응답
            정적인 콘텐츠는 그대로 클라이언트에 제공, 동적인 요청은 웹 애플리케이션 서버에 요청
            - 웹 애플리케이션 서버 : 웹 서버를 통해 들어온 요청에 맞게 데이터를 추출 및 가공해 결과를 웹 서버에 반환
            
            Client - 요청 → 서버의 응답을 받음
            
    - 웹 애플리케이션의 동작 원리
        1. 클라이언트 → 웹 서버 데이터 요청
        2. 웹 서버는 웹 애플리케이션 서버에 클라이언트의 요청 사항 전달
        3. 웹 애플리케이션 서버는 미리 작성해둔 코드에 따라 데이터베이스에서 데이터를 생성,조회,수정,삭제 하는 작업
        4. 데이터베이스는 작업에 따른 데이터의 상태를 항상 최신으로 유지
        5. 웹 애플리케이션 서버는 데이터를 처리한 후 결과를 웹 서버에 전달
        6. 웹 서버는 결과 데이터를 클라이언트에 반환
        7. 클라이언트는 반환 받은 데이터를 화면에서 확인
        - 클라이언트 - 웹 브라우저
        - 웹 서버 - 아파치, 엔진엑스, IIS
        - 웹 애플리케이션 서버 - 아파치 톰캣, 제이보스, IBM 웹스피어, 오라클 웹로직
        - DBMS - MySQL, 오라클, 몽고DB
    - 백엔드 개발자가 하는 일
        - 서버 개발
            - 클라이언트 요청 접수 → 처리 → 적절한 응답
        - 데이터베이스 설계 및 관리
            - 데이터를 효율적으로 저장하고 관리하기 위한 DB설계 및 관리
            - 성능과 확장성을 고려한 데이터 모델 설계 및 운영
        - API 개발
            - 프론트엔드와 백엔드가 데이터를 효율적으로 주고받을 수 있는 인터페이스
            - 다른 서비스나 플랫폼과 통합할 때도 중요한 역할
        - 보안 및 인프라 관리
            - 외부 공격으로부터 서버와 데이터를 지키기 위해 보안 정책 수립, 관련 기술 적용
            - 서버 구성 및 모니터링 등의 인프라 관리 업무 (서버 장비, 스토리지, 미들웨어, 운영체제)
        - 네트워크 설정
            - 네트워크 설정을 통해 서버와 클라이언트 간의 효율적인 통신을 보장
            - 로드 밸런싱(작업 부하 분산), 캐싱(자주 사용하는 데이터 복사본 고속 저장소에 저장), 네트워크 보안 설정
    - 백엔드 로드맵 소개
        - CS 기초 지식 ( 네트워크, 운영체제, 데이터베이스, 자료구조 )
        - 백엔드 개발 언어 & 프레임워크
        - DBMS
        - API  개발
        - 버전관리 시스템
        - 클라우드 컴퓨팅
        - 가상화 & 컨테이너
        - 웹 애플리케이션 아키텍처
        - 테스트 & CI/CD
        - 총 정리

Part2 백엔드 로드맵 따라가기

- Chapter02 CS기초 지식
  - 네트워크
    - IP주소

      네트워크에 연결된 각 컴퓨터를 구분하는 유일한 주소

      IPv4 ⇒ 4바이트 주소 체계

      IPv6 ⇒ 16바이트 주소 체계

    - 도메인 네임

      사용자가 쉽게 기억할 수 있도록 IP 주소를 문자열로 변환

    - DNS

      도메인과 IP 주소의 매핑 정보를 가지고 있는 시스템

      사용자 웹 주소 입력 ⇒ DNS 서버 ⇒ 매핑된 IP 주소 반환

      일반 사용자는 DNS를 따로 설정하지 않고 ISP(Internet Service Provider)가 제공하는 정보를 받아서 사용

      DNS 서버의 계층 구조

      [www.google.com](http://www.google.com)(.) 에서 (마지막은 생략됨)

      - . 루트 도메인
      - com 최상위 레벨 도메인
      - google 2 레벨 도메인
      - www 3 레벨 도메인
      - 각 계층마다 해당 도메인을 관리하는 DNS 서버가 있음
      - 상위 계층 DNS > 하위 계층 DNS 정보 관리
      - 하위 계층 DNS > 서버의 IP 주소 관리m
    - 포트와 포트 번호

      IP 주소로 특정 컴퓨터에 요청을 보낼 때 주소만 갖고 어떤 프로그램인지 어떻게 찾는가?

      포트를 이용해 프로그램을 구분 할 수 있음

      대표적인 포트

      - HTTP - 80
      - HTTPS - 443
      - SSH(외부 접속 서비스) - 22
      - DNS - 53
      - FTP - 20, 21
      - SMTP(메일 전송 서비스) - 25
    - 프로토콜

      상대방의 요청과 응답을 이해할 수 있도록 네트워크 통신에서 정해놓은 규칙과 절차

      TCP, IP, HHTP, HTTPS 등

      - TCP(Transmission Control Protocol) & IP(Internet Protocol)
        - 데이터를 패킷이라는 작은 단위로 나눠서 전송
        - IP는 목적지 주소 ⇒ 순서가 안맞거나 중간에 유실될 수 있음
        - TCP는 이런 문제를 해결하기 위한 신뢰성 있는 프로토콜
          - 패킷 순서에 맞게 정렬, 유실된 패킷은 다시 보내달라 요청
        - (송신 측)HTTPS(4 : 응용 계층) ⇒ TCP(3 : 전송계층) ⇒ IP(2 : 인터넷 계층) ⇒ 이더넷(1 : 네트워크 계층) ⇒ 이더넷 ⇒ IP ⇒ TCP ⇒ HTTPS (수신측)
      - HTTP
        - 인터넷에서 클라이언트와 서버 간에 데이터를 주고 받기 위해 사용하는 프로토콜
        - HTTP로 처리한 데이터를 TCP와 IP를 거쳐 인터넷 통신망으로 전송
        - HTTP 요청 ↔ HTTP 응답 ⇒ HTTP message
          - start line, header, empty line, body 로 구성됨
            - start line - 요청 혹은 응답 관련 주요 정보
              - 요청
                - HTTP 메서드(GET, POST)
                - 요청 URI(Uniform Resource Identifier) - 웹 상의 고유한 자원 식별하는 통합 자원 식별자
                - HTTP 버전 정보
              - 응답
                - HTTP 버전 정보
                - 상태코드
                  - 1XX - 정보를 제공하는 응답
                  - 2XX - 요청을 성공적으로 처리
                  - 3XX - Redirection 응답
                  - 4XX - 클라이언트 에러 응답
                  - 5XX - 서버 에러 응답
                - 상태 메시지
                  - 상태 코드에 대한 해설 제공
            - header - 요청 혹은 응답 관련 부가 정보
            - empty line - 헤더의 끝을 표시하기 위한 빈 행
            - body - 통신을 통해 실제로 주고 받는 데이터
      - HTTPS
        - 보안 요소가 강화된 HTTP 프로토콜 (데이터를 암호화)
        - SSL(Secure Socket Layer) / TLS(Transport Layer Security) 프로토콜 사용
    - 네트워크 정리
      1. **내부 IP (Private IP) vs. 외부 IP (Public IP)**
        - **내부 IP:** 공유기(라우터)와 같은 장비에 의해 할당되는 **로컬 네트워크 안에서만 사용되는 IP 주소**입니다. (예: 192.168.x.x, 10.x.x.x) 인터넷상에서는 직접 접근할 수 없습니다. 집 안의 여러 기기가 같은 외부 IP를 공유할 때 각 기기를 구분하기 위해 사용됩니다.
        - **외부 IP:** 인터넷 서비스 제공자(ISP)가 할당하는 **인터넷 상에서 유일하게 식별되는 IP 주소**입니다. 전 세계 어디서든 이 주소로 접근할 수 있습니다. 보통 공유기가 이 외부 IP를 할당받습니다.
      2. **유동 IP (Dynamic IP) vs. 고정 IP (Static IP)**
        - **유동 IP:** 기기가 네트워크에 접속할 때마다 (또는 일정 시간마다) **새롭게 할당받는 IP 주소**입니다. DHCP 서버가 주로 관리하며, 일반 가정집 인터넷 사용자들이 주로 사용합니다. IP 자원을 효율적으로 관리할 수 있습니다.
        - **고정 IP:** 한 번 할당받으면 **변경되지 않고 계속 사용하는 IP 주소**입니다. 웹 서버, 메일 서버 등 외부에서 항상 동일한 주소로 접근해야 하는 서비스에 필요합니다. 보통 추가 비용이 발생합니다.
      3. **DNS (Domain Name System) vs. hosts 파일**
        - **DNS:** google.com과 같은 **사람이 읽기 쉬운 도메인 이름**을 컴퓨터가 이해하는 **IP 주소로 변환**해주는 **인터넷 전화번호부** 같은 분산 시스템입니다. 전 세계적인 규모로 작동합니다.
        - **hosts 파일:** **내 컴퓨터에 저장된** 작은 텍스트 파일로, 특정 도메인 이름과 IP 주소를 **수동으로 매핑**해 놓은 목록입니다. 운영체제는 DNS 서버에 묻기 전에 이 파일을 먼저 확인합니다. 개발/테스트 목적으로 특정 도메인 요청을 로컬이나 다른 서버로 보내고 싶을 때 사용합니다.
      4. **레지스트리 (Registry) vs. 레지스트라 (Registrar)** (도메인 관련)
        - **레지스트리:** .com, .kr 등 **최상위 도메인(TLD)에 대한 정보를 총괄 관리하는 기관 또는 데이터베이스**입니다. 어떤 도메인이 등록되었는지, 어떤 네임서버를 사용하는지 등의 공식 기록을 유지합니다. (예: Verisign은 .com 레지스트리)
        - **레지스트라:** **일반 사용자나 기업에게 도메인 등록 서비스를 제공하는 회사**입니다. 레지스트리로부터 인증받아 도메인 판매, 정보 변경 등을 대행합니다. (예: 가비아, GoDaddy, Google Domains) 사용자는 레지스트라를 통해 도메인을 구매/관리합니다.
      5. **Well-known Port vs. Registered Port vs. Dynamic Port**
        - **Well-known Ports (0 ~ 1023):** **매우 잘 알려진 특정 서비스들을 위해 예약된 포트 번호**입니다. IANA(국제 인터넷 주소 관리 기구)에서 관리하며, 변경하기 어렵습니다. (예: HTTP-80, HTTPS-443, FTP-21, SSH-22)
        - **Registered Ports (1024 ~ 49151):** **특정 응용 프로그램이나 서비스를 위해 등록된 포트 번호**입니다. 충돌을 피하기 위해 IANA에 등록하여 사용하지만, Well-known 포트만큼 강제성은 없습니다. (예: MySQL-3306, PostgreSQL-5432, Tomcat HTTP-8080)
        - **Dynamic/Private Ports (49152 ~ 65535):** **클라이언트가 서버에 접속할 때 임시로 사용하는 포트 번호 (Ephemeral Port)** 또는 사용자가 임의의 서버 프로그램을 위해 자유롭게 사용할 수 있는 영역입니다.
      6. **포트 포워딩 (Port Forwarding)**
        - 공유기(라우터)의 기능 중 하나로, **외부 IP 주소의 특정 포트로 들어오는 요청**을 내부 네트워크의 특정 기기(내부 IP)의 특정 포트로 전달(포워딩)해주는 설정입니다. 이를 통해 외부 인터넷에서 내부 네트워크에 있는 서버(웹 서버, 게임 서버 등)에 접근할 수 있게 됩니다. (예: 외부 IP:포트 80 요청 -> 내부 IP 192.168.0.10:포트 8080으로 전달)
      7. **OSI 7계층 (OSI 7 Layers) vs. TCP/IP 4계층 (TCP/IP 4 Layers)**
        - **OSI 7계층:** 네트워크 통신 과정을 **7개의 논리적인 단계(계층)** 로 나눈 **개념적인 참조 모델**입니다. (물리-데이터링크-네트워크-전송-세션-표현-응용) 각 계층은 특정 기능을 수행하며, 표준화와 학습에 유용합니다.
        - **TCP/IP 4계층:** 현재 **인터넷에서 실제로 사용되는 프로토콜들의 구조**를 더 단순하게 **4개의 계층**으로 표현한 모델입니다. (네트워크 인터페이스/링크 - 인터넷 - 전송 - 응용) OSI 모델보다 실용적이며, 실제 구현에 가깝습니다. OSI의 여러 계층이 TCP/IP의 한 계층에 묶이기도 합니다. (예: OSI 세션, 표현, 응용 계층 -> TCP/IP 응용 계층)
  - 운영체제

    컴퓨터 ↔ 사용자 사이의 인터페이스 제공

    컴퓨터 자원을 효율적으로 관리 & 분배 하는 역할

    - 프로세스와 스레드
      - 프로세스 : 현재 실행 중인 프로그램 ( 한 프로그램이 여러 프로세스를 가질 수 있음 )
        - 코드, 데이터, 힙, 스택 영역을 갖고있음
      - 스레드 : 프로세스 내에서 작업을 처리하는 실행 단위
        - 프로세스의 스택 영역 나눠갖고 나머지 코드, 데이터, 힙영역 공유
        - 하나의 프로세스를 둘 이상의 스레드로 → 멀티쓰레드
    - 콘텍스트 스위칭

      cpu 코어 수보다 더 많은 작업이 실행되면 각 코어는 정해진 시간 동안 여러 작업을 번갈아가며 수행

      실행 중인 작업을 교체하는 것을 컨텍스트 스위칭이라 함

      프로세스나 스레드가 번갈아가며 CPU를 할당받아 사용

    - 공유 자원과 동기화 문제

      공유 자원 → 스레드는 힙영역 말고는 공유해서 한 프로세스에서 사용하는데

      두 스레드가 하나의 자원에 동시에 접근하는 경우 → 경쟁 조건(race condition)

      이런 문제가 발생할 수 있는 부분을 임계 영역(critical section)이라 함

      임계 영역에서 문제가 일어나지 않기 위해서

      - 상호 배제(mutual exclusive) - 하나의 스레드가 임계영역에 있으면 다른 스레드 접근 못함
      - 진행(progess) - 임계 영역에서 실행중인 스레드가 없을때만 다른 스레드가 임계영역에 들어감
      - 한정 대기(bounded waiting) - 무한히 기다리지않고 유한한 시간이 지나면 들어갈 수 있음
      - **상호 배제**는 **점유 중**일 때의 규칙 (다른 스레드 접근 금지)
      - **진행**은 **비어 있고 경쟁 중**일 때의 규칙 (결국 누군가는 진입 보
    - 운영체제 정리
      1. **뮤텍스 (Mutex - Mutual Exclusion)**
        - 임계 영역(Critical Section) 접근을 제어하는 동기화 도구입니다.
        - 오직 **하나의 스레드**만 뮤텍스를 획득(lock)하고 임계 영역에 들어갈 수 있습니다.
        - 사용 후에는 반드시 반납(unlock)해야 다른 스레드가 획득할 수 있습니다. (화장실 열쇠 하나와 비슷)
      2. **세마포어 (Semaphore)**
        - 공유 자원에 **동시에 접근할 수 있는 스레드의 수**를 제어하는 동기화 도구입니다.
        - 정수 값(카운터)을 가지며, wait 연산으로 자원을 획득(카운터 감소, 0 이하면 대기), signal 연산으로 자원을 반납(카운터 증가)합니다.
        - 카운터가 1인 세마포어(이진 세마포어)는 뮤텍스와 유사하게 동작할 수 있습니다. (여러 개의 화장실 열쇠와 비슷)
      3. **데드록 (Deadlock - 교착 상태)**
        - **두 개 이상의 프로세스(또는 스레드)가 서로 상대방이 가진 자원을 기다리며 무한정 대기**하는 상태입니다.
        - 결과적으로 아무 작업도 진행되지 못하고 시스템이 멈추게 됩니다. (예: 스레드 A는 자원 X를 갖고 Y를 기다리고, 스레드 B는 자원 Y를 갖고 X를 기다리는 상황)
      4. **기아 현상 (Starvation)**
        - 특정 프로세스(또는 스레드)가 **자원을 계속 할당받지 못해서 영원히 기다리게 되는 상태**입니다.
        - 시스템은 다른 작업들을 처리하며 돌아가고 있지만, 해당 프로세스는 작업을 전혀 진행하지 못합니다. (예: 우선순위가 너무 낮거나, 계속해서 락 획득 경쟁에서 밀리는 경우)
        - 데드록과 달리 시스템 전체가 멈춘 것은 아닙니다.
      5. **식사하는 철학자 문제 (Dining Philosophers Problem)**
        - **데드록과 기아 현상을 설명하기 위한 유명한 동시성 문제**입니다.
        - 원탁에 앉은 철학자들이 식사를 하려면 양쪽의 젓가락(자원) 두 개가 모두 필요한 상황을 가정합니다.
        - 잘못된 자원 할당 전략은 모든 철학자가 왼쪽 젓가락만 들고 오른쪽 젓가락을 영원히 기다리는 데드록을 유발할 수 있습니다.
      6. **CPU 스케줄링 알고리즘:**
        - **FCFS (First-Come, First-Served):**
          - **가장 먼저 도착한 프로세스**부터 순서대로 CPU를 할당하는 **비선점형** 방식입니다.
          - 구현이 간단하지만, 긴 작업 뒤의 짧은 작업이 오래 기다릴 수 있습니다 (Convoy Effect).
        - **SJF (Shortest Job First):**
          - **CPU 실행 시간이 가장 짧을 것으로 예상되는 프로세스**를 먼저 실행하는 방식입니다. (주로 비선점형)
          - 평균 대기 시간을 최소화하지만, 실행 시간 예측이 어렵고 긴 작업의 기아 현상이 발생할 수 있습니다.
        - **SRF (Shortest Remaining Time First) / SRTF:**
          - **SJF의 선점형 버전**입니다. 현재 실행 중인 프로세스의 남은 시간보다 더 짧은 실행 시간의 프로세스가 도착하면 CPU를 빼앗아 그 프로세스를 실행합니다.
          - 평균 대기 시간을 더 줄일 수 있으나, 잦은 선점(컨텍스트 스위칭)으로 오버헤드가 발생할 수 있습니다.
        - **RR (Round Robin):**
          - *모든 프로세스에게 동일한 시간 할당량(Time Quantum)을 부여하고, 시간이 다 되면 다음 프로세스로 전환하는 **선점형** 방식입니다.
          - 시분할 시스템에 적합하며 응답 시간이 빠르지만, 시간 할당량 크기에 따라 성능이 좌우됩니다.
  - 데이터베이스
    - 데이터베이스와 DBMS
      - 데이터를 파일시스템으로 관리하다가 관리 비용이 늘어남에 따라 데이터베이스가 만들어짐
      - 만들어진 데이터베이스를 관리하는 DataBase Management System이 만들어짐
    - 데이터 저장 방식
      - Entity : 데이터베이스에서 표현하려는 유﹒무형의 객체
      - Attribute : Entity의 성질을 나타내는 구성요소
      - Relation(Table) : 데이터를 저장하는 기본 단위 회원 Entity ⇒ 회원 Relation으로 관리
      - Tuple : Table에 쌓이는 행의 단위
      - Domain : 릴레이션 내 각 속성이 가질 수 있는 값의 집함 (나이 0~999)
      - Key : 테이블 ↔ 속성 간의 관계를 명확히 하기위해 지정된 특별한 속성
        - PK : 유일성과 최소성을 충족하는 키
        - FK : 다른 테이블의 기본키를 참조하는 키 → 두 테이블간의 관계 나타냄
    - 데이터베이스 설계
      - 요구사항 분석
        - 쇼핑몰 사이트 회원 기능 → 회원 번호, 이메일, 비밀번호, 이름, 나이 가 필요함을 분석
      - 개념적 설계
        - 엔티티와 속성 추출(명사 추출)
          - 서비스의 요구사항으로 필요한 엔티티(회원) 및 속성(번호,나이 등) 추출
        - 관계 추출(동사 추출)
          - 회원 ↔ 주문 ↔ 상품 에서 주문이라는 관계로 회원과 상품이 연결됨
      - 논리적 설계
        - 위에서 만든 관계(ERD)를 바탕으로 속성의 Domain, 제약조건 결정
      - 물리적 설계
        - 개념적 설계와 논리적 설계로 구성한 DB 구조를 실제 물리적 저장장치에 담을 수 있도록
          데이터의 저장방식, 접근 경로, 탐색 기법 설계
    - 데이터베이스 정규화
      - 이상현상(anomaly)
        - 삽입 이상 - 새로운 데이터가 불필요한 데이터와 함께 삽입
        - 갱신 이상 - 중복된 데이터 값중 일부 값만 변경함으로써 데이터 불일치
        - 삭제 이상 - 특정 데이터 삭제시 다른 데이터까지 삭제되는 현상
      - 정규화 → 이상현상 방지 + 저장 공간 효율적으로 사용을 위함
      - 정규화 방법

        **제1정규화 (1NF: First Normal Form)**

        - **조건:** 테이블의 모든 컬럼(속성) 값이 원자값(Atomic Value)을 가져야 합니다. 즉, 하나의 컬럼에 여러 값이 들어가거나, 반복되는 그룹이 있어서는 안 됩니다. 모든 행은 고유 식별자(기본 키)를 통해 구분될 수 있어야 합니다.
        - **목표:** 데이터의 구조를 단순화하고 각 속성 값을 명확히 합니다.
        - **예시 (비정규형 -> 1NF):**
          - **Before:** 학생 테이블에 `수강과목` 컬럼이 있고, 한 학생이 여러 과목을 수강할 경우 `'자료구조, 운영체제, 네트워크'` 처럼 한 셀에 여러 값이 들어감.
          - **After:** `수강과목` 컬럼을 분리하여 각 행에는 하나의 과목만 오도록 하거나, 별도의 `수강` 테이블(`학생ID`, `과목명`)을 만듭니다.

        | 학생ID | 이름 | 수강과목 |
                        | --- | --- | --- |
        | 101 | 홍길동 | 자료구조, 운영체제, 네트워크 |

        ⬇️ (1NF 만족)

        | 학생ID | 이름 | 수강과목 |
                        | --- | --- | --- |
        | 101 | 홍길동 | 자료구조 |
        | 101 | 홍길동 | 운영체제 |
        | 101 | 홍길동 | 네트워크 |
          
        ---

        **제2정규화 (2NF: Second Normal Form)**

        - **조건:**
          1. 제1정규형(1NF)을 만족해야 합니다.
          2. **부분 함수 종속(Partial Functional Dependency)을 제거**해야 합니다. 즉, 기본 키가 여러 컬럼으로 구성된 복합 키(Composite Key)일 경우, 기본 키의 일부에만 종속되는 일반 속성(Non-prime attribute)이 없어야 합니다. 모든 일반 속성은 반드시 기본 키 *전체*에 종속되어야 합니다.
        - **목표:** 복합 키 중 일부에만 의존하는 속성을 분리하여 데이터 중복 및 이상 현상을 줄입니다.
        - **예시 (1NF -> 2NF):**
          - **Before:** `수강` 테이블 `(학생ID, 과목ID)` 가 기본 키이고, 속성으로 `학생이름`, `과목명`, `성적`이 있음. 여기서 `학생이름`은 `학생ID`에만 종속되고, `과목명`은 `과목ID`에만 종속됩니다 (부분 함수 종속).
          - **After:** 테이블을 분해합니다.
            - `학생` 테이블: `(학생ID, 학생이름)`
            - `과목` 테이블: `(과목ID, 과목명)`
            - `수강성적` 테이블: `(학생ID, 과목ID, 성적)`

        | **학생ID** | 과목ID | 학생이름 | 과목명 | 성적 |
                        | --- | --- | --- | --- | --- |
        | 101 | CS101 | 홍길동 | 자료구조 | A |
        | 101 | CS201 | 홍길동 | 운영체제 | B |
        | 201 | CS101 | 이몽룡 | 자료구조 | B+ |

        ⬇️ (2NF 만족)

        **학생 테이블**

        | 학생ID | 학생이름 |
                        | --- | --- |
        | 101 | 홍길동 |
        | 201 | 이몽룡 |

        **과목 테이블**

        | 과목ID | 과목명 |
                        | --- | --- |
        | CS101 | 자료구조 |
        | CS201 | 운영체제 |

        **수강성적 테이블**

        | 학생ID | 과목ID | 성적 |
                        | --- | --- | --- |
        | 101 | CS101 | A |
        | 101 | CS201 | B |
        | 201 | CS101 | B+ |
          
        ---

        **제3정규화 (3NF: Third Normal Form)**

        - **조건:**
          1. 제2정규형(2NF)을 만족해야 합니다.
          2. **이행 함수 종속(Transitive Functional Dependency)을 제거**해야 합니다. 즉, 기본 키가 아닌 속성이 다른 일반 속성에 의존해서는 안 됩니다. (A -> B 이고 B -> C 일 때, A -> C 가 성립하는 종속성 제거. 단, B는 후보 키가 아니어야 함)
        - **목표:** 기본 키를 통해 간접적으로 종속되는 속성을 분리하여 데이터 중복 및 이상 현상을 줄입니다.
        - **예시 (2NF -> 3NF):**
          - **Before:** `학생` 테이블 `(학생ID, 학생이름, 학과ID, 학과명, 학과전화번호)` 가 있음. 여기서 `학과명`과 `학과전화번호`는 기본 키인 `학생ID`에 직접 종속된 것이 아니라, 일반 속성인 `학과ID`에 종속됩니다 (`학생ID` -> `학과ID` -> `학과명`, `학과전화번호`). 이것이 이행 함수 종속입니다.
          - **After:** 테이블을 분해합니다.
            - `학생` 테이블: `(학생ID, 학생이름, 학과ID)`
            - `학과` 테이블: `(학과ID, 학과명, 학과전화번호)`

        | 학생ID | 학생이름 | 학과ID | 학과명 | 학과전화번호 |
                        | --- | --- | --- | --- | --- |
        | 101 | 홍길동 | CS | 컴퓨터공학과 | 123-4567 |
        | 201 | 이몽룡 | EE | 전자공학과 | 987-6543 |
        | 301 | 성춘향 | CS | 컴퓨터공학과 | 123-4567 |

        ⬇️ (3NF 만족)

        **학생 테이블**

        | 학생ID | 학생이름 | 학과ID |
                        | --- | --- | --- |
        | 101 | 홍길동 | CS |
        | 201 | 이몽룡 | EE |
        | 301 | 성춘향 | CS |

        **학과 테이블**

        | 학과ID | 학과명 | 학과전화번호 |
                        | --- | --- | --- |
        | CS | 컴퓨터공학과 | 123-4567 |
        | EE | 전자공학과 | 987-6543 |
          
        ---

        **BCNF (Boyce-Codd Normal Form)**

        - **조건:**
          1. 제3정규형(3NF)을 만족해야 합니다.
          2. 모든 **결정자(Determinant)** 가 **후보 키(Candidate Key)** 여야 합니다. 즉, 함수 종속성 X -> Y 에서 X가 반드시 슈퍼키(Superkey)여야 합니다. 3NF보다 조금 더 엄격한 조건입니다. (3NF는 X가 슈퍼키가 아니더라도 Y가 기본 키의 일부이면 허용)
        - **목표:** 3NF에서 해결하지 못하는 일부 이상 현상을 제거합니다. 주로 복수의 후보 키가 존재하고, 이들이 서로 중첩되는 경우에 필요합니다.
        - **예시 (3NF -> BCNF):**
          - **Before:** `수강신청` 테이블 `(학생ID, 과목명, 담당교수)` 가 있고, 각 과목은 한 명의 교수가 담당하며, 교수는 여러 과목을 담당할 수 있다고 가정. 추가로, 각 교수는 딱 한 과목만 담당한다고 가정 (현실적이지 않지만 BCNF 설명을 위해). 이 경우 `(학생ID, 과목명)`은 후보 키입니다. 또한 `담당교수` -> `과목명` 이라는 함수 종속이 성립합니다. 하지만 `담당교수`는 후보 키가 아닙니다. 이것이 BCNF 위반입니다.
          - **After:** 테이블을 분해합니다.
            - `수강정보` 테이블: `(학생ID, 담당교수)`
            - `교수과목` 테이블: `(담당교수, 과목명)`

          ---

        **제4정규화 (4NF: Fourth Normal Form)**

        - **조건:**
          1. BCNF를 만족해야 합니다.
          2. **다치 종속(Multi-valued Dependency, MVD)** 을 제거해야 합니다. 즉, A ->> B 와 같은 다치 종속에서 A가 슈퍼키가 아닌 경우가 없어야 합니다. 다치 종속은 하나의 A 값에 대해 여러 개의 B 값이 존재할 수 있고, 이것이 다른 속성 C와는 독립적일 때 발생합니다.
        - **목표:** 하나의 테이블에 두 개 이상의 독립적인 다대다 관계가 표현될 때 발생하는 데이터 중복을 제거합니다.
        - **예시 (BCNF -> 4NF):**
          - **Before:** `교수정보` 테이블 `(교수ID, 담당과목, 연구분야)` 가 있음. 한 교수는 여러 과목을 담당할 수 있고(다치), 여러 연구분야를 가질 수 있습니다(다치). 담당과목과 연구분야는 서로 독립적입니다. 이 경우 `교수ID` ->> `담당과목` 과 `교수ID` ->> `연구분야` 라는 다치 종속이 존재합니다.
          - **After:** 테이블을 분해합니다.
            - `교수과목` 테이블: `(교수ID, 담당과목)`
            - `교수연구` 테이블: `(교수ID, 연구분야)`

          ---

        **제5정규화 (5NF: Fifth Normal Form / PJNF: Project-Join Normal Form)**

        - **조건:**
          1. 제4정규형(4NF)을 만족해야 합니다.
          2. **조인 종속(Join Dependency, JD)** 이 후보 키를 통하지 않고는 성립되지 않아야 합니다. 즉, 테이블을 여러 개의 작은 테이블로 분해했다가 다시 조인했을 때 원래 테이블과 동일한 결과가 나와야 하며(손실 없는 분해), 이 분해가 후보 키에 의한 것이 아니라면 5NF 위반입니다.
        - **목표:** 매우 드물게 발생하는, 여러 테이블 간의 복잡한 관계에서 기인하는 데이터 중복을 제거합니다.
        - **예시:** 매우 복잡하고 실무에서 거의 고려하지 않습니다. 특정 제약 조건 하에서만 의미가 있습니다. 예를 들어, `(판매원, 회사, 제품)` 관계에서 "판매원이 특정 회사의 제품을 팔고, 그 회사가 그 제품을 만들며, 그 판매원이 그 제품을 취급한다면, 이 판매원은 해당 회사를 통해 해당 제품을 판매한다"는 규칙이 있을 때 발생할 수 있습니다. 이를 3개의 테이블 `(판매원, 회사)`, `(회사, 제품)`, `(판매원, 제품)`으로 분해해야 5NF를 만족할 수 있습니다.

          ---

        **요약 및 실용성:**

        - **1NF, 2NF, 3NF:** 데이터베이스 설계 시 기본적으로 고려하며, 대부분의 경우 3NF까지 진행하면 잘 설계된 데이터베이스로 간주됩니다.
        - **BCNF:** 3NF보다 엄격하며, 가능한 경우 BCNF를 만족시키는 것이 좋습니다.
        - **4NF, 5NF:** 다치 종속이나 조인 종속은 특수한 경우에 발생하며, 실무에서는 4NF나 5NF까지 정규화를 진행하는 경우는 드뭅니다. 지나친 정규화는 테이블 수가 너무 많아져 조인 연산이 복잡해지고 성능이 저하될 수 있으므로, 상황에 맞게 **정규화 수준과 성능 사이의 트레이드오프**를 고려해야 합니다.
    - 트랜잭션
      - 하나의 논리적 기능을 수행하기 위한 작업 단위
      - 트랜잭션이 정상적으로 처리되면 commit 실패시 rollback
    - 데이터베이스 정리
      - RDBMS
      - NoSQL
  - 자료구조

    자료구조 : 데이터를 어떤 형식으로 조직해 저장할 것인가

    - 배열
      - Array : 동일한 데이터 타입의 여러 데이터를 저장하는 자료구조
      - 각 데이터를 element
      - 요소의 위치를 0 부터 index
      - 탐색하는 시간 복잡도
        - 삽입, 삭제 마지막요소 O(1) ↔ 가운데 요소 O(n)
        - 탐색 O(1)
        - 삽입 삭제보다 탐색의 비중이 높은 경우 사용
    - 연결리스트
      - 포인터를 통해 여러 node가 연결돼 있는 자료구조
      - 각 node 는 data + pointer(다음 노드를 가리키는 포인터)
      - node 삽입 혹은 삭제시 앞 뒤 포인터만 변경해서 연결하면 됨
      - 탐색시간 O(n) - 특정 데이터가 몇 번째 노드에 위치하는지 알 수 없음
    - 스택
      - 접시더미처럼 ‘더미’를 의미함 후입선출(LIFO)
      - push(삽입), pop(삭제), top(스택상단을 가리키는 pointer)
    - 큐
      - 번호표 뽑고 순서를 기다리는 선입선출(FIFO)
      - rear(삽입 - 맨 뒤 데이터를 가리키는 포인터), front(삭제 - 맨 앞 데이터를 가리키는 포인터)
    - 그래프
      - 정점(vertext)와 간선(edge)로 이루어진 자료구조
      - 간선에 방향이 존재하면 방향 그래프(directed graph) ↔ 존재하지 않으면 무방향 그래프(undirected graph)
    - 트리
      - 그래프의 일종, 계층적 데이터의 집합
      - 루트 노트(최상위 노드) - 내부 노드(중간 노드), 리프 노드(자식이 없는 노드) 로 이어지는 부모-자식 형태 계층 구조
    - 맵
      - key - value 쌍으로 이루어진 데이터의 집합
      - key는 중복 x
    - 자료구조 정리
      - **선형 자료구조 (Linear Data Structure) vs. 비선형 자료구조 (Non-linear Data Structure)**
        - **개념:**
          - **선형 자료구조:** 데이터 요소들이 **일렬로 순차적으로 연결**되어 있는 형태입니다. 마치 기차 칸처럼 앞뒤 요소와의 관계가 중요합니다. 다음 요소가 무엇인지 예측하기 쉽습니다.
          - **비선형 자료구조:** 데이터 요소들이 **계층적 또는 네트워크 형태**로 연결되어 있습니다. 하나의 요소가 여러 다른 요소와 연결될 수 있습니다. 데이터 간의 관계가 더 복잡합니다.
        - **사용 예시:**
          - **선형:**
            - **배열(Array):** 순서가 있는 데이터를 저장할 때 (예: 학생들의 성적 목록)
            - **연결 리스트(Linked List):** 데이터 삽입/삭제가 빈번할 때 (예: 음악 플레이리스트)
            - **스택(Stack):** 가장 나중에 들어온 데이터를 먼저 처리할 때 (예: 웹 브라우저 뒤로 가기, 함수 호출 스택)
            - **큐(Queue):** 먼저 들어온 데이터를 먼저 처리할 때 (예: 프린터 인쇄 대기열, 메시지 큐)
          - **비선형:**
            - **트리(Tree):** 계층적인 데이터를 표현할 때 (예: 파일 시스템 폴더 구조, 조직도)
            - **그래프(Graph):** 복잡한 관계(네트워크)를 표현할 때 (예: 소셜 네트워크 친구 관계, 지하철 노선도)

        ---

      - **해시 테이블 (Hash Table)**
        - **개념:** 키(Key)와 값(Value)을 짝지어 저장하는 자료구조입니다. 키를 해시 함수(Hash Function)라는 특별한 계산식에 넣어 데이터가 저장될 위치(인덱스, 버킷)를 빠르게 알아냅니다. 이를 통해 데이터를 매우 빠르게 검색, 삽입, 삭제할 수 있습니다 (평균적으로 O(1) 시간 복잡도). 가끔 다른 키가 같은 위치를 가리키는 충돌(Collision)이 발생할 수 있으며, 이를 해결하는 방법들이 필요합니다.
        - **사용 예시:**
          - 파이썬의 딕셔너리(Dictionary), 자바의 HashMap 등 연관 배열(Associative Array) 구현
          - 데이터베이스 인덱싱 (빠른 검색을 위해)
          - 캐싱 (자주 사용하는 데이터를 빠르게 접근하기 위해 임시 저장)
          - 중복 데이터 확인

        ---

      - **이진 트리 (Binary Tree)**
        - **개념:** 비선형 자료구조의 일종으로, 각 노드(데이터 요소)가 **최대 두 개의 자식 노드**(왼쪽 자식, 오른쪽 자식)를 가지는 트리입니다. 최상위 노드를 루트(Root)라고 부릅니다. 자식이 없는 노드는 리프(Leaf) 노드라고 합니다.
        - **사용 예시:**
          - 계층적인 데이터 표현 (예: 간단한 조직도)
          - 이진 검색 트리, 힙 등 더 특수한 트리의 기본 구조
          - 수식 트리 (Expression Tree) - 연산자와 피연산자를 트리 형태로 표현

        ---

      - **이진 검색 트리 (Binary Search Tree - BST)**
        - **개념:** 이진 트리의 특별한 형태로, **정렬된 상태를 유지**하는 특징이 있습니다. 각 노드에 대해 다음과 같은 규칙이 적용됩니다.
          - 노드의 **왼쪽 서브트리**에 있는 모든 값은 **노드의 값보다 작습니다.**
          - 노드의 **오른쪽 서브트리**에 있는 모든 값은 **노드의 값보다 큽니다.**
          - 이 규칙 덕분에 데이터를 효율적으로 검색, 삽입, 삭제할 수 있습니다 (평균적으로 O(log n) 시간 복잡도). 하지만 트리가 한쪽으로 치우쳐 불균형해지면 성능이 저하될 수 있습니다 (최악 O(n)).
        - **사용 예시:**
          - 데이터를 정렬된 상태로 저장하고 빠르게 검색해야 할 때 (예: 사전)
          - 데이터의 삽입/삭제가 빈번하면서도 검색 성능이 중요할 때
          - 균형 잡힌 BST (AVL 트리, 레드-블랙 트리 등)는 성능 저하 문제를 해결하여 많이 사용됩니다.

        ---

      - **힙 (Heap)**
        - **개념:** **최대값 또는 최소값**을 빠르게 찾아내기 위해 고안된 **완전 이진 트리** 기반의 자료구조입니다. (완전 이진 트리: 마지막 레벨을 제외하고 모든 레벨이 완전히 채워져 있으며, 마지막 레벨의 노드는 왼쪽부터 채워짐)
          - **최대 힙(Max Heap):** 부모 노드의 값이 항상 자식 노드의 값보다 크거나 같습니다. (루트 노드가 가장 큰 값)
          - **최소 힙(Min Heap):** 부모 노드의 값이 항상 자식 노드의 값보다 작거나 같습니다. (루트 노드가 가장 작은 값)
          - *주의: 형제 노드 사이의 크기 관계는 정의되지 않습니다.*
        - **사용 예시:**
          - **우선순위 큐 (Priority Queue)** 구현 (가장 중요한/긴급한 작업을 먼저 처리)
          - 힙 정렬 (Heap Sort) 알고리즘
          - 주어진 데이터 묶음에서 k번째 최대값/최소값을 찾을 때

        ---

      - **우선순위 큐 (Priority Queue)**
        - **개념:** 일반적인 큐(FIFO: First-In, First-Out)와 달리, 들어온 순서가 아니라 데이터 요소의 우선순위(Priority)에 따라 데이터가 처리(삭제)되는 추상적인 자료구조입니다. 우선순위가 높은 요소가 먼저 나갑니다.
        - **구현 방법:** 주로 힙(Heap)을 사용하여 효율적으로 구현합니다. (최대 힙은 우선순위가 높은 것부터, 최소 힙은 우선순위가 낮은 것부터 처리) 배열이나 연결 리스트로도 구현 가능하지만, 힙보다 비효율적일 수 있습니다.
        - **사용 예시:**
          - 운영체제의 작업 스케줄링 (중요한 프로세스를 먼저 실행)
          - 네트워크 라우팅 알고리즘 (예: 다익스트라 알고리즘에서 최단 거리를 가지는 노드를 선택)
          - 이벤트 처리 시스템 (긴급한 이벤트를 먼저 처리)
          - 병원 응급실 (위급한 환자를 먼저 치료)
- Chapter03 백엔드 개발 언어와 프레임워크
  - 프로그래밍 패러다임

    paradigm : 문제를 해결하는데 사용하는 기본적인 철학이나 접근 방식

    - 명령형 프로그래밍
      - 어떻게 문제를 해결할 것인가에 초점
      - 연속된 명령어를 통해 문제를 해결하는 방식
    - 절차지향 프로그래밍
      - 명령형 프로그래밍에 속하는 방법
      - 각 명령에 순서가 있고 반드시 한 방향으로 수행돼야 한다는 원칙
      - 실행속도가 빠르지만 유지보수와 디버깅이 어려움
    - 객체지향 프로그래밍
      - 실세계를 모델링해 프로그램을 개발하는 방법
      - 속성, 기능으로 사물의 본질을 정의해 만들어진 모델 ⇒ class ⇒ class로부터 실체화된 객체 object
      - 특징
        - 추상화(abstraction)
          - 공통 속성과 기능을 추출해 이름을 붙이는 과정
        - 캡슐화(encapsulation)
          - 속성과 기능을 하나의 캡슐로 묶는 것 → 외부로 노출하고 싶은 속성이나 기능 제어
        - 상속(inheritance)
          - 기존 상위 클래스의 속성과 기능을 가져다 하위 클래스에서 재 사용하는 것 (is-a 관계)
    - 함수형 프로그래밍
      - 불변성(immutable)
        - 데이터는 일단 생성되면 변하지 않아야한다. → 언뜻보면 불편해보이지만 ‘참조 투명성’이 보장됨
      - 선언형(declarative)
        - 무엇을 할 것인지에 초점을 둠
  - 백엔드 개발 언어
    - 자바스크립트
      - 웹 페이지의 정적인 HTML 콘텐츠를 동적으로 변경하거나 이벤트 같은 상호작용을 구현하기위한 스크립트 언어 (인터프리터방식)
      - 인터프리터 방식
        - 소스 코드를 한 줄씩 읽고 그 즉시 기계어로 변환해 실행 → 모든 코드가 실행될 때까지 코드 읽고 실행 반복
      - 컴파일 방식
        - 전체 소스코드를 읽고 한꺼번에 기계어로 변환, 결과물인 실행 파일을 저장해 실행
      - Node.js 등장 ⇒ 기존 프론트엔드 개발에서 백엔드 개발에도 사용 가능해짐 (runtime 환경에서 실행할 수 있게 해줌)
      - 데이터 타입 명시 필요 없는 동적 타입의 언어
      - DOM API 기반 웹 브라우저 내 이벤트 처리 같은 사용자와의 상호작용 처리
        - DOM(Document Object Model) API ⇒ 웹 페이지의 텍스트를 바꾸거나 이미지 추가하거나, 버튼 동작 등 작업에 사용
    - 타입스크립트
      - 자바스크립트에서 프로젝트 규모가 커질수록 동적 데이터 타입으로 인해 예측하지 못하는 동작 발생 가능성 높음
      - 자바스크립트의 모든 기능을 유지하면서 정적 타입과 관련된 문법 추가
    - 자바
      - JVM을 통해 실행(가상머신) ⇒ 운영체제에 종속되지 않고 실행 가능
      - primitive type 을 제외하면 모든 데이터들을 객체로 구성함 (객체 지향 프로그래밍에 적합)
      - 모든 메모리 접근을 자바 시스템이 관리하고 제한함 (gc, memory leak 등 걱정하지 않아도 됨)
      - 멀티 스레드 구현에 용이함
  - 백엔드 프레임워크
    - 라이브러리와 프레임워크
      - 라이브러리 : 개발하는데 필요한 기능을 미리 구현해놓은 코드의 모음
      - 프레임워크 : 복잡한 문제를 해결하거나 서술하는데 사용되는 기본구조란 의미로 일정한 형태와 기능을 제공하는 틀
    - Express.js: 자바스크립트 기반
      - Node.js가 제공하는 API를 바탕으로 백엔드 개발을 할 수 있도록 만들어진 프레임워크
      - 장점
        - 경량화된 프레임워크 ⇒ 간단하고 빠르게 웹 서버를 만들 수 있음
        - 유연성이 뛰어남 (필요한 기능만 선택해 사용 가능)
        - 다양한 미들웨어와 플러그인 지원
      - 단점
        - 대규모 프로젝트 개발에 부적합 (경량화된 프레임워크)
        - 프로젝트 규모가 커질수록 코드 구조가 복잡해짐
        - 멀티 스레드 지원하지 않음
        - 공식적으로 세션 관리, db연결을 지원하지 않음 (third party library 사용)
    - NestJS: 타입스크립트 기반
      - 타입스크립트 우선 지원하는 프레임워크
      - DB, ORM, 각종 설정, 유효성 검사등 수많은 기본 기능 제공
      - DI, IoC 같은 객체지향 개념 이용해 Express.js의 구조적 문제 해결
      - 장점
        - 타입스크립트 ⇒ 코드 안정성 향상
        - 모듈화 + 의존성 주입 지원 ⇒ 모듈간 결합도 낮추고 코드 재사용성 높임
        - MSA 구현을 위한 기능 내장되어있음 (확장 용이)
      - 단점
        - 초기 설정 복잡함
        - 속도가 느림
    - 스프링: 자바 기반
      - 개발자가 비즈니스 로직에 집중할 수 있도록 함
      - POJO(Plain Old Java Object) 지향 - 순수하게 만든 자바만 이용해 만든 객체를 사용함으로써 외부 기술 변화, 환경에 종속되지 않음
        - DI(의존성주입)
        - IoC(제어 역전)
        - AOP(Aspect-Oriented Programming)
        - PSA(Portable Service Abstraction)
    - 스프링부트: 자바 기반
      - 스프링을 사용할 때 실행 환경이나 의존성 관리 설정에 들이는 시간과 에너지를 아껴 비즈니스로직에 집중할 수 있게 해줌
      - 내장 tomcat
  - 백엔드 개발 언어와 프레임워크 선택 방법
    - 자바스크립트 + Node.js
      - 비동기 처리에 강함
      - 싱글 스레드 기반 이벤트 루프로 빠른 응답시간 제공
    - 자바 + 스프링 부트
      - 다양한 모듈을 사용할 수 있고 안정된 성능을 보여줌
      - 대규모 서비스에 적합
    - 파이썬 + 장고/플라스크/FastAPI
      - AI 및 데이터 중심의 웹 애플리케이션 개발에 유리
      - 진입 장벽이 낮음
      - 장고 - 기능 풍부 + 초기 학습 필요
      - 플라스크 - 직관적
      - FastAPI - 큰 규모에서는 효용이 떨어짐
    - IDE 선택 방법
      - 언어 지원 확인
      - 기능 확인 (코드 자동완성, 디버깅, 테스팅)
      - 플러그인 및 확장 프로그램 지원
      - UI 및 성능
- Chapter04 DBMS
  - DBMS의 개요
    - RDBMS
      - 사물의 특성을 관계로 표현함
        - 1:1, 1:N, N:M 관계
      - SQL(Structured Query Language)
        - DDL
          - 테이블이나 관계 구조 생성 및 관리
          - CREATE, DROP, ALTER, TRUNCATE
        - DML
          - 테이블의 데이터 생성, 조회, 수정, 삭제
          - SELECT, INSERT, UPDATE, DELETE
        - DCL
          - 데이터의 사용 권한을 관리
          - GRANT, REVOKE
    - NoSQL
      - Not Only SQL
      - 저장 형식이 일정하지 않은 비정형 데이터를 효율적으로 관리하기 위해 개발
      - 종류
        - 도큐먼트 데이터베이스
          - JSON, XML 형식의 도큐먼트로 데이터 저장
          - MongoDB
          - 행과 열 개념 없고 데이터마다 구성도 다름
        - 키 - 값 데이터베이스
          - CassandraDB / DynamoDB
          - 간단한 데이터 처리 작업, 데이터 간의 관계가 중요하지 않은 경우 사용
        - 그래프 데이터베이스
          - Neo4j
          - 4개 이상 테이블을 이용하는 복잡한 쿼리 수행할 때 강점
          - 노드와 간선으로 이루어진 그래프 형태의 데이터 모델 사용
          - SNS 친구관계같은 데이터 간의 연결 효율적 관리 + 경로탐색같은 복잡한 쿼리 지원
          - 대용량 데이터처리에 제한적
  - RDBMS에서의 CRUD
    - 테이블 만들기 - 생략
    - 데이터 CRUD - 생략
    - 테이블 조인
      - INNER JOIN - 공통된 속성 값을 가진 튜플 반환
      - FULL OUTER JOIN - 왼쪽 테이블과 오른쪽 테이블의 모든 행 반환
      - LEFT JOIN - 왼쪽 테이블 모든 결과 + 오른쪽 테이블에서는 왼쪽과 일치하는 값만 결과에 포함 + 없는 경우 NULL
      - RIGHT JOIN - 기준 테이블인 오른쪽 테이블 결과 + 오른쪽과 일치하는 왼쪽 테이블 값만 결과에 포함 + 없는 경우 NULL
  - NoSQL에서의 CRUD
    - MongoDB의 특징
      - Collection(테이블) 과 Document(field + value 쌍으로 구성)를 사용해 데이터 저장
    - 컬렉션 만들기
      - 컬렉션 생성

        ```docker
        db.createCollection("컬렉션명")
        
        show collections // 해당 db내 컬렉션 목록 확인 가능
        ```

    - 데이터 CRUD
      - 데이터 생성

          ```docker
          db.컬렉션명.insert({field: value, field: value, ...})
          
          // 실행 결과
          {
            acknowledge: true, // 데이터 생성 작업 성공 여부
            insertedIds: {'0': ObjectId("123456789abcd")} // 생성된 도큐먼트의 아이디
          }
          ```

      - 데이터 조회

          ```docker
          db.컬렉션명.find() // 모든 도큐먼트 조회
          db.컬렉션명.find({조건}) // 조건에 부합하는 도큐먼트 조회
          
          db.board.find({"private": true});
          ```

      - 데이터 수정
        - updateOne : 조건에 부합하는 도큐먼트 중 맨 처음 도큐먼트만 수정
        - updateMany : 조건에 부합하는 모든 도큐먼트 수정

          ```docker
          db.컬렉션명.updateOne({filter}, {update}) // filter 조건에 부합하는 맨 첫번째 도큐먼트를 update 규칙에 따라 수정
          db.컬렉션명.updateMany({filter}, {update}) // filter 조건에 부합하는 모든 도큐먼트를 update 규칙에 따라 수정
          
          db.board.updateOne({title: "제목1"}, {$set: {title: "제목2}})
          {
            acknowledged: true,
            intertedId: null,
            matchedCount: 1,
            modifiedCount: 1,
            upsertedCount: 0
          }
          ```

      - 데이터 삭제하기
        - deleteOne : 조건에 부합하는 도큐먼트 중 첫번째 도큐먼트를 삭제
        - deleteMany : 조건에 부합하는 모든 도큐먼트 삭제

          ```docker
          db.컬렉션명.deleteOne({조건})
          db.컬렉션명.deleteMany({조건})
          db.컬렉션명.deleteMnay({}) // 전체삭제
          ```

- Chapter05 API
  - API의 개요
    - API의 개념
      - API(Applicatoin Programming Interface)
        - 응용 프로그램에서 사용할 수 있도록 운영체제나 프로그래밍 언어가 제공하는 기능을 제어하기 위한 인터페이스
      - Interface
        - 여러 장치나 프로그램 사이에서 통신이 가능하도록 도와주는 매개체
      - 예시
        - 클라이언트 → API 호출(데이터요청) → 서버 → 데이터베이스 → 서버 → 클라이언트(데이터반환)
    - API 개발 순서
      - 엔드포인트 설계
        - 요청을 보낼 서버의 주소 설정하고 해당 경로에 어떤 API를 요청할지 최종 엔드포인트 정의 (하나의 경로에 여러 엔드포인트 지정 가능)
      - HTTP 메서드 지정
        - 클라이언트가 서버에 보내는 요청의 종류 POST, GET, PUT 등
      - 데이터 포맷 및 프로토콜 선택
        - 데이터 포맷 - JSON
        - 프로토콜 - RESTful
      - 엔드포인트 구현
        - 각 엔드포인트로 접수된 클라이언트의 요청을 처리하는 서버 측 로직 구현
      - 인증 및 보안
        - API 보호를 위한 사용자 인증, 액세스 토큰 기반 권한 부여, 암호화 등 기능 구현
      - 오류 및 예외 처리
        - 잘못된 요청이나 예외 상황에 적절한 오류를 응답할 수 있도록 구현
      - 테스트와 디버깅
        - API 정확성, 안정성, 문제 해결 및 성능 최적화 가능
      - API 문서화
        - API를 사용하는 다른 개발자가 쉽게 이해하고 사용할 수 있도록 문서화
        - 엔드포인트, 매개변수, 응답 형식, 오류 코드 등에 대한 명세를 문서로 작성
  - API의 유형
    - REST API
      - REpresentational State Transfer API
      - 웹의 장점을 이용해 만든 API 설계 스타일
      - 구성요소
        - resource(자원)
          - 클라이언트와 서버가 주고받는 자원(텍스트, 이미지, 영상 등)을 URI로 명시
          - URI는 URL의 상위 개념으로 특정 자원 자체를 의미
          - `scheme:[//[user[:password]@host[:port]][/path][?query][#fragment]`
            - scheme - 사용할 프로토콜의 종류 (http, https)
            - user, password - 서버에 저장된 데이터에 접근하는데 필요한 사용자 이름과 비밀번호 (생략가능)
            - host, port - 접근할 서버의 호스트 명(도메인, IP 주소)와 포트
            - path - 접근할 서버의 경로에대한 상세 정보
            - query - 접근할 대상에 전달하는 추가정보
            - fragment - 메인 자원 내에 있는 서브자원에 접근할 때 이를 식별하기 위한 정보
        - verb(행위)
          - 해당 자원에 CRUD 연산을 적용하는 것을 의미
          - CREATE - POST
          - READ - GET
          - UPDATE - PUT, PATCH
          - DELETE - DELETE
        - representation of resource(표현)
          - 클라이언트가 서버에 자원 요청하면 요청 받는 시점의 자원 상태를 반환함 (JSON 또는 XML 형태)
      - REST API 특징
        - 요청 메시지만 보고도 어떤 동작이나 정보를 요청하는 지 쉽게 이해 가능
      - 설계 규칙
        - URI에 명사를 사용
          - GET/getUserById/:id(x) ↔ GET/users/:id (o)
        - 자원의 계층 관계를 /로 나타냄
          - has-a 관계
        - 마지막에 /를 넣지 않음
        - 명사와 명사를 구분할때 -를 사용
        - 소문자 사용
        - 확장자 사용X
        - 적절한 HTTP 상태코드 응답
    - GraphQL
      - Graph Query Language - 페이스북에서 만든 쿼리 언어로, 클라이언트가 서버로부터 데이터를 효율적으로 가져오기 위해 개발됨
      - 기존 rest api에서는 get /auther/:id 라고 하면 이름과 이메일을 응답하게 해놨고 전화번호도 필요하다할 때 이를 변경하려면 코드를 고쳐야함
      - GraphQL은 원하는 데이터를 직접 요청할 수 있음 (클라이언트 단에서)

        ```docker
        query Author($id: Int) {
          author(id: $id) {
            name
            email
            // phoneNumber 추가 가능
          }
        }
        ```

      - URI 하나로 필요한 데이터를 조합한 쿼리를 요청 가능함
  - API 명세서
    - API 명세서 작성 방법
      - API 목차 시트 만들기
        - URL - 클라이언트가 요청을 보낼 서버 주소
        - API 목차 - method, 하위 URI, description, 명세서 작성 여부, 서버 작성 여부
        - 세부 명세서 작성
          - method (GET, POST …)
          - Header (JWT 등)
          - Body (클라이언트가 서버로 전송하는 본문 데이터)
          - Query String (URL 뒤에 오는 매개변수 key=value 형식)
          - Path Variable (URL 경로 내에 동적으로 변경되는 값을 나타내는 URL)
          - Response Parameters (API 요청에 대한 응답으로 반환되는 데이터의 필드와 속성)
          - Response Sample (API 요청에 대한 응답 예시)
          - Result Code (처리 결과)
    - OpenAPI: 스웨거
      - REST API를 문서화하기 위한 공개 표준
      - 자동으로 API 명세서를 생성하고 스웨거 UI를 통해 API 명세서를 시각적으로 구조화해 보여줌
      - 프론트엔드 개발자가 실시간으로 업데이트 된 API 문서를 보고 개발 가능
      - API 명세서를 토대로 API 테스트를 확인할 수 있음
- Chapter06 버전 관리 시스템
  - 버전 관리 시스템의 개요
    - 버전 관리 시스템의 개념
      - 파일의 변화를 시간에 따라 버전별로 기록했다가 나중에 다시 사용할 수 있도록 만든 시스템
      - 추가, 수정, 삭제 내역 확인
      - 언제 어떤 사용자가 작업했는지 추적 가능
      - 파일을 이전 상태로 되돌리고 시간대별로 파일의 변경 사항 비교 가능
    - 버전 관리 시스템의 종류
      - CVCS(중앙 집중식 버전 관리 시스템)
        - 중앙에 서버를 두고 저장소로 사용
        - 네트워크로 연결된 모든 컴퓨터의 파일 변경내역을 저장하고 관리하는 방식
      - DVCS(분산 버전 관리 시스템)
        - 모든 사용자의 컴퓨터가 저장소로서 버전 관리를 담당함
        - 파일을 한 번 저장소에서 받아온 다음 서버와 별개로 작업 가능
        - 서버에 문제가 생겨도 작업하는 데 지장이 없고, 다른 컴퓨터에서 파일을 받아와 복원도 가능
        - 오프라인에서 작업해도 전체 복제본을 받아서 작업하기 때문에 모든 변경이력이 남음
        - merge, pull 을 통해 양쪽 시스템 간에 동기화를 수행함
  - 분산 버전 관리 시스템: 깃
    - 깃의 동작 방식
      - 각 파일의 변경 이력을 기록하지 않고 대상의 전체 모습을 기록하는 스냅샷을 .git폴더에 저장해 버전 관리 수행
    - 깃의 작업 영역
      - 작업 공간(working directory)
        - 현재 작업하고 있는 공간
        - git add 명령 실행 전까지 이 영역에서 발생하는 파일 변경 및 상태의 변화를 추적하지 않음
      - 스테이징 영역(staging area)
        - 작업 공간에서 발생한 상태 변화 중 실제로 변경 이력을 남길 작업을 선정하는 공간
        - git add를 통해 staging 영역에 이동했을 때만 깃으로 변경 사항 기록함
      - 내부 저장소(local repository)
        - 스테이징 영역에서 git commit 명령어를 통해 이동하는 영역 .git 폴더를 의미
        - 스테이징 영역에 있는 파일의 변경 이력을 스냅샷으로 만들어 저장함
  - 웹 기반 버전 관리 저장소: 깃허브
    - 깃허브의 동작 방식
      1. 프로젝트 매니저가 폴더를 생성한 후 소스코드 저장 → .git 저장소 만들고 최초의 스냅샷 저장
        1. git init
        2. git add
        3. git commit
      2. 자신의 컴퓨터에 있는 스냅샷을 외부 저장소인 깃허브에 업로드
        1. git remote add origin(외부저장소별칭) 외부저장소주소
        2. git push origin(외부저장소별칭) main(브랜치이름)
      3. 팀원들은 깃허브를 이용해 소스코드 + 저장소에서 관리하는 모든 스냅샷 내려받아 작업함
        1. git clone 외부저장소주소 or git pull 외부저장소주소
          1. 차이점
            1. clone - 내 컴퓨터의 특정 폴더를 관리하도록 선언 + 깃허브에서 프로젝트를 내려받아 동기화하는 작업 수행 (git init + git pull)
            2. pull - 이미 내 컴퓨터의 특정 폴더를 깃으로 관리하고있는 상태에서 깃허브의 프로젝트와 동기화만 수행
    - 브랜치
      - 동일한 프로젝트에 대해 각 개발자가 독립적으로 작업을 수행하기 위해 사용하는 개념
      - 원래 프로젝트에서 분기해 작업을 진행
      - 브랜치 종류
        - master - 제품으로 출시될 수 있는 브랜치
        - feature - 새로운 기능을 개발하는 브랜치
        - develop - 다음 버전 출시를 위해 개발 중인 브랜치
    - 충돌
      - 다수의 개발자가 동시에 작업함에따라 충돌(conflict) 발생 가능
      - 여러 브랜치에서 같은 파일을 수정한 경우
      - 파일 이름이나 경로가 충돌하는 경우
- Chapter07 클라우드 컴퓨팅
  - 클라우드 컴퓨팅의 개요
    - 클라우드 컴퓨팅의 개념
      - 언제 어디서든 인터넷을 통해 접속할 수 있는 컴퓨팅 환경
      - 클라우드 도입 이전에는 자체적으로 서버 구축, 운영하는 on-premise 시스템 사용
      - 온프레미스 시스템
        - 사용자가 보안과 데이터 소유권 직접 통제
        - 외부 네트워크에 연결하지 않아도 내부 네트워크에서 서버 접근 가능
        - 초기투자비용, 유지보수비용 많이 듦
        - 자원의 확장성, 유연성 제한
      - 클라우드 시스템
        - 사용한 자원에 대해서만 비용 지불
        - 초기 비용이 적음
        - 복잡한 인프라 구축과 유지보수 비용 부담 줄어듦
        - 확장성과 유연성이 뛰어나고 자원을 신속하게 확장, 축소 가능
        - 인터넷이 연결된 장치 어디에서나 접속 가능
    - 클라우드 서비스의 종류
      - 공용 클라우드
        - 다수의 사용자가 공유하는 클라우드 환경
        - AWS, Azure, GCP
      - 사설 클라우드
        - 단일 조직이나 기업이 사용하는 클라우드 환경
      - 하이브리드 클라우드
        - 공용 + 사설 클라우드 조합
        - 클라우드 운영하면서 사설 클라우드 + 필요시 공용 클라우드 자원 이용
      - IaaS
        - 인프라 - 네트워크 장비, 데이터 스토리지, 서버 등 시스템을 구성하는 물리적인 요소
        - 클라우드 서비스 제공 업체가 가상 인프라를 제공하는 모델 (AWS, Azure, GCP)
      - PaaS
        - 플랫폼 - 소프트웨어 개발 및 실행 환경을 제공하는 기술적 기반, 운영체제, 미들웨어, 런타임 포함
        - 웹 애플리케이션을 구축하고 실행할 수 있는 인프라와 플랫폼 제공(Heroku, 구글 앱 엔진, 애저 앱서비스)
      - SaaS
        - 소프트웨어 - 컴퓨터에 명령을 내려 작업을 수행하는 프로그램, 애플리케이션, 데이터의 집합
        - 클라우드 서비스 제공업체가 웹 애플리케이션을 제공하는 모델(세일즈포스, 구글 워크스페이스, MS365)
  - 클라우드 서비스: AWS
    - Amazon EC2: 가상 서버 서비스
      - 가상의 서버 컴퓨터를 provisioning(필요할 때 바로 사용할 수 있도록 인프라 구성 및 관리작업 자동화)
      - EC2 인스턴스 - 다양한 사양, 운영체제 지원
      - 웹서버 - 클라이언트로부터 HTTP 요청을 받아 정적인 웹 페이지를 제공하는 서버
      - API 서버 - 클라이언트로부터 API 요청을 받아 응답하는 서버
      - 프록시 서버 - 클라이언트와 서버 사이에서 중계 역할 수행(통신 중계, 보안, 로드밸런싱, 캐싱)
      - FTP 서버 - 파일 업로드 및 다운로드 서비스 제공
      - 보안 그룹, 네트워크 접근 제어자목록(ACL), 가상 사설네트워크(VPC) 등 구성 가능
    - Amazon S3: 스토리지 서비스
      - 파일을 저장하는데 사용되는 스토리지
      - 파일이 보관되는 바구니 - bucket
        - 버킷은 빈 상태에서 시작
        - 보관하는 파일의 개수, 크기, 유형 제한 없음
        - 필요한 사용자에게만 버킷 / 버킷 내 파일 단위의 접근 허용
        - 파일의 안전성 보장하는 암호화 기술 제공
      - 웹사이트 호스팅 - 버킷에 정적파일 저장하면 S3버킷을 통해 사용가능
      - 미디어 콘텐츠 호스팅
      - 데이터 백업 및 복원
      - 데이터 저장 및 분석 - 머신러닝, 데이터 분석 등
    - Amazon RDS: 데이터베이스 서비스
      - 관계형 데이터베이스를 구축하고 관리할 수 있도록 도와주는 클라우드 서비스
      - 데이터 베이스 생성 (MySQL, PostgreSQL, Oracle 지원)
      - 데이터 백업 및 복원
      - 데이터베이스 모니터링
      - 자원 자동 조정
    - AWS IAM: 보안 및 접근 권한 제어
      - AWS 자원에 접근하고 사용할 수 있는 사용자의 권한 제어
      - 사용자 권한 관리 - 각 사용자에게 고유한 자격 증명 부여
      - 사용자 역할 관리 - IAAM role 일시적으로 사용되는 권한
      - 사용자 그룹 관리
      - 자원 접근 정책 관리 - 그룹, 롤 단위로 적용됨
      - 암호 정책
      - MFA관리 - 사용자의 신원을 확인하기 위해 여러 가지 인증 요소 사용
  - AWS 서버 구축 방법
    - EC2 인스턴스 생성
      - EC2 검색 → 인스턴스 시작
      - 생성 → 인스턴스 이름, 운영체제, 인스턴스 유형, 키페어, 보안그룹, 스토리지 구성
    - EC2 인스턴스 접속
      - ssh 원격 접속
    - 웹 애플리케이션 배포
      - 소스 코드 가져오기 → 빌드 → 설정파일 수정 → 실행
- Chapter08 가상화와 컨테이너
  - 가상화와 컨테이너의 개요
    - 가상화의 개념
      - 하나의 물리적인 서버를 여러 개의 가상 서버로 분할해 사용하는 기술
    - 가상화의 종류
      - 개발 환경 가상화
        - 개발의 필요한 환경을 가상으로 만들어줌 (anaconda)
      - 머신 가상화
        - VM으로 하나의 서버에 여러 운영체제를 실행할 수 있게 해줌 (VMware, Citrix, WSL)
      - 운영체제 수준 가상화
        - 호스트 운영체제 위에 격리된 컨테이너를 만들어 컨테이너 안에서 웹 애플리케이션을 실행하는 기술 (도커, 쿠버네티스)
    - 컨테이너의 개념
      - 격리된 여러 개의 실행 환경을 제공하는 기술 (라이브러리, 실행 파일, 구성 파일)
      - 가상머신
        - hypervisor - 소프트웨어 계층을 사용해 호스트 운영체제 위에 게스트 운영체제를 설치하고 실행하는 방식
          - 자체적 게스트 운영체제 + 웹 애플리케이션
        - 컨테이너 - 호스트 운영체제 위에서 격리된 실행 환경을 만듦
          - 자체적 게스트 운영체제 없이 호스트 운영체제의 자원을 공유받아 실행
  - 컨테이너 플랫폼: 도커
    - 도커의 개념
      - 컨테이너 기술을 이용해 웹 애플리케이션을 배포하고 실행하는 오픈 소스 플랫폼
      - 웹 애플리케이션을 하나의 이미지로 만들고 이미지를 활용해 컨테이너 생성 및 실행
      - 호스트 운영체제의 제한을 받을 수 있음
    - 도커의 구조
      - client - api를 통해 host 의 docker daemon과 요청을 주고 받음, cli 환경 제공, dockerd(컨테이너, 이미지 관리 주체)라는 프로세스를 통해 동작함
      - host - docker daemon, container, image
      - hub - container registry
    - 컨테이너 이미지
      - 컨테이너 실행에 필요한 모든 것들이 포함된 패키지 (소스 코드, 런타임, 라이브러리, 환경 변수 등)
      - Dockerfile → docker image → docker container
    - 컨테이너의 주요 명령어
      - docker run [옵션] [이미지이름] - 컨테이너 생성 & 실행 명령어
      - docker start, stop, restart [컨테이너 이름]
      - docker rm [컨테이너이름] - 삭제
      - docker ps - 실행중인 컨테이너 목록
      - docker logs [컨테이너 이름]- 로그
      - docker exec [옵션] [컨테이너이름] [실행할 명령] - 컨테이너 내부에서 명령 실행
      - docker build -t 이미지명:tag - 도커 이미지 생성
    - 컨테이너 실행 과정
      - docker run(컨테이너 생성 및 실행) 또는 docker start(컨테이너 실행)
  - 컨테이너 오케스트레이션
    - 도커의 등장으로 복잡한 서버세팅 과정 없이 가상화 기술 구현이 가능하게 됨 → 거대한 server cluster(여러 서버를 하나의 시스템으로 묶는 것)가 형성됨
    - 다수의 컨테이너를 관리하는 프로세스를 container orchestration 이라 함
    - Kubernetes, Docker Swarm, APache Mesos 등이 있음
- Chapter09 웹 애플리케이션 아키텍처
  - 웹 애플리케이션 아키텍처의 개요
    - 애플리케이션과 웹 애플리케이션의 차이
      - 애플리케이션
        - 운영체제 위에 설치해 사용하는 프로그램 ( 카카오톡, 포토샵 등)
      - 웹 애플리케이션
        - 웹 브라우저 위에서 작동하는 프로그램
          - 접근성, 우수한 확장성 및 유지 보수성 장점, 사용자 경험 장점(다운로드 불필요)
    - 웹 애플리케이션 아키텍처의 개념
      - 모듈들을 도식화해 각 영역이 상호작용하는 방법을 구체적으로 정의
        - 사용자에게 보여줄 화면을 담당하는 클라이언트 모듈
        - 화면에 표시할 데이터를 제공하는 서버 모듈
        - 데이터를 모아두는 데이터베이스 모듈
    - 웹 애플리케이션 아키텍처의 중요성
      - 유지보수성
        - 사용자 - 클라이언트 - 서버 - 데이터베이스 단일 구조이면 서버에서 오류가 났을 때 전체를 고쳐야함 ↔ 서버가 이미지 서버, 텍스트 서버로 분리되어있다면 오류 발생 부분만 수정 가능 (오류발생 안한 서버는 정상 동작 가능)
      - 확장성
        - 위의 경우에도 결국 확장하기위해 댓글 서버를 하나 더 추가하면 기존 서버를 건드리지 않아도 되므로 확장성이 뛰어나짐
  - 웹 애플리케이션 아키텍처의 종류
    - 모놀리식 아키텍처
      - 하나의 대규모 응용 프로그램으로 구성된 전통적인 소프트웨어 아키텍처
      - 3tier architecture ( client 표현계층 ↔ server 논리 계층 ↔ database 데이터 계층 )
        - presentation tier - 사용자와 직접 접촉하는 계층, 사용자 인터페이스 요소 등이 포함됨
        - logic tier - 비즈니스 로직이 실행되는 계층 (사용자 요청을 받아 처리)
        - data tier - 데이터 저장소에 접근해 데이터를 불러오거나 저장하는 계층, 데이터 접근 경로는 논리 계층에서 결정
      - 높은 결합도 - 한 모듈을 변경하면 전체 시스템에 영향을 미칠 수 있음
      - 높은 복잡성 - 시스템의 크기가 커질수록 코드의 복잡도 증가
      - 단일 데이터베이스 - 하나의 데이터베이스를 사용해 모든 데이터를 처리 (스키마 변경이 어려움)
      - 전체 시스템 중단 가능성 - 단일 프로세스 내에서 전체 시스템이 실행됨
      - 개발 프로세스의 복잡성 - 모든 개발자와 코드 변경사항이 생길 때마다 공유하고 테스트해야 함
    - 마이크로서비스 아키텍처
      - 웹 애플리케이션을 여러 개의 작은 서비스 단위로 분해해 각각의 서비스를 독립적으로 개발, 배포, 운영하는 방식
      - 각 서비스마다 DB를 따로 구축하고 이러한 서비스들이 API 게이트웨이와 연결 됨
      - 관심사 분리 - 각 서비스가 한 가지 기능을 수행하도록 설계 됨
      - 분산 데이터 관리 - 각 서비스는 자체 데이터베이스를 가지기 때문에 스키마 변경에도 유연하게 대처 가능
      - 개발, 배포 용이 - 각 서비스를 독립적으로 개발해 배포할 수 있음
      - 높은 탄력성 - 하나의 서비스에 장애가 발생해도 다른 서비스는 정상 작동함
    - 서버리스 아키텍처
      - 서버가 존재하지 않는 아키텍처 (실제로 존재하지 않는 것이 아닌 개발자가 신경쓰지 않아도 된다는 의미)
      - BaaS(Backend as a Service) - 클라우드 서비스 제공 업체가 제공하는 백엔드 기능을 활용해 웹 애플리케이션 구축 (Firebase, AWS AppSync, Azure Cosmos DB)
        - 제공된 API에 한정된 기능 구현, 코드 수정 및 유지보수로 인한 배포가 잦아짐
      - FaaS(Function as a Service) - 개발 프로젝트를 여러 개의 함수로 쪼개 매우 거대하고 분산된 클라우드 컴퓨팅 환경에 미리 준비해둔 함수를 등록, 실행된 횟수와 시간만큼 비용지불
        - AWS 람다
        - 서비스에 필요한 함수의 코드 스크립트만 작성해 등록
        - 함수에서  사용할 수 있는 자원에 제한이 있음
  - 추천 프로젝트
  - 정리하기
- Chapter10 테스트와 CI/CD
  - 테스트의 개요
    - 테스트의 개념
      - 테스트 코드를 작성해 웹 애플리케이션의 기능, 동작, 성능을 확인하고 검증
      - 왜 필요한지? → 한 가지 기능만 바꿔도 확인할 지점이 많은 복잡한 웹 애플리케이션에서 개발자가 일일이 코드를 실행해보지 않아도 코드가 잘 동작하리라는 것을 보장받을 수 있도록해 예상치 못한 부작용을 잡아냄
    - 테스트의 이점
      - 기능적 요구 사항 충족 확인
        - 제품의 기능적 요구 사항을 충족하는지 (정확하게 동작하는지)
      - 초기의 요구 사항 파악을 위한 도구
        - 설계하는 단계에서도 활용 가능
        - 기능적 요구 사항을 최대한 분석해 최적의 설계를 진행
        - 미처 발견하지 못한 예상 밖의 케이스를 찾아낼 수 있음
      - 협업을 위한 문서
        - 타인이 코드 유지보수 시 유용함
        - 코드의 전반적인 흐름을 이해하는데 도움을 주는 일종의 문서 역할
  - 테스트의 종류
    - 단위 테스트
      - 소스 코드를 구성하는 가장 작은 단위의 개체를 테스트 하는 것
        - 개별 함수, 클래스, 메서드 등
        - 여러 기능이 결합된 복잡한 흐름을 역추적하는 과정을 최대한 단순화 할 수 있음
        - 기능을 구성하는 코드 상호 간의 결합도와 의존성을 낮추는 효과 있음 ( 코드 품질 향상 )
    - 통합 테스트
      - 모듈 간의 상호작용 테스트 (백엔드 ↔ 데이터베이스, 컨트롤러 ↔ 서비스 ↔ 리포지터리 ↔ 데이터베이스)
      - 개별 코드를 결합한 기능이 잘 동작하는지 확인
    - 시스템 테스트
      - 전체적인 성능, 안정성, 보안 테스트
      - 사용자 입장에서 해당 기능이 제대로 동작하고 요구 사항에 부합하는지 확인
  - 테스트 주도 개발
    - 테스트 주도 개발(TDD)
      - red - 아직 구현되지 않은 기능에 대해 테스트를 작성하는 단계
      - green - red  단계에서 실패한 테스트를 통과시키기 위한 코드를 작성하는 단계 (통과가 목표)
      - refactoring - 테스트를 통과한 코드를 개선하는 단계 (코드의 품질 향상 목표)
      - 이 세 과정을 반복하며 개발 진행
    - 행동 주도 개발(BDD)
      - 사용자의 행동을 중심으로 테스트를 하는 개발 방법론
      - 사용자 스토리 → 사용자로서 이러한 기능을 원한다를 작성
      - Cucumber (행동 주도 개발 프레임워크) 를 사용해 테스트 코드 작성 (Feature, Scenario, Given(주어진 환경), When(행위), Then(기대결과))
  - CI/CD
    - CI/CD의 개념
      - CI - 소스 코드의 변경 사항을 자동으로 빌드 및 테스트해 통합하는 것
      - CD - 언제든지 배포 가능한 상태로 유지하는 것
    - CI/CD 도구
      - CI 도구
        - Jenkins - 가장 인기 있는 오픈 소스 CI 도구로, 다양한 플러그인 제공 → 기능 확장 가능
        - Github Actions - 깃허브에서 제공하는 자체 CI도구, 소스 코드가 변경되면 이를 감지하고 자동으로 빌드 및 테스트를 진행
        - Travis CI - 깃허브와 통합해 사용할 수 있는 CI도구, 설정이 간단하고 다양한 개발 언어 및 프레임워크 지원
        - CircleCI - 클라우드 기반의 CI 도구, 빠른 속도와 쉬운 설정, 유연한 확장성, 도커와 통합 가능
      - CD 도구
        - AWS CodeDeploy - 웹 애플리케이션의 배포를 자동화해 개발자가 빠르고 안정적으로 배포할 수 있음
      - CI / CD 도구
        - GitLab CI/CD - 통합 CI/CD 도구, 코드 저장소와 통합해 빌드-테스트-배포를 자동화함
        - Jenkins X - 쿠버네티스 위에서 동작하는 통합 CI/CD 도구, 클라우드 네이티브 애플리케이션의 빌드-테스트-배포를 자동화함
    - 데브옵스와 CI/CD 차이
      - 데브옵스는 문화와 프로세스에 중점
        - Development + Operation - 개발 팀과 운영 팀의 협력, 소통을 강조하는 문화와 방법론 의미 (개발 문화, 개발 조직, 개발 프로세스, 개발 도구 가 포함)
      - CI/CD는 도구와 자동화에 중점
        - 지속적인 통합과 지속적인 배포
        - 데브옵스를 실현하기 위한 구체적인 프로세스와 도구의 일부분
- Chapter11 백엔드 개발 총 정리
  - 프로젝트 소개
    - 프로젝트 생성 및 업로드 -  자바 + 스프링 부트 조합 / GitHub
    - 도커 파일 생성 및 서버 세팅 - AWS 서버 환경 세팅 및 도커 파일 작성
    - CI/CD 파이프라인 구축 및 배포 - GitHub Action
  - 프로젝트 생성 및 업로드 하기
    - 프로젝트 생성
      - Spring Initializr 사용
    - 디렉토리 구조 잡기
      - 개발할 API
        - 회원 조회: GET /api/v1/users
        - 회원 상태 변경: PATCH /api/v1/users/{id}/status
        - 상품 조회: GET /api/v1/products
        - 상품 추가: PUST /api/v1/products
        - 주문 내역 조회: GET /api/v1/orders

        ```
        src
        └─ main
           └─ java
              └─ com
                 └─ laze
                    └─ backendloadmap
                       ├─ config
                       └─ domain
                          ├─ user
                          │  ├─ controller
                          │  ├─ service
                          │  └─ dao
                          ├─ product
                          │  ├─ controller
                          │  ├─ service
                          │  └─ dao
                          └─ order
                             ├─ controller
                             ├─ service
                             └─ dao
        ```

      - config - 웹 애플리케이션의 설정 파일 또는 설정 관련 클래스 저장
      - domain - 웹 애플리케이션의 주요 도메인 모델을 구성하는 클래스 저장
        - controller - 클라이언트의 요청을 받아 처리하고 응답을 반환, service 객체의 메서드를 호출하고 결과를 반환하는 역할
        - service - 실질적인 비즈니스 로직 수행 후 결과를 controller에 전달
        - dao -  데이터베이스와의 통신을 담당하는 영역, service 계층으로부터 받은 요청에따라 DB 접근, 데이터 생성,조회,수정,삭제 후 service에 결과 데이터 반환
    - 데이터베이스와 연동하기
      - application.yml

          ```
          spring:
          datasource:
            url: jdbc:mysql://localhost:3306/db
            username: name
            password: pw
            driver-class-name: com.mysql.jdbc.Driver
          ```

    - API 구현하고 깃허브에 업로드하기
      - api 코드 구현하고 PostMan을 통해 API 요청 응답 테스트
      - github 업로드
  - 도커 파일 생성 및 서버 세팅하기
    - 도커 파일 작성하기
      - 루트 디렉토리에 Dockerfile 생성

        ```
        FROM eclipse-temurin:17-djk
        CMD ["./gradlew", "clean", "build"]
        ARG JAR_FILE_PATH=build/libs/server-0.0.1-SNAPSHOT.jar
        COPY ${JAR_FILE_PATH} app.jar
        ENTRYPOINT ["nohup", "java", "-jar", "app.jar", "2>&1", "&"]
        ```

      - FROM - 베이스 이미지
      - CMD - 컨테이너 시작 시 실행할 명령어
      - ARG - 도커 이미지 빌드 시 전달할 인수 정의
      - COPY - 호스트 → 컨테이너로 파일 복사
      - ENTRYPOINT - 컨테이너가 시작될 때 시작될 기본 실행 파일 정의
      - ENTRYPOINT 옵션 설명

        네, Dockerfile의 `ENTRYPOINT`에 사용된 `2>&1`과 `&`는 유닉스/리눅스 셸(Shell)에서 사용하는 표준적인 문법입니다. 각각 다음과 같은 역할을 합니다.

        1. **`2>&1` : 표준 에러(stderr)를 표준 출력(stdout)으로 리다이렉션(Redirection)**
          - **`2`**: 셸에서 **표준 에러(Standard Error)**를 나타내는 파일 디스크립터(File Descriptor) 번호입니다. 프로그램 실행 중 발생하는 오류 메시지가 주로 이쪽으로 출력됩니다.
          - **`1`**: 셸에서 **표준 출력(Standard Output)**을 나타내는 파일 디스크립터 번호입니다. 프로그램의 일반적인 결과 메시지가 이쪽으로 출력됩니다.
          - **`>`**: 리다이렉션(방향 재지정)을 의미하는 연산자입니다. `command > file`은 명령어의 표준 출력을 파일로 저장하라는 의미입니다.
          - **`&`**: 파일 디스크립터 번호를 명시적으로 사용하기 위해 붙입니다. `>&1`은 '파일 디스크립터 1번으로'라는 의미가 됩니다. (그냥 `>1`이라고 쓰면 '1'이라는 이름의 파일로 리다이렉션하라는 뜻이 됩니다.)

           따라서 `2>&1`은 **"표준 에러(2번)의 출력 방향을 표준 출력(1번)이 현재 가리키는 곳으로 동일하게 보내라"**는 의미입니다.

          - 이렇게 하는 주된 이유는 **표준 출력과 표준 에러 로그를 한 곳에서 같이 보거나 관리**하기 위함입니다. `nohup`과 함께 쓰일 때는 보통 `nohup.out` 파일에 표준 출력과 표준 에러가 모두 기록되도록 합니다. Docker 환경에서는 컨테이너 로그(`docker logs <container_id>`)에 표준 출력과 표준 에러가 모두 나타나도록 하는 효과가 있습니다.
        2. **`&` : 백그라운드(Background) 실행**
          - 명령어의 맨 끝에 `&`를 붙이면 해당 명령어를 **백그라운드에서 실행**하라는 의미입니다.
          - 즉, 셸은 해당 명령어를 실행시킨 후, 그 명령어의 종료를 기다리지 않고 즉시 다음 명령어를 받거나 프롬프트를 사용자에게 돌려줍니다.
          - `nohup` 명령어와 함께 사용되어 터미널 세션이 종료되더라도 프로세스가 계속 백그라운드에서 실행되도록 보장하는 데 자주 쓰입니다.

        **결론:**

        `ENTRYPOINT ["nohup", "java", "-jar", "app.jar", "2>&1", "&"]` 명령어는 다음과 같이 해석됩니다.

        1. `nohup java -jar app.jar`: `java -jar app.jar` 명령어를 실행하되, 터미널 세션이 끊어져도(hangup 신호를 받아도) 종료되지 않도록 합니다.
        2. `2>&1`: `java -jar app.jar` 명령어 실행 시 발생하는 표준 에러(stderr) 메시지를 표준 출력(stdout)이 나가는 곳으로 함께 보내도록 합니다. (`nohup`은 기본적으로 stdout을 `nohup.out` 파일로 리다이렉션하므로, 결국 stderr도 `nohup.out`으로 가게 됩니다. Docker 환경에서는 컨테이너 로그로 같이 출력됩니다.)
        3. `&`: 위의 `nohup ... 2>&1` 전체 명령어를 백그라운드에서 실행합니다.

        **Docker에서의 고려사항:**

        - Docker 컨테이너는 일반적으로 **포그라운드(Foreground)**에서 실행되는 주 프로세스가 종료되면 컨테이너 자체도 종료됩니다.
        - `ENTRYPOINT`나 `CMD`에서 `&`를 사용하여 주 애플리케이션을 백그라운드로 돌리는 것은 Docker의 일반적인 사용 패턴과는 약간 다릅니다. 이렇게 하면 `nohup` 프로세스 자체는 포그라운드에서 실행될 수 있지만, 실제 `java` 애플리케이션은 백그라운드로 실행됩니다. 만약 `nohup` 프로세스가 어떤 이유로든 즉시 종료되면 컨테이너가 바로 멈출 수 있습니다.
        - 대부분의 경우 Docker 컨테이너에서는 `nohup`과 `&` 없이 단순히 `ENTRYPOINT ["java", "-jar", "app.jar"]` 와 같이 애플리케이션을 포그라운드로 실행하고, 로그는 Docker 데몬이 표준 출력/표준 에러를 수집하도록 하는 것이 더 일반적이고 권장되는 방식입니다. 컨테이너를 백그라운드로 실행하고 싶다면 `docker run -d` 옵션을 사용합니다.
    - AWS 서버 세팅하기
      - EB(Elastic Beanstalk) PaaS → 서버 인프라 및 플랫폼 제공하는 서비스
        - 웹 애플리케이션 실행에 필요한 인프라 자동으로 프로비저닝(**필요한 IT 인프라 자원을 사용할 수 있도록 준비하고 설정하는 과정)**
        - 웹 애플리케이션 실행에 필요한 환경 제공(컨테이너)
        - 배포 프로세스 자동화(CD 기능 포함)
        - 모니터링과 로그 수집 기능 제공
        - 다른 AWS 서비스화 통합 가능 (Amazon RDS, S3 등)
    - AWS 인증 키 발급받기
      - IAM
        - 액세스 키, 비밀 액세스 키 발급
  - CI/CD 파이프라인 구축 및 배포하기
    - 깃 허브 저장소에 환경 변수 등록하기
      - Settings - Security - Secrets and variables - Actions - New repository secret 에서 등록
        - AWS_ACCESS_KEY_ID: AWS_IAM_ACCESS_KEY_ID
        - AWS_SECRET_ACCESS_KEY: AWS_IAM_SECRET_ACCESS_KY
        - DOCKERHUB_USERNAME: DOCKERHUB_ID
        - DOCKERHUB_TOKEN: DOKCERHUB_PASSWORD
    - 워크플로 파일 작성하기
      - devleop 브랜치에 대한 CI/CD 파이프라인 워크플로 작성

        ```
        dev-ci-cd.yml
        
        name: dev CI/CD
        
        on:
          push:
            branches: [ develop ]
            
        jobs:
          dev-ci-cd:
            runs-on: ubuntu-latest
            steps:
              - name: Checkout Latest Repo
                uses: actions/checkout@v3
                
              - name: Set up JDK 17
                uses: actions/setup-java@v3
                with:
                  java-version: '17'
                  distribution: 'temurin'
              
              - name: Grant execute permission for gradlew
                run: chmod +x gradlew
              
              - name: Build with Gradle
                run: ./gradlew clean build
              
              - name: Docker build
                run: |
                  docker login -u ${{ secrets.DOCKERHUB_USERNAME }} -p ${{ secrets.DOCKERHUB_TOKEN }}
                  docker build -t sluv-springboot-main-cicd .
                  docker tag sluv-springboot-main-cicd sluv2323/
                    sluv-springboot-main-cicd:latest
                  docker push sluv2323/sluv-springboot-main-cicd:latest
                  
              - name: Get timestamp
                uses: gerred/actions/current-time@master
                id: current-time
                
              - name: Run string replace
                uses: frabert/replace-string-action@master
                id: format-time
                with:
                  pattern: '[:\.]+'
                  string: "${{ steps.current-time.outputs.time }}"
                  replace-with: '-'
                  flags: 'g'
                  
              - name: Beanstalk Deploy
                uses: einaregilsson/beanstalk-deploy@v21
                with:
                  aws_access_key: ${{ secrets.AWS_ACCESS_KEY_ID }}
                  aws_secret_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
                  application_name: sluv-dev
                  environment_name: Sluvdev-env
                  version_label: "github-actions--${{ steps.format-time.outputs.replaced }}"
                  region: ap-northeast-2
                  deployment_package: Dockerrun.aws.json
                  wait_for_environment_recovery: 180
        ```

      - 설명

        네, 이 `dev-ci-cd.yml` 파일은 GitHub Actions 워크플로우를 정의하는 파일입니다. 특정 이벤트가 발생했을 때 GitHub 서버(Runner)에서 자동으로 실행될 작업들을 순서대로 명시해 놓은 것입니다. 이 파일의 내용을 단계별로 자세히 설명해 드릴게요.

        **파일 요약:**

        이 워크플로우는 `develop` 브랜치에 코드가 푸시(push)될 때마다 자동으로 실행됩니다. 주된 역할은 다음과 같습니다.

        1. **CI (Continuous Integration - 지속적 통합):**
          - 코드를 가져옵니다 (Checkout).
          - Java 17 개발 환경을 설정합니다.
          - Gradle 빌드 도구를 사용하여 프로젝트를 빌드합니다 (컴파일, 테스트 포함 가능).
        2. **CD (Continuous Deployment - 지속적 배포):**
          - 빌드된 애플리케이션을 포함하는 Docker 이미지를 생성합니다.
          - 생성된 Docker 이미지를 Docker Hub (컨테이너 이미지 저장소)에 푸시합니다.
          - 방금 푸시한 Docker 이미지를 AWS Elastic Beanstalk의 개발 환경(`Sluvdev-env`)에 배포합니다.

        **단계별 상세 설명:**

        1. **`name: dev CI/CD`**
          - 이 워크플로우의 이름을 "dev CI/CD"로 지정합니다. GitHub Actions 탭에서 이 이름으로 표시됩니다.
        2. **`on:`**
          - 워크플로우가 **언제** 실행될지를 정의하는 트리거(trigger) 설정입니다.
          - `push: branches: [ develop ]`: `develop` 브랜치에 `push` 이벤트가 발생할 때마다 이 워크플로우를 실행합니다.
        3. **`jobs:`**
          - 워크플로우에서 실행될 하나 이상의 **작업(job)**들을 정의합니다. 작업들은 병렬 또는 순차적으로 실행될 수 있습니다.
          - `dev-ci-cd:`: 이 워크플로우에는 `dev-ci-cd`라는 이름의 작업 하나만 정의되어 있습니다.
        4. **`runs-on: ubuntu-latest`**
          - `dev-ci-cd` 작업이 실행될 가상 환경(Runner)을 지정합니다. 여기서는 GitHub에서 제공하는 최신 버전의 Ubuntu 리눅스 환경을 사용합니다.
        5. **`steps:`**
          - `dev-ci-cd` 작업 내에서 순차적으로 실행될 **단계(step)**들을 정의합니다.
          - **`name: Checkout Latest Repo`**
            - `uses: actions/checkout@v3`: 미리 만들어진 GitHub Action(`actions/checkout`) 버전 3을 사용합니다.
            - **역할:** 현재 워크플로우가 실행되는 리포지토리의 최신 코드를 Runner 환경으로 가져옵니다 (checkout). `develop` 브랜치의 코드가 받아집니다.
          - **`name: Set up JDK 17`**
            - `uses: actions/setup-java@v3`: Java 환경 설정 Action 버전 3을 사용합니다.
            - `with:`: Action에 필요한 파라미터를 전달합니다.
              - `java-version: '17'`: JDK 버전을 17로 설정합니다.
              - `distribution: 'temurin'`: JDK 배포판으로 'temurin'(Eclipse Temurin)을 사용합니다.
            - **역할:** 이후 단계에서 Gradle 빌드를 위해 필요한 Java 17 환경을 Runner에 준비합니다.
          - **`name: Grant execute permission for gradlew`**
            - `run: chmod +x gradlew`: Runner에서 셸 명령어를 직접 실행합니다.
            - **역할:** `gradlew` (Gradle Wrapper 실행 스크립트) 파일에 실행 권한을 부여합니다. Linux 환경에서는 파일에 실행 권한이 있어야 직접 실행할 수 있습니다.
          - **`name: Build with Gradle`**
            - `run: ./gradlew clean build`: `gradlew` 스크립트를 사용하여 Gradle 빌드를 실행합니다.
              - `clean`: 이전 빌드 결과물(보통 `build` 폴더)을 삭제합니다.
              - `build`: 소스 코드를 컴파일하고, 테스트를 실행하며, 애플리케이션을 패키징합니다 (보통 `.jar` 또는 `.war` 파일 생성). 이 과정에서 의존성 라이브러리도 다운로드합니다.
            - **역할:** 프로젝트 코드를 빌드하여 실행 가능한 애플리케이션 아티팩트(artifact)를 생성합니다. CI의 핵심 단계입니다.
          - **`name: Docker build`**
            - `run: |`: 여러 줄의 셸 명령어를 실행합니다.
              - `docker login -u ${{ secrets.DOCKERHUB_USERNAME }} -p ${{ secrets.DOCKERHUB_TOKEN }}`: GitHub 리포지토리 설정의 Secrets에 저장된 Docker Hub 사용자 이름과 토큰을 사용하여 Docker Hub에 로그인합니다. (Secrets는 민감한 정보를 안전하게 관리하는 방법입니다.)
              - `docker build -t sluv-springboot-main-cicd .`: 현재 디렉토리( `.` )에 있는 `Dockerfile`을 사용하여 Docker 이미지를 빌드하고, 이미지 이름을 `sluv-springboot-main-cicd`로 태그합니다. (**주의:** 이 단계가 성공하려면 리포지토리 루트에 `Dockerfile`이 있어야 합니다.)
              - `docker tag sluv-springboot-main-cicd sluv2323/sluv-springboot-main-cicd:latest`: 방금 빌드한 이미지에 새로운 태그를 추가합니다. Docker Hub에 푸시하려면 `<사용자명>/<이미지명>:<태그>` 형식이어야 합니다. 여기서는 `sluv2323` 사용자의 `sluv-springboot-main-cicd` 이미지에 `latest` 태그를 붙입니다.
              - `docker push sluv2323/sluv-springboot-main-cicd:latest`: 태그된 이미지를 Docker Hub로 푸시(업로드)합니다.
            - **역할:** 빌드된 애플리케이션을 포함하는 Docker 이미지를 만들고, 이를 나중에 배포할 수 있도록 Docker Hub에 저장합니다.
          - **`name: Get timestamp`**
            - `uses: gerred/actions/current-time@master`: 외부 Action을 사용하여 현재 시간을 가져옵니다.
            - `id: current-time`: 이 단계의 ID를 `current-time`으로 지정하여 나중에 출력값을 참조할 수 있게 합니다.
            - **역할:** 배포 버전을 구분하기 위한 고유한 타임스탬프를 얻습니다.
          - **`name: Run string replace`**
            - `uses: frabert/replace-string-action@master`: 외부 Action을 사용하여 문자열 치환을 수행합니다.
            - `id: format-time`: 이 단계의 ID를 `format-time`으로 지정합니다.
            - `with:`:
              - `pattern: '[:\\.]+'`: 콜론(`:`) 이나 점(`.`) 문자를 찾습니다.
              - `string: "${{ steps.current-time.outputs.time }}"`: 입력 문자열로 이전 단계(`current-time`)에서 얻은 시간 값을 사용합니다.
              - `replace-with: '-'`: 찾은 문자를 하이픈()으로 바꿉니다.
              - `flags: 'g'`: 문자열 전체에서 모든 일치 항목을 바꿉니다.
            - **역할:** 타임스탬프 문자열에서 Elastic Beanstalk 버전 레이블에 사용할 수 없는 특수 문자(`:`, `.`)를 하이픈()으로 변경하여 포맷합니다.
          - **`name: Beanstalk Deploy`**
            - `uses: einaregilsson/beanstalk-deploy@v21`: AWS Elastic Beanstalk 배포를 위한 외부 Action 버전 21을 사용합니다.
            - `with:`: 배포에 필요한 파라미터들을 설정합니다.
              - `aws_access_key`, `aws_secret_key`: AWS 접근 키와 시크릿 키를 GitHub Secrets에서 가져옵니다. AWS에 배포할 권한을 얻기 위해 필요합니다.
              - `application_name: sluv-dev`: 배포할 Elastic Beanstalk 애플리케이션의 이름을 지정합니다.
              - `environment_name: Sluvdev-env`: 배포할 대상 환경의 이름을 지정합니다. (개발 환경)
              - `version_label: "github-actions--${{ steps.format-time.outputs.replaced }}"`: 배포될 애플리케이션 버전에 고유한 레이블을 붙입니다. 포맷된 타임스탬프를 사용하여 매번 다른 레이블이 생성됩니다.
              - `region: ap-northeast-2`: Elastic Beanstalk 환경이 위치한 AWS 리전(서울)을 지정합니다.
              - `deployment_package: Dockerrun.aws.json`: **매우 중요.** Elastic Beanstalk에 배포할 패키지를 지정합니다. Docker 배포의 경우, 이 파일은 어떤 Docker 이미지를 가져와서 어떻게 실행할지 (예: 포트 매핑 등)를 정의하는 JSON 파일입니다. 이 파일은 이전 단계에서 Docker Hub에 푸시한 `sluv2323/sluv-springboot-main-cicd:latest` 이미지를 사용하도록 설정되어 있을 것입니다. (**주의:** 이 단계가 성공하려면 리포지토리 루트에 `Dockerrun.aws.json` 파일이 있어야 합니다.)
              - `wait_for_environment_recovery: 180`: 배포 후 환경 상태가 완전히 복구될 때까지 최대 180초(3분) 동안 기다립니다.
            - **역할:** Docker Hub에 푸시된 최신 버전의 Docker 이미지를 사용하여 AWS Elastic Beanstalk 개발 환경에 애플리케이션을 자동으로 배포합니다. CD의 핵심 단계입니다.

        **결론적으로, 이 워크플로우는 `develop` 브랜치에 변경 사항이 푸시될 때마다 자동으로 코드를 빌드하고, Docker 이미지를 만들어 Docker Hub에 올린 다음, 그 이미지를 AWS Elastic Beanstalk 개발 서버에 배포하는 전체 CI/CD 파이프라인을 자동화합니다.**

    - Dockerrun.aws.json 파일 작성하기
      - 깃허브 액션을 통해 도커 이미지를 도커 허브로 업로드할 때 작성해야함
      - EB에 도커 이미지 빌드, 실행 방법에 관한 정보 제공
      - 스프링 부트 프로젝트 루트 경로(src)에 생성

        ```
        {
          "AWSEBDockerrunVersion": "1",
          "Image": {
            "Name": "sluv2323/sluv-springboot-main-cicd:latest",
            "Update": "true"
          },
          "Ports": [
            {
              "ContainerPort": 8080,
              "HostPort": 5000
            }
          ]
        }
        ```

    - 배포 확인하기

      소스 추가 및 병합시 명시된 작업(jobs)이 지정된 단계(steps)에 따라 자동으로 빌드 - 테스트 - 배포 되는지 확인


Part3 백엔드 전문가로 성장하기

- Chapter12 백엔드 커리어 설계하기
  - 백엔드 개발자
    - API 개발해 프론트엔드 요청 처리
    - DB 설계 및 백엔드 개발 로직과 연동
    - hard skill
      - 개발 언어, 프레임워크, 라이브러리, 개발 방법론 등 직무 역량
    - soft skill
      - 협업 역량 (커뮤니케이션, 배우는 자세, 유연한 사고, 책임감, 주도적인 자세)
    - 주니어 (0~3년차) - 개발 언어, 프레임워크, 라이브러리를 사용해 트러블 슈팅을 할 수 있는 수준
    - 미들급 (3~7년차) - 프로젝트 매니저, 기획자 등의 직군과 개발 관련 지식을 바탕으로 회의할 수 있는 수준
    - 시니어 개발자 (7 ~10년차 이상) - 개발 중인 웹 애플리케이션의 산업군(이커머스, 금융 등)에 대한 도메인 지식을 갖추고 프로젝트 전체를 관리하는 수준
  - 아키텍트
    - 웹 애플리케이션의 전체 구조를 설계하는 사람
      - 개발하려는 웹 애플리케이션 분야의 특징과 사용자 요구 사항을 분석해 그 결과에 맞게 설계
      - 설계에 따라 개발에 사용할 기술 결정
      - 개발이 설계되로 진행되고 있는지 코드 품질 및 프로젝트 관리 수행
    - 시스템 아키텍트 - 기업 전체의 IT 시스템 설계 및 구현을 담당, 하드웨어, 소프트웨어, 네트워크 등의 기술 이해하고, 전체 시스템이 비즈니스 목표를 효율적으로 달성할 수 있도록 지원
    - 백엔드 아키텍트 - 백엔드 시스템을 설계하고 개발, 시스템의 성능, 안정성, 보안 등을 책임짐
    - 솔루션 아키텍트 - 특정 비즈니스 문제를 해결하기 위한 솔루션을 설계하고 구현, 비즈니스 요구사항을 이해하고 적절한 기술 솔루션을 제시함으로써 요구 사항을 실현하는 역할
  - DBA
    - 데이터베이스 설계, 구현, 유지보수, 보안 등의 업무 수행
      - 개발하려는 웹 애플리케이션 분야의 특징과 사용자 요구사항 분석 → 데이터베이스로 구현
      - 기존 DB의 비효율적 작동 방식이나 설계를 찾아내고 성능 개선 및 모니터링
      - 다양한 상황에 대비해 백업, 복구, 버전업 등의 작업 수행 → DB의 무결성과 가용성 유지
    - 데이터 엔지니어 - 기업이 수집하는 대량의 데이터를 관리하고 구조화함, 데이터가 원활하게 입출력될 수 있도록 파이프라인 설계, 구축
    - 데이터 분석가 - 수집된 데이터를 분석해 큰 규모의 의사 결정에 도움이 되는 지표나 근거 등의 인사이트 제공, 통계 방법론, 데이터  시각화 도구, 데이터 분석 특화 언어(R)사용
  - 데브옵스 엔지니어
    - 프로젝트에 참여하는 개발 팀과 운영 팀이 협력할 수 있도록 소프트웨어 개발의 생명주기 전반에 걸쳐 관여
      - 코드 배포 자동화
      - 전반적인 개발 인프라 자동화
      - CI/CD 유지보수, 서버 상태 모니터링 및 로깅
    - 클라우드 아키텍트 - 웹 애플리케이션의 인프라 구축, 인프라 자동화 등에 적용되는 클라우드 컴퓨팅 기술 전반을 책임짐
    - 시스템 아키텍트 - 기업 전체의 IT 시스템 설계 및 구현 담당
    - 마이크로서비스 아키텍트 - 프로젝트의 복잡한 요구사항을 작은 단위의 서비스로 분해하도록 아키텍처를 설계하고 구현
  - 프로젝트 매니저
    - 웹 애플리케이션 전체의 생명 주기를 관리, 아이디어 수집,선별 → 개발, 출시, 유지 관리등 모든 단계에 대한 책임
      - 개발할 애플리케이션의 비전과 전략 수립 → 로드맵으로 변환 (시장 조사, 경쟁 제품 분석, 고객 인터뷰)
      - 고객의 요구사항, 비즈니스 목표, 기술적 한계 고려해 요구사항 식별 및 정의, 우선순위에 따라 정렬
      - 도출된 요구사항을 바탕으로 개발의 방향성 조정 및 소통 중재
      - 출시 이후에는 성과를  측정하고 분석해 지표화함
  - 풀스택 개발자
    - 프론트엔드 개발과 백엔드 개발 업무를 모두 수행
    - 분리되어 있는 경우 양측 개발자 간의 커뮤니케이션 간극을 줄이는 역할
  - CTO
    - 기술과 관련된 활동을 총괄하고 최종 의사 결정을 내리는 역할
      - 웹 애플리케이션 개발을 위한 아키텍처 전략 설정 (기본적 구조, 필요한 철학, 규칙 등)
      - 개발 기술에 관한 지식 + 프로젝트 관리에 관한 지식
      - 사업 아이템에 기술을 적용해 시장의 니즈를 충족할 수 있는 방향성을 제시해야 함
