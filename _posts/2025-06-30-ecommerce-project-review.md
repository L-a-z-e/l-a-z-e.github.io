---
title: E-Commerce Project Review
description: 
author: laze
date: 2025-06-30 00:00:03 +0900
categories: [Dev, SpringBoot]
tags: [SpringBoot]
---
다음의 목표를 가지고 토이 프로젝트 진행
### **Phase 1: 기반 다지기 (Core E-Commerce)**

- **목표:** 기본적인 상품 등록, 조회, 장바구니, 주문 기능이 동작하는 API와 화면을 만든다.
- **주요 작업:**
  1. **요구사항 정의 및 DB 설계:** 사용자, 상품, 주문, 장바구니 간의 관계를 정의하고 ERD(Entity-Relationship Diagram)를 그립니다.
  2. **Spring Boot 프로젝트 설정:** JPA, Spring Security (기초적인 인증/인가), H2 (초기 개발용 인메모리 DB) 또는 PostgreSQL/MySQL을 설정합니다.
  3. **핵심 API 개발:** 상품 CRUD, 회원가입/로그인, 장바구니 추가/조회/삭제, 주문 생성 API를 개발합니다.
  4. **Vue.js 화면 개발:** 위 API와 연동되는 기본적인 상품 목록, 상세, 장바구니 페이지를 만듭니다.
- **학습 포인트:** 복잡한 도메인 모델링, RESTful API 심화 설계, JPA N+1 문제 등 성능 이슈에 대한 기초 이해.

### **Phase 2: 검색 기능 강화 (Elasticsearch)**

- **목표:** SQL의 LIKE 검색을 넘어, 빠르고 정확한 전문(Full-text) 검색 기능을 도입한다.
- **주요 작업:**
  1. **Elasticsearch 학습 및 설치:** Elasticsearch가 왜 필요한지, 기본 개념(인덱스, 문서)은 무엇인지 학습합니다. 로컬 환경에 Docker를 이용해 간단히 설치합니다.
  2. **데이터 동기화:** Spring Boot에서 상품 데이터가 추가/수정될 때마다 Elasticsearch에도 자동으로 반영(인덱싱)되도록 구현합니다.
  3. **검색 API 개발:** 기존의 상품 검색 API를 Elasticsearch를 사용하도록 교체합니다.
- **학습 포인트:** **Elasticsearch의 필요성 및 기본 원리 이해**, Spring Data Elasticsearch를 활용한 연동 방법.

### **Phase 3: 개인화 기반 마련 (Data Collection & Basic Recommendation)**

- **목표:** 사용자의 행동(조회, 클릭) 데이터를 수집하고, 이를 바탕으로 한 가장 기초적인 추천 기능을 구현한다.
- **주요 작업:**
  1. **사용자 행동 로그 수집:** 사용자가 특정 상품을 조회할 때마다 (사용자 ID, 상품 ID, 시간) 정보를 로그 테이블에 기록하는 API를 개발합니다.
  2. **기초 추천 로직 구현:** **"이 상품을 본 다른 사용자가 함께 본 상품"** 기능을 구현합니다. 이는 복잡한 ML 없이 SQL 쿼리나 간단한 로직으로도 구현 가능하며, 추천 시스템의 첫걸음으로 적합.
  3. **추천 API 개발 및 UI 연동:** 상품 상세 페이지에 위 로직으로 계산된 추천 상품 목록을 보여줍니다.
- **학습 포인트:** 서비스에 필요한 데이터가 무엇인지 정의하고 수집하는 방법, 데이터를 가공하여 가치를 만드는 경험.

### **Phase 4: 세상에 내놓기 (AWS & CI/CD)**

- **목표:** 내 컴퓨터에서만 돌아가던 프로젝트를 클라우드에 배포하여 누구나 접속할 수 있게 만든다.
- **주요 작업:**
  1. **AWS 기본 서비스 학습:** EC2(가상 서버), RDS(관계형 데이터베이스), S3(파일 저장소)의 개념을 학습합니다.
  2. **인프라 구축:** AWS에 RDS 인스턴스를 생성하고, EC2 인스턴스를 생성하여 Spring Boot 애플리케이션을 배포합니다.
  3. **CI/CD 파이프라인 구축:** GitHub Actions을 이용하여, 코드가 main 브랜치에 푸시될 때마다 자동으로 테스트, 빌드, EC2에 배포되도록 파이프라인을 작성합니다.
- **학습 포인트:** **클라우드 환경에서의 애플리케이션 배포 전체 사이클 경험.**
- 
### **프로젝트 종합 복습: 핵심 키포인트 정리**

### **Phase 1: 기반 다지기 및 핵심 기능 구현 (Architecture & Backend)**

**목표:** 아이디어를 구체적인 설계로 옮기고, 동작하는 백엔드 API의 뼈대를 완성한다.

- **1. 데이터베이스 설계 (ERD):**
  - **키포인트:** 단순히 테이블을 나열하는 것을 넘어, **테이블 간의 관계(1:N, N:M)를 명확히 정의**하는 것이 핵심. `orders`와 `products`의 N:M 관계를 해결하기 위해 `order_items`라는 중간 테이블을 두는 **정규화** 과정이 매우 중요했다.
- **2. ORM과 엔티티 모델링 (JPA & Hibernate):**
  - **키포인트:** `@Entity`는 DB 테이블의 '설계도'이며, `@Id`, `@GeneratedValue`, `@Column` 같은 어노테이션으로 세부 규칙을 정한다. **`@ManyToOne`, `@OneToMany`*를 통해 객체 세상의 관계와 DB 세상의 외래 키(FK)를 연결했다.
  - **핵심 경험:** **`cascade` (영속성 전이)**와 **`orphanRemoval` (고아 객체 제거)** 옵션을 통해, 부모 엔티티(`Order`)만 관리해도 자식 엔티티(`OrderItem`)가 알아서 처리되는 객체지향적인 설계를 경험했다.
- **3. 리포지토리와 서비스 계층 분리:**
  - **키포인트:** **`Controller` (요청 접수) → `Service` (비즈니스 로직) → `Repository` (데이터 처리)**로 역할을 명확히 분리했다. 이를 통해 코드가 훨씬 더 깔끔해지고, 테스트와 유지보수가 용이해졌다.
  - **핵심 경험:** **더티 체킹(Dirty Checking)**의 마법. `@Transactional` 환경에서는, 조회한 엔티티의 상태만 변경하면 JPA가 알아서 `UPDATE` 쿼리를 날려준다는 것을 배웠다. `save()`는 새로운 객체를 저장할 때만 사용한다.
- **4. 인증/인가 시스템 구축 (Spring Security & JWT):**
  - **키포인트:** **인증(Authentication, 누구인가?)**과 **인가(Authorization, 무엇을 할 수 있는가?)**는 다르다. 우리는 JWT를 통해 이 둘을 모두 구현했다.
  - **핵심 경험:** JWT 페이로드에 `email`뿐만 아니라 **`role`(역할)을 포함**시켜야만, 토큰 자체만으로 사용자의 권한을 판단할 수 있는 **Stateless** 시스템이 완성된다는 것을 깨달았다. `JwtAuthenticationFilter`는 이 정보를 읽어 보안 컨텍스트에 등록하는 역할을 했다.

### **Phase 2: 기능 고도화 (Elasticsearch 검색 엔진 연동)**

**목표:** RDBMS의 한계를 이해하고, 검색 전문 도구를 연동하여 서비스의 질을 높인다.

- **1. 이기종 데이터 아키텍처:**
  - **키포인트:** 주 데이터 저장소(PostgreSQL)와 검색/분석용 저장소(Elasticsearch)의 **역할을 분리**했다. 모든 것을 하나의 DB로 해결하려 하지 않는 것이 현대적인 아키텍처의 핵심이다.
- **2. 데이터 동기화:**
  - **키포인트:** **원본 데이터(Source of Truth)는 항상 RDBMS(PostgreSQL)**에 있다. 상품이 생성/수정될 때, 이 원본 데이터를 기반으로 검색에 필요한 데이터만 가공하여 Elasticsearch에 **인덱싱(Indexing)**하는 파이프라인을 구축했다.
- **3. 네이티브 기능 활용의 어려움과 해결:**
  - **핵심 경험:** JPA 환경에서 `JSONB`나 `Full-text search` 같은 **데이터베이스 고유의 기능**을 사용하려 할 때, JPA의 자동 번역 기능의 한계(`Unknown Types value`, `column name not found`)에 부딪혔다.
  - **해결 과정:** **`nativeQuery=true`*와 **SQL 별칭(Alias)** 또는 **`@SqlResultSetMapping`*을 사용하여, DB 컬럼명과 엔티티 필드명을 명시적으로 매핑해주는 것이 가장 확실한 해결책임을 배웠다.

### **Phase 3: 개인화 기반 마련 (추천 시스템)**

**목표:** 사용자 행동 데이터를 수집하고, 이를 가공하여 새로운 가치를 창출하는 경험을 한다.

- **1. 데이터 수집의 중요성:**
  - **키포인트:** 모든 개인화와 추천의 시작은 **'로그(Log) 수집'**이다. 우리는 `product_view_logs` 테이블을 만들어 사용자의 모든 상품 조회 기록이라는 원재료를 쌓기 시작했다.
- **2. SQL을 이용한 데이터 분석:**
  - **핵심 경험:** 복잡한 머신러닝 없이도, 순수한 **SQL(JOIN, GROUP BY, COUNT, ORDER BY)**만으로도 "함께 본 상품"과 같은 의미 있는 비즈니스 인사이트를 추출하고, 이를 추천 기능으로 구현할 수 있다는 것을 배웠다.
- **3. 사용자 경험으로의 연결:**
  - **키포인트:** 백엔드에서 가공된 데이터를 API로 제공하고, 프론트엔드에서는 이를 받아 사용자에게 **'가치 있는 제안'**의 형태로 보여주었다. 이것이 바로 데이터 기반 서비스의 가장 기본적인 사이클이다.

### **Phase 4: 세상에 내놓기 (AWS 배포 및 CI/CD)**

**목표:** 내 컴퓨터를 벗어나, 실제 클라우드 환경에 서비스를 배포하고 운영하는 경험을 한다.

- **1. 클라우드 인프라 구축 (IaaS):**
  - **키포인트:** **EC2(서버), RDS(데이터베이스), S3(스토리지)** 등 각기 다른 역할을 하는 AWS 서비스들을 조합하여 애플리케이션이 동작할 수 있는 인프라를 직접 구축했다.
  - **핵심 경험:** **보안 그룹(Security Group)**은 클라우드의 핵심적인 '방화벽'이다. **EC2와 RDS가 서로 통신**하려면, RDS의 보안 그룹 인바운드 규칙에 EC2의 보안 그룹을 소스로 등록해주어야 한다는 네트워크의 기본 원리를 체득했다.
- **2. 개발 환경과 운영 환경의 차이:**
  - **핵심 경험:** `.jar` 파일에는 코드만 포함될 뿐, `.env` 같은 **환경 의존적인 설정 파일은 포함되지 않는다.** 따라서 실제 서버 환경에 맞는 `.env` 파일을 직접 서버에 생성하고, 애플리케이션 실행 시 `D` 옵션 등으로 해당 설정을 읽도록 지정해주어야 한다는 배포의 핵심 원리를 배웠다.
- **3. CI/CD 자동화 (GitHub Actions):**
  - **키포인트:** **빌드-테스트-배포**로 이어지는 반복적인 작업을 자동화했다. `main` 브랜치에 코드를 `push`하는 것만으로 모든 배포가 완료되는 파이프라인을 구축했다.
  - **핵심 경험:** GitHub 레포지토리의 **Secrets** 기능을 사용하여, AWS 액세스 키와 같은 민감한 정보를 코드에 노출하지 않고 안전하게 자동화 스크립트에서 사용하는 방법을 익혔다.

---
