---
title: Marker Interface의 역할과 책임 분석
description: 
author: laze
date: 2025-07-07 00:00:01 +0900
categories: [Dev, Java]
tags: [Java]
---
# Marker Interface의 역할과 책임 분석

## 1. 개요

Java 언어에서 마커 인터페이스(Marker Interface)는 아무런 메서드를 선언하지 않은, 비어 있는 인터페이스를 지칭한다.
대표적인 예로 `java.io.Serializable`, `java.lang.Cloneable`이 있다.
이 인터페이스들은 구현 클래스에 특정 기능을 추가하지 않는다.
대신, JVM이나 프레임워크에 해당 클래스가 특정 속성을 가지거나 특별한 방식으로 처리되어야 함을 알리는 '표식'으로 기능한다.

주요 마커 인터페이스의 존재 이유와, 이를 구현하는 개발자가 져야 할 기술적 책임에 대해 분석해보는 것이 목표이다.

## 2. 마커 인터페이스의 존재 이유: 'Opt-in' 정책과 타입 안정성

마커 인터페이스의 핵심 설계 사상은 **명시적 동의(Opt-in)**에 기반한 타입 안정성 확보다.

특정 기능(직렬화, 복제 등)을 모든 객체에 기본적으로 허용하는 대신, 개발자가 해당 기능에 대한 안정성을 보증하고 의도를 명시한 클래스에 한해서만 기능을 활성화한다.

이는 특정 기능이 모든 객체에 적합하지 않다는 전제에서 출발한다.

- **직렬화(Serialization):** 데이터베이스 커넥션, 스레드, 소켓 등과 같이 상태를 보존할 수 없거나 보안상 민감한 데이터를 포함한 객체는 직렬화에 부적합하다.
- **복제(Cloning):** 객체가 복잡한 참조 구조를 가질 경우, 단순한 필드 복사(얕은 복사)는 데이터 무결성을 해칠 수 있다.

마커 인터페이스는 이러한 기능적 제약을 타입 시스템을 통해 관리한다.

JVM이나 관련 API는 대상 객체가 특정 마커 인터페이스의 인스턴스인지(`instanceof`) 런타임에 확인하여,

조건에 부합하지 않을 경우 예외(`NotSerializableException`, `CloneNotSupportedException`)를 발생시켜 예기치 않은 동작을 차단한다.

## 3. 주요 마커 인터페이스와 개발자의 책임

마커 인터페이스를 구현하는 행위는 단순히 표식을 붙이는 것을 넘어, 해당 기능의 동작 방식과 제약사항을 이해하고 그에 따른 책임을 다하겠다는 계약과 같다.

### 3.1. `java.io.Serializable`

- **목적:** 해당 객체가 JVM 직렬화 메커니즘을 통해 바이트 스트림으로 변환될 수 있음을 명시한다.
- **개발자의 책임:**
  1. **필드 선별 (`transient`):** 직렬화 대상에서 제외해야 할 필드(비밀번호, DB 커넥션)에 `transient` 키워드를 명시해야 한다. 이를 누락할 경우, 민감 정보가 노출되거나 역직렬화 시 `null`이 아닌 유효하지 않은 상태를 유발할 수 있다.
  2. **버전 관리 (`serialVersionUID`):** 클래스의 변경에 따른 직렬화 호환성 문제를 제어하기 위해 `private static final long serialVersionUID`를 명시적으로 선언하고 관리해야 한다. 미선언 시, 사소한 클래스 변경만으로도 역직렬화 과정에서 `InvalidClassException`이 발생하여 시스템 장애로 이어질 수 있다.

### 3.2. `java.lang.Cloneable`

- **목적:** `Object.clone()` 메서드의 사용을 허가함을 명시한다.
- **개발자의 책임:**
  1. **`clone()` 메서드 재정의:** `Object.clone()`은 `protected` 접근 제어자를 가지므로, 외부에서 사용 가능하도록 `public`으로 재정의해야 한다.
  2. **복사 방식 결정 (Shallow vs. Deep Copy):** `Object.clone()`은 필드 값만 복사하는 **얕은 복사(Shallow Copy)**를 수행한다. 만약 클래스가 다른 객체에 대한 참조를 필드로 포함하고 있다면, 개발자는 반드시 `clone()` 메서드 내에서 해당 참조 객체를 새로 생성하여 할당하는 **깊은 복사(Deep Copy)** 로직을 직접 구현해야 한다. 이 책임을 이행하지 않을 경우, 원본 객체와 복제된 객체가 내부 상태를 공유하게 되어 데이터 불일치 및 예측 불가능한 버그를 유발한다.

    ```java
    // 깊은 복사 책임 이행 예시
    @Override
    public User clone() throws CloneNotSupportedException {
        User cloned = (User) super.clone();
        cloned.setAddress(new Address(this.address.getCity())); // 참조 필드 재성성
        return cloned;
    }
    ```


### 3.3. `java.rmi.Remote`

- **목적:** 해당 인터페이스를 구현한 객체가 RMI(Remote Method Invocation)의 대상이 될 수 있음을 명시한다.
- **개발자의 책임:**
  1. **`RemoteException` 처리 강제:** `Remote`를 상속하는 인터페이스의 모든 메서드는 `java.rmi.RemoteException`을 `throws` 절에 선언해야 한다. 이는 원격 호출이 네트워크 지연, 서버 장애 등 본질적인 실패 가능성을 내포하고 있음을 컴파일 타임에 강제하는 것이다. 개발자는 이 규칙을 통해 원격 호출의 불안정성을 인지하고, 호출부에서 반드시 예외 처리 로직을 구현하도록 유도된다.

## 4. 요약 및 결론

마커 인터페이스는 Java의 타입 시스템을 활용하여 특정 기능에 대한 개발자의 명시적 동의를 받고, 그에 따른 책임을 부과하는 설계 패턴이다. 각 마커 인터페이스가 부여하는 선언적 의도와 핵심 책임은 다음 표와 같이 요약할 수 있다.

| 마커 인터페이스 | 개발자의 선언 (의도) | 개발자의 핵심 책임 | 책임 불이행 시 주요 문제 |
| --- | --- | --- | --- |
| **`Serializable`** | "이 객체의 상태는 저장/복원되어도 안전하다." | `transient` 키워드로 제외 필드 지정 | 데이터 유실, 보안 취약점, `InvalidClassException` |
| **`Cloneable`** | "이 객체는 복제되어도 안전하다." | 참조 타입 필드의 '깊은 복사' 직접 구현 | 데이터 불일치 (Side Effect) |
| **`Remote`** | "이 객체는 원격 호출의 위험성을 인지했다." | 모든 메서드에 `RemoteException` 처리 | 원격 통신 장애 시 예외 처리 누락 |

현대 Java에서는 어노테이션(`@Annotation`)이 메타데이터를 표현하는 유연한 대안으로 부상했으나, `instanceof`를 통한 타입 계층 검사가 필요한 경우 마커 인터페이스는 여전히 유효하고 강력한 도구로 남는다. 개발자는 마커 인터페이스를 마주했을 때, 그 이름이 암시하는 기술적 책임과 제약사항을 반드시 숙고해야 한다.

---
