---
title: CPU vs I/O, Sync vs Async 가이드
description: 
author: laze
date: 2025-07-25 00:00:02 +0900
categories: [Dev, SpringWebflux]
tags: [SpringWebflux, CPU, I/O, Sync, Async]
---
# [개념 정리] Spring Webflux를 위한 첫걸음: CPU vs I/O, Sync vs Async 가이드

## 1. 서론: 왜 우리는 Webflux를 고민하게 되었을까?

수년 동안 Spring MVC는 Java 웹 개발의 표준이었습니다. '요청 당 스레드(Thread-per-Request)' 모델을 기반으로 한 이 방식은 직관적이고 안정적입니다.

하지만 수많은 마이크로서비스가 서로 통신하고, 대규모 동시 접속을 처리해야 하는 현대적인 웹 환경에서는 새로운 접근 방식이 필요해졌습니다.

Spring Webflux는 바로 이러한 요구에 부응하기 위해 등장한 '비동기(Asynchronous), 논블로킹(Non-Blocking)' 리액티브 스택입니다.

Webflux를 제대로 이해하고 사용하기 위해서는, 그 근간을 이루는 두 가지 큰 축인 "작업의 종류(CPU Bound vs. I/O Bound)"와 "작업을 처리하는 방식(Sync vs. Async)"을 명확히 구분해야 합니다.

## 2. 작업의 종류: 내 애플리케이션은 CPU와 I/O 중 어디에 시간을 더 많이 쓰는가?

### 2.1. CPU-Bound (CPU 집약적 작업)

- **정의:** 작업의 처리 시간이 대부분 CPU 연산에 의해 결정되는 경우. CPU가 쉴 틈 없이 계산을 수행합니다.
- **예시:** 복잡한 수학 계산, 대규모 데이터 암호화/복호화, 비디오 인코딩, 이미지 처리.
- **비유:** 한 명의 천재 수학자가 매우 어려운 문제를 풀고 있는 상황. 수학자는 100% 자신의 뇌(CPU)를 사용하며, 다른 어떤 것도 기다리지 않습니다.
- **특징과 오해:**
  - 이런 작업을 여러 스레드로 동시에 처리하면 **컨텍스트 스위칭(Context Switching)** 비용이 발생하여 오히려 성능이 저하될 수 있습니다. CPU 코어 개수만큼의 스레드로 순차 처리하는 것이 더 효율적일 때가 많습니다.
  - 컨텍스트 스위칭이란, CPU가 하나의 프로세스(스레드) 상태를 저장하고 다른 프로세스의 상태를 불러오는 과정으로, 이 전환에 비용이 발생합니다.

### 2.2. I/O-Bound (I/O 집약적 작업)

- **정의:** 작업의 처리 시간이 대부분 I/O(Input/Output) 작업의 대기 시간에 의해 결정되는 경우. CPU는 대부분 쉬고 있습니다.
- **예시:** 데이터베이스 조회, 외부 API 호출, 파일 읽기/쓰기 등 네트워크나 디스크 작업.
- **비유:** 한 명의 사서가 다른 도서관에 책을 요청하고, 그 책이 배달될 때까지 하염없이 기다리는 상황. 사서의 뇌(CPU)는 쉬고 있지만, 일은 끝나지 않았습니다.
- **Spring MVC의 접근법 (Thread-per-Request):**
  - Spring MVC는 이 '기다리는 사서' 문제를 해결하기 위해 '여러 명의 사서(스레드)를 고용'하는 전략을 사용합니다.
  - 요청이 들어올 때마다 스레드 풀(Thread Pool)에서 스레드를 하나씩 할당합니다. A 스레드가 DB 응답을 기다리는 동안, B 스레드는 다른 요청을 받아 CPU를 사용합니다.
  - **한계:** 요청 수가 스레드 풀의 최대 스레드 수를 초과하면, 남은 요청들은 스레드가 반납될 때까지 대기해야 합니다. 수만 개의 동시 요청이 들어오면 수만 개의 스레드가 필요하게 되고, 이는 메모리 고갈(OOM)로 이어집니다.

> 대부분의 현대 웹 애플리케이션은 여러 마이크로서비스를 호출하는 등, I/O-Bound 작업의 비중이 압도적으로 높습니다.
>

## 3. 작업을 처리하는 방식: Sync vs Async, Blocking vs Non-Blocking

이 네 가지 용어는 종종 혼용되지만, 명확히 다른 개념입니다.

- **Blocking vs. Non-Blocking:** I/O 작업을 호출하는 '커널 레벨'의 이야기입니다. 호출한 함수가 I/O 작업이 끝날 때까지 즉시 결과를 반환하는지, 아니면 일단 반환하고 나중에 알려주는지에 대한 것입니다.
- **Sync vs. Async:** 전체 작업의 '애플리케이션 레벨'의 이야기입니다. 한 작업의 결과를 다음 작업이 계속 확인하며 기다리는지, 아니면 결과가 준비되면 콜백(Callback)이나 이벤트를 통해 알려주는지에 대한 것입니다.

### 3.1. Synchronous + Blocking (동기-블로킹) - "전화하고 끝날 때까지 기다리기"

- **이것이 바로 Spring MVC 모델입니다.**
- **동작:**
  1. 애플리케이션 스레드가 DB에 쿼리를 요청합니다 (I/O 호출).
  2. 커널은 DB로부터 데이터가 올 때까지 **애플리케이션 스레드를 멈춥니다 (Blocking).**
  3. 애플리케이션 스레드는 다른 일을 하지 못하고 **결과가 올 때까지 계속 기다립니다 (Synchronous).**
  4. 데이터가 오면, 멈췄던 스레드가 깨어나 다음 작업을 처리합니다.
- **장점:** 코드가 직관적이고 디버깅이 쉽다.
- **단점:** 스레드가 I/O 대기 시간 동안 아무 일도 못하고 자원만 차지한다. 높은 동시성 처리에 불리하다.

### 3.2. Asynchronous + Non-Blocking (비동기-논블로킹) - "문자 보내고 나중에 알림 받기"

- **이것이 바로 Spring Webflux 모델입니다.**
- **동작:**
  1. 애플리케이션 스레드(이벤트 루프)가 커널에 I/O 작업을 요청하고, **즉시 반환받습니다 (Non-Blocking).** 스레드는 멈추지 않습니다.
  2. 애플리케이션 스레드는 다른 요청을 처리하는 등 자신의 일을 계속합니다.
  3. 커널은 백그라운드에서 I/O 작업을 처리하고, 작업이 완료되면 **애플리케이션에 이벤트(알림)를 보냅니다.**
  4. 이벤트를 받은 애플리케이션 스레드가 콜백 함수를 실행하여 결과를 처리합니다 **(Asynchronous).**

## 4. Webflux의 비밀 무기: I/O 멀티플렉싱과 이벤트 루프

"어떻게 적은 수의 스레드로 수많은 요청을 처리할 수 있는가?" 라는 질문에 대한 답이 바로 I/O 멀티플렉싱(Multiplexing)입니다.

- **비유:** 한 명의 유능한 보안 요원(이벤트 루프 스레드)이 수백 개의 CCTV 모니터(소켓 연결)를 동시에 감시하는 상황. 요원은 모든 모니터를 계속 쳐다보지 않습니다. 대신, 특정 모니터에서 움직임(I/O 이벤트)이 감지될 때만 그쪽으로 가서 처리하고, 다시 전체를 감시하는 상태로 돌아갑니다.
- **동작 원리:**
  1. 애플리케이션은 처리해야 할 모든 소켓(연결)을 커널에 '이벤트 등록'을 합니다. ("이 소켓들에서 읽을 데이터가 생기면 알려줘!")
  2. **단 하나의 이벤트 루프 스레드**가 커널에 "등록된 이벤트 중에 발생한 거 있니?"라고 물어보고 대기합니다.
  3. 커널은 여러 소켓 중 어느 하나라도 이벤트가 발생하면, 이벤트 루프 스레드를 깨워 어떤 소켓에서 이벤트가 발생했는지 알려줍니다.
  4. 이벤트 루프 스레드는 해당 소켓의 데이터를 읽는 등 최소한의 I/O 작업을 처리하고, 복잡한 비즈니스 로직은 별도의 워커 스레드 풀에 위임한 후, 다시 2번으로 돌아가 다른 이벤트를 기다립니다.

이 모델 덕분에, **소수의 고정된 스레드만으로 수만 개의 동시 연결을 효율적으로 처리**할 수 있게 됩니다.

## 5. 결론: 그래서, Spring MVC or Webflux?

| 구분 | Spring MVC (Sync-Blocking) | Spring Webflux (Async/Non-Blocking) |
| --- | --- | --- |
| **기반 모델** | Thread-per-Request (서블릿 스택) | Event Loop (Netty 등) |
| **주요 장점** | 코드 직관성, 쉬운 디버깅, 풍부한 라이브러리 생태계 | 높은 동시성 처리, 적은 리소스 사용 |
| **적합한 작업** | - **Blocking I/O**가 필수인 경우 (e.g., **JPA**)
- CPU-Bound 작업이 많은 경우
- 개발 속도가 중요하고 코드가 단순한 경우 | - **Non-Blocking I/O** 기반의 서비스
- 다수의 외부 API 호출 등 I/O-Bound 작업이 지배적인 경우
- 대규모 동시 접속 처리가 필요한 경우 (채팅, 스트리밍 등) |
  | **주의사항** | 스레드 개수가 동시성 처리의 한계 | **이벤트 루프를 절대 막으면 안 됨(Don't block the event loop!)**. 모든 호출 스택이 Non-Blocking을 지원해야 함. |

**결론적으로, 선택의 기준은 '성능'이 아니라 '아키텍처'입니다.**
내부 로직이 복잡하고 JPA처럼 블로킹 라이브러리를 사용해야 한다면, Spring MVC는 여전히 훌륭하고 안정적인 선택입니다. 반면, 수많은 외부 서비스와 비동기적으로 통신하며 높은 동시성을 처리해야 하는 MSA 환경이라면, Spring Webflux는 더 적은 리소스로 더 높은 효율을 낼 수 있는 강력한 대안이 될 것입니다.
